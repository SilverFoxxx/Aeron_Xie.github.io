<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>初探NSURLProtocol | Aeron_Xie</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="NSURLProtocol 是 URL Loading System 中的一部分, 但是它十分的强大和牛逼, 可以说是苹果又一大黑魔法了, 它能够拦截所有的 URL Loading System发出的网络请求, 拦截之后就可以做各种自定义处理. 下面就来看下这个神奇的东西。。。">
<meta property="og:type" content="article">
<meta property="og:title" content="初探NSURLProtocol">
<meta property="og:url" content="http://yoursite.com/2017/10/16/初探NSURLProtocol/index.html">
<meta property="og:site_name" content="Aeron_Xie">
<meta property="og:description" content="NSURLProtocol 是 URL Loading System 中的一部分, 但是它十分的强大和牛逼, 可以说是苹果又一大黑魔法了, 它能够拦截所有的 URL Loading System发出的网络请求, 拦截之后就可以做各种自定义处理. 下面就来看下这个神奇的东西。。。">
<meta property="og:image" content="http://7xoijj.com1.z0.glb.clouddn.com/nsobject_hierarchy_2x.png">
<meta property="og:updated_time" content="2017-10-16T06:09:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="初探NSURLProtocol">
<meta name="twitter:description" content="NSURLProtocol 是 URL Loading System 中的一部分, 但是它十分的强大和牛逼, 可以说是苹果又一大黑魔法了, 它能够拦截所有的 URL Loading System发出的网络请求, 拦截之后就可以做各种自定义处理. 下面就来看下这个神奇的东西。。。">
  
    <link rel="alternative" href="/atom.xml" title="Aeron_Xie" type="application/atom+xml">
  
  
    <link rel="icon" href="img/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Aeron_Xie</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/aeronxie" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/1919135421/home?wvr=5" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/xie-fei-75-92" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="https://mail.google.com/mail/#inbox" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Block/" style="font-size: 10px;">Block</a> <a href="/tags/C/" style="font-size: 12.5px;">C++</a> <a href="/tags/CentOS/" style="font-size: 10px;">CentOS</a> <a href="/tags/CocoaPods/" style="font-size: 10px;">CocoaPods</a> <a href="/tags/GCD/" style="font-size: 10px;">GCD</a> <a href="/tags/Git/" style="font-size: 12.5px;">Git</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/KVC/" style="font-size: 10px;">KVC</a> <a href="/tags/Mach-O/" style="font-size: 12.5px;">Mach-O</a> <a href="/tags/NSURL/" style="font-size: 10px;">NSURL</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/Objc/" style="font-size: 10px;">Objc</a> <a href="/tags/Objective-C/" style="font-size: 17.5px;">Objective-C</a> <a href="/tags/PPTP/" style="font-size: 10px;">PPTP</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Reactivecocoa/" style="font-size: 10px;">Reactivecocoa</a> <a href="/tags/Reveal/" style="font-size: 10px;">Reveal</a> <a href="/tags/Runloop/" style="font-size: 10px;">Runloop</a> <a href="/tags/Runtime/" style="font-size: 10px;">Runtime</a> <a href="/tags/VPN/" style="font-size: 10px;">VPN</a> <a href="/tags/VPS/" style="font-size: 10px;">VPS</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/iOS11/" style="font-size: 10px;">iOS11</a> <a href="/tags/lock/" style="font-size: 10px;">lock</a> <a href="/tags/runtime/" style="font-size: 15px;">runtime</a> <a href="/tags/verson/" style="font-size: 10px;">verson</a> <a href="/tags/传感器/" style="font-size: 10px;">传感器</a> <a href="/tags/动画/" style="font-size: 10px;">动画</a> <a href="/tags/推送/" style="font-size: 10px;">推送</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/腾讯/" style="font-size: 10px;">腾讯</a> <a href="/tags/通知/" style="font-size: 10px;">通知</a> <a href="/tags/链表/" style="font-size: 10px;">链表</a> <a href="/tags/随笔/" style="font-size: 12.5px;">随笔</a> <a href="/tags/面试/" style="font-size: 12.5px;">面试</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://laichanwai.github.io/">Ivy的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://maru-zhang.github.io">maru的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/b82d2721ba07/latest_articles">叶孤城的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.onevcat.com/">喵神的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://kittenyang.com/">Kitten Yong的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.ibireme.com/">Ibireme的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.sunnyxx.com/">我就叫Sunny的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.devtang.com/">唐巧的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.desgard.com/">瓜的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://draveness.me/">Draveness的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://southpeak.github.io/">南峰子的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/u/12201cdd5d7a">冰霜的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/u/3e55748920d2">Bestswift的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.cnbang.net/">bang神</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://fullstack.blog/">fullstack</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">一个二流大学喜欢iOS开发的一个大学生，喜欢各种新鲜事物，会android \ swift \ python \ java \ C \ javascript \ mysql \ jsp单词的拼写~~~~</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Aeron_Xie</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Aeron_Xie</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/aeronxie" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/1919135421/home?wvr=5" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/xie-fei-75-92" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="https://mail.google.com/mail/#inbox" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-初探NSURLProtocol" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/16/初探NSURLProtocol/" class="article-date">
  	<time datetime="2017-10-16T03:39:27.000Z" itemprop="datePublished">2017-10-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      初探NSURLProtocol
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NSURL/">NSURL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p> NSURLProtocol 是 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">URL Loading System</a> 中的一部分, 但是它十分的强大和牛逼, 可以说是苹果又一大黑魔法了, 它能够拦截所有的 <code>URL Loading System</code>发出的网络请求, 拦截之后就可以做各种自定义处理. 下面就来看下这个神奇的东西。。。</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是NSURLProtocol">什么是NSURLProtocol</h2><p><code>NSURLProtocol</code>是<code>URL Loading System</code>的一个重要组成部分, 看下官方给的结构图:</p>
<p><img src="http://7xoijj.com1.z0.glb.clouddn.com/nsobject_hierarchy_2x.png" alt=""></p>
<p>URL加载系统包括<code>URL加载</code>、<code>认证&amp;证书</code>、<code>配置管理</code>、<code>缓存管理</code>、<code>Cookie存储</code>和<code>协议支持</code>这几个部分. <code>NSURLProtocol</code>看起来像是一个协议, 但是其并不是一个<code>Protocol</code>, 而是一个<code>Class</code>, 而且是一个<code>Abstract Class</code>. 来看下官方对它的解释:</p>
<blockquote>
<p>An NSURLProtocol object handles the loading of protocol-specific URL data. The NSURLProtocol class itself is an abstract class that provides the infrastructure for processing URLs with a specific URL scheme. You create subclasses for any custom protocols or URL schemes that your app supports.</p>
</blockquote>
<p>每一个<code>HTTP</code>请求开始时，<code>URL Loading System</code>就会创建一个合适的 <code>NSURLProtocol</code>对象处理对应的<code>URL</code>请求，我们不需要直接实例化一个<code>NSURLProtocol</code>子类, 而我们需要做的就是写一个继承自<code>NSURLProtocol</code>的类，并实现合适的抽象方法, 通过<code>-registerClass:</code>方法注册我们的协议类，然后<code>URL Loading System</code>就会在请求发出时使用我们创建的协议对象对该请求进行处理, 也就是说, 最后我们只需要写好继承自<code>NSURLProtocol</code>的子类即可.</p>
<h2 id="NSURLProtocol的使用">NSURLProtocol的使用</h2><blockquote>
<p><code>NSURLProtocol</code>是如何实例化的？</p>
<p>那么<code>NSURLProtocol</code>是如何拦截<code>HTTP</code>请求的 ？</p>
<p>如何决定哪些请求需要处理哪些请求不需要处理？</p>
<p>对需要处理的请求做哪些操作？</p>
<p>如何发出<code>HTTP</code>请求后并且将<code>response</code>传递给调用者？</p>
</blockquote>
<p>首先来看下, <code>NSURLProtocol</code>都提供有哪些API.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request cachedResponse:(nullable <span class="built_in">NSCachedURLResponse</span> *)cachedResponse client:(nullable <span class="keyword">id</span> &lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startLoading;</span><br><span class="line">- (<span class="keyword">void</span>)stopLoading;</span><br><span class="line"></span><br><span class="line">+ (nullable <span class="keyword">id</span>)propertyForKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">+ (<span class="keyword">void</span>)setProperty:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSMutableURLRequest</span> *)request;</span><br><span class="line">+ (<span class="keyword">void</span>)removePropertyForKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSMutableURLRequest</span> *)request;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)registerClass:(Class)protocolClass;</span><br><span class="line">+ (<span class="keyword">void</span>)unregisterClass:(Class)protocolClass;</span><br></pre></td></tr></table></figure>
<p>之前说到过 <code>NSURLProtocol</code> 是一个抽象类，所以不能够直接使用必须被子类化之后才能使用.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomURLProtocol</span> : <span class="title">NSURLProtocol</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>之后需要注册它</p>
<p><code>[NSURLProtocol registerClass:[CustomURLProtocol class]]</code></p>
<h4 id="注册完成之后我们需要在子类中实现一些方法">注册完成之后我们需要在子类中实现一些方法</h4><ul>
<li><code>+ (BOOL)canInitWithRequest:(NSURLRequest *)request</code></li>
</ul>
<p>每一次请求都会有一个<code>NSURLRequest</code>实例，通过拿到请求对象，我们就可以根据对应的请求选择是否处理该对象. 这个方法主要是说明你是否打算处理对应的<code>request</code>，如果不处理，返回<code>NO</code>，<code>URL Loading System</code>会使用系统默认的行为去处理；如果打算处理，则返回<code>YES</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey: URLProtocolKey inRequest:request]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *scheme = [[request URL] scheme];</span><br><span class="line">    <span class="keyword">if</span> ([scheme caseInsensitiveCompare:<span class="string">@"http"</span>] == <span class="built_in">NSOrderedSame</span> || [scheme caseInsensitiveCompare:<span class="string">@"https"</span>] == <span class="built_in">NSOrderedSame</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这表示我们只处理<code>http</code>和<code>https</code>请求, 发现有一个<code>[NSURLProtocol propertyForKey:protocolKey inRequest:request]</code>判断, 这个方法表示这个请求是否已经被请求过了, 为了防止死循环, 这个接下来会说到</p>
<ul>
<li><code>+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request</code></li>
</ul>
<p>在这个方法中，我们可以对<code>request</code>对象进行处理, 如修改头部信息、URL重定向、修改host等,最后返回一个处理后的<code>request实例</code>, 如果不处理我们也可以直接返回<code>request</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">	<span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b</code></li>
</ul>
<p>用于判断两个<code>request</code>是否相同，如果相同的话可以使用缓存数据，通常只需要调用父类的实现即可</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> requestIsCacheEquivalent:a toRequest:b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(nullable NSCachedURLResponse *)cachedResponse client:(nullable id &lt;NSURLProtocolClient&gt;)client</code></li>
</ul>
<p>该方法会创建一个<code>NSURLProtocol</code>实例，每一个网络请求都会创建一个新的实例, 在这里直接调用父类的方法，实例化一个对象并返回</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request cachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse client:(<span class="keyword">id</span> &lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client &#123;</span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> initWithRequest:request cachedResponse:cachedResponse client:client];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// we do somthing log here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>- (void)startLoading</code></li>
</ul>
<p>拦截到网络请求，并且对网络请求进行定制处理以后, 我们需要将网络请求重新发送出去, 该方法就是转发的核心方法, 在该方法中, 我们把处理过的<code>request</code>重新发送出去, 可以是基于<code>NSURLConnection</code>、<code>NSURLSession</code>甚至<code>CFNetwork</code>.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">	<span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [<span class="keyword">self</span><span class="variable">.request</span> mutableCopy];</span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES forKey:URLProtocolKey inRequest:mutableReqeust];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.connection</span> = [<span class="built_in">NSURLConnection</span> connectionWithRequest:mutableReqeust delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们又看到了<code>[NSURLProtocol setProperty:@YES forKey:URLProtocolKey inRequest:mutableReqeust]</code>,将这个<code>Property</code>设为了<code>YES</code>, 在<code>canInitWithRequest</code>需要判断, 为什么我们需要做这些个操作？ </p>
<p>因为<code>URL Loading System</code>在询问是否处理该请求的时候, 没加判断并返回了<code>YES</code>, 然后<code>URL Loading System</code>会创建一个<code>CustomURLProtocol</code>实例然后调用<code>startLoading</code>去获取数据, 重新发起一个请求, 然后又会走到<code>canInitWithRequest</code>,而在这个方法中又返回了<code>YES</code>,之后<code>URL Loading System</code>又会创建一个<code>CustomURLProtocol</code>实例, 然后就会出现无限循环下去. 所以我们应该保证每个<code>request</code>只被处理一次，所以需要通过<code>setProperty:forKey:inRequest:</code>标记那些已经处理过的<code>request</code>，然后在<code>canInitWithRequest:</code>中判断该<code>request</code>是否已经处理过了, 如果是则返回<code>NO</code></p>
<h4 id="如果我们拦截图片加载请求，本地有缓存的话就直接从本地加载没有再去请求,_我们可以这么做:">如果我们拦截图片加载请求，本地有缓存的话就直接从本地加载没有再去请求, 我们可以这么做:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [[<span class="keyword">self</span> request] mutableCopy];</span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES forKey: URLProtocolKey inRequest:mutableReqeust];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *imageKey = <span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span><span class="variable">.absoluteString</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *localPath = [[SNImageCache sharedImageCache] cachedPathForKey:imageKey];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:localPath];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">NSURLResponse</span> *response = [[<span class="built_in">NSURLResponse</span> alloc] initWithURL:mutableReqeust<span class="variable">.URL</span></span><br><span class="line">                                                            MIMEType:[<span class="built_in">NSData</span> sd_contentTypeForImageData:data]</span><br><span class="line">                                               expectedContentLength:data<span class="variable">.length</span></span><br><span class="line">                                                    textEncodingName:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.client</span> URLProtocol:<span class="keyword">self</span></span><br><span class="line">              didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.client</span> URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.client</span> URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.connection</span> = [<span class="built_in">NSURLConnection</span> connectionWithRequest:mutableReqeust delegate:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>- (void)stopLoading</code></li>
</ul>
<p>在请求完全结束之后取消对应的<code>request</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stopLoading &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.connection</span> cancel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSURLProtocolClient">NSURLProtocolClient</h3><p>当我们把<code>request</code>发送出去之后, 当收到网络请求的响应，我们怎么把返回值返回给原来发送网络请求的地方呢？</p>
<p>这时我们需要用到<code>client</code>这个对象, 每一个<code>client</code>都实现了<code>NSURLProtocolClient</code>协议, 我们把<code>response</code>告诉<code>client</code>，也就是<code>URL Loading System</code>，让他来继续处理这个<code>response</code>，因为一切都是基于<code>URL Loading System</code>发生的，所以把<code>response</code>交给他，他会自动处理这个<code>response</code>并返回给发送<code>request</code>的地方</p>
<p>那么这个协议都有一些什么方法呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol wasRedirectedToRequest:(<span class="built_in">NSURLRequest</span> *)request redirectResponse:(<span class="built_in">NSURLResponse</span> *)redirectResponse;</span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol cachedResponseIsValid:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse;</span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response cacheStoragePolicy:(<span class="built_in">NSURLCacheStoragePolicy</span>)policy;</span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didLoadData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line">- (<span class="keyword">void</span>)URLProtocolDidFinishLoading:(<span class="built_in">NSURLProtocol</span> *)protocol;</span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didFailWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge;</span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didCancelAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge;</span><br></pre></td></tr></table></figure>
<p>每一个<code>NSURLProtocol</code>的子类都有一个<code>client</code>对象来处理请求得到的<code>response</code>, 我们通常这样做, 就能将收到的消息通过<code>client</code>返回给<code>URL Loading System</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.client</span> URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.client</span> URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.client</span> URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.client</span> URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们是通过<code>NSURLConnection</code>请求的，所以需要通过其代理方法获取到数据, 在代理方法中将数据交给<code>client</code>，让其内部处理即可.</p>
<h2 id="需要注意的地方">需要注意的地方</h2><p>在使用<code>NSURLProtocol</code>的时候, 有几个坑是需要我们注意的:</p>
<ul>
<li><p><code>NSURLProtocol</code>可以拦截的网络请求包括<code>NSURLSession</code>，<code>NSURLConnection</code>以及<code>UIWebVIew</code>,基于<code>CFNetwork</code>的网络请求，以及<code>WKWebView</code>的请求是无法拦截的,详细可以查看<a href="http://www.openradar.me/search?query=nsurlprotocol" target="_blank" rel="external">这个网站</a>.<br><code>AFNetworking</code>，<code>Alamofire</code>等这些第三方网络库都是基于<code>NSURLSession</code>或<code>NSURLConnection</code>的，所以这些网络库的网络请求都可以被<code>NSURLProtocol</code>拦截.<code>ASIHTTPRequest</code>等网路库都是基于<code>CFNetwork</code>的，所以这些网络库的网络请求都无法被<code>NSURLProtocol</code>拦截</p>
</li>
<li><p>如果需要<code>NSURLProtocol</code>来截获<code>NSURLSession</code>发出的请求，需要每一个<code>NSURLSession</code>在创建时配置的<code>NSURLSessionConfiguration</code>类的<code>protocolClasses</code>属性设置为自定义的<code>NSURLProtocol</code></p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultSessionConfiguration &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    configuration<span class="variable">.protocolClasses</span> = @[[CustomURLProtocol class]];   </span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>苹果文档也说了<code>You cannot use custom NSURLProtocol subclasses in conjunction with background sessions.</code>对于后台<code>Sessions</code>，是不支持自定义的<code>NSURLProtocol</code>的</p>
<ul>
<li><p>记得在<code>canInitWithRequest</code>方法里判断<code>if ([NSURLProtocol propertyForKey:protocolKey inRequest:request]) {
  return NO;
}</code>, 在<code>startLoading</code>方法里设置<code>[NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];</code><br>防止无限循环</p>
</li>
<li><p>若一个项目中存在多个<code>NSURLProtocol</code>，那么<code>NSURLProtocol</code>的拦截顺序跟注册顺序有关,多个<code>NSURLProtocol</code>拦截顺序为注册顺序的倒序，也就是后注册的<code>NSURLProtocol</code>会先被拦截. 对于通过配置<code>NSURLSessionConfiguration</code>对象的<code>protocolClasses</code>属性来注册的,<br><code>protocolClasses</code>这个数组里只有第一个<code>NSURLProtocol</code>会起作用,其他的都无效, 我们看下<code>OHHTTPStubs</code>库在注册时是如何处理的:</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> * urlProtocolClasses = [<span class="built_in">NSMutableArray</span> arrayWithArray:sessionConfig<span class="variable">.protocolClasses</span>];</span><br><span class="line">Class protoCls = OHHTTPStubsProtocol<span class="variable">.class</span>;</span><br><span class="line"><span class="keyword">if</span> (![urlProtocolClasses containsObject:protoCls]) &#123;</span><br><span class="line">    [urlProtocolClasses insertObject:protoCls atIndex:<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [urlProtocolClasses removeObject:protoCls];</span><br><span class="line">&#125;</span><br><span class="line">sessionConfig<span class="variable">.protocolClasses</span> = urlProtocolClasses;</span><br></pre></td></tr></table></figure>
<p>把自己的<code>NSURLProtocol</code>插入到<code>protocolClasses</code>的第一个，进行拦截, 拦截完成之后，又对其进行移除, 保证需要拦截的时候, 自己是在数组的第一个.</p>
<p>到这里, 对<code>HTTP</code>请求进行拦截就结束了, 我们通过<code>NSURLProtocol</code>对<code>request</code>做了各种神奇的事情, 但是它的强大还不止这些. </p>
<h2 id="NSURLProtocol实现">NSURLProtocol实现</h2><p>了解了<code>NSURLProtocol</code>的使用之后, 我们再来看下它的内部实现. 这次依然用的是GNU源码.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableArray</span>	*registered = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSLock</span>		*regLock = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> Class		abstractClass = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> Class		placeholderClass = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSURLProtocol</span>	*placeholder = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">  <span class="keyword">if</span> (registered == <span class="literal">nil</span>) &#123;</span><br><span class="line">      abstractClass = [<span class="built_in">NSURLProtocol</span> class];</span><br><span class="line">      placeholderClass = [<span class="built_in">NSURLProtocolPlaceholder</span> class];</span><br><span class="line">      registered = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">      placeholder = (<span class="built_in">NSURLProtocol</span>*)<span class="built_in">NSAllocateObject</span>(placeholderClass, <span class="number">0</span>,</span><br><span class="line">	<span class="built_in">NSDefaultMallocZone</span>());</span><br><span class="line">      regLock = [<span class="built_in">NSLock</span> new];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_<span class="built_in">NSHTTPURLProtocol</span> class]];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_<span class="built_in">NSHTTPSURLProtocol</span> class]];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_<span class="built_in">NSFTPURLProtocol</span> class]];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_<span class="built_in">NSFileURLProtocol</span> class]];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_<span class="built_in">NSAboutURLProtocol</span> class]];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_<span class="built_in">NSDataURLProtocol</span> class]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类初始化的时候会初始化一些类, 发现会默认注册了几个<code>XXXURLProtocol</code>, 这些类都是什么? </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The URL loading system provides support <span class="keyword">for</span> accessing resources using the following protocols:</span><br><span class="line"></span><br><span class="line">File Transfer Protocol (ftp:<span class="comment">//)</span></span><br><span class="line">Hypertext Transfer Protocol (http:<span class="comment">//)</span></span><br><span class="line">Hypertext Transfer Protocol with encryption (https:<span class="comment">//)</span></span><br><span class="line">Local file URLs (file:<span class="comment">///)</span></span><br><span class="line">Data URLs (data:<span class="comment">//)</span></span><br></pre></td></tr></table></figure>
<p>这就是<code>URL loading system</code>支持的这几个协议, 但是还有一个<code>_NSAboutURLProtocol</code>, <code>about</code>协议, 这个协议应该是web浏览器一个内部的协议, 这可以显示关于浏览器的信息.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)registerClass:(Class)protocolClass &#123;</span><br><span class="line">  <span class="keyword">if</span> ([protocolClass isSubclassOfClass: [<span class="built_in">NSURLProtocol</span> class]] == <span class="literal">YES</span>) &#123;</span><br><span class="line">      [regLock lock];</span><br><span class="line">      [registered addObject: protocolClass];</span><br><span class="line">      [regLock unlock];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)unregisterClass:(Class)protocolClass &#123;</span><br><span class="line">	[regLock lock];</span><br><span class="line">	[registered removeObjectIdenticalTo: protocolClass];</span><br><span class="line">	[regLock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是注册函数的实现, 其内部很简单, 如果<code>protocolClass</code>是<code>NSURLProtocol</code>的子类的话, 就往<code>registered</code>数组里添加, <code>registered</code>是一个静态全局数组. 用于存放注册的类. 而反注册则是将注册过的类直接从<code>registered</code>中移除.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">	[<span class="keyword">self</span> subclassResponsibility: _cmd];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">	[<span class="keyword">self</span> subclassResponsibility: _cmd];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading &#123;</span><br><span class="line">	[<span class="keyword">self</span> subclassResponsibility: _cmd];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个都是抽象方法, 内部什么都没做, 需要子类覆盖实现的. 如果没有实现, <code>- subclassResponsibility:</code> 则会以<code>exception</code>形式告诉<code>Dev</code>子类忘记覆盖实现了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest: (<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">	<span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法则是默认直接返回<code>request</code>对象, 如果子类不需要特殊处理<code>request</code>的话可以不用覆盖.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b &#123;</span><br><span class="line">	  a = [<span class="keyword">self</span> canonicalRequestForRequest: a];</span><br><span class="line">	  b = [<span class="keyword">self</span> canonicalRequestForRequest: b];</span><br><span class="line">	  <span class="keyword">return</span> [a isEqual: b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>isEqual</code>判断, 两个<code>request</code>对象是不是同一个</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)setProperty:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSMutableURLRequest</span> *)request &#123;</span><br><span class="line">	[request _setProperty:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)propertyForKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">	<span class="keyword">return</span> [request _propertyForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个用于标记是否已经处理过请求的方法, 将<code>value</code>和<code>key</code>赋值给<code>request</code>, <code>request</code>是一个<code>NSURLRequest</code>对象, 其内部有一个<code>properties</code>可变字典, 用于存放标记过的<code>request</code>.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request cachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse client: (<span class="keyword">id</span> &lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client &#123;</span><br><span class="line">    </span><br><span class="line">    Class c = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (c == abstractClass || c == placeholderClass) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span>    count;</span><br><span class="line">        DESTROY(<span class="keyword">self</span>);</span><br><span class="line">        [regLock lock];</span><br><span class="line">        count = [registered count];</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Class proto = [registered objectAtIndex: count];</span><br><span class="line">            <span class="keyword">if</span> ([proto canInitWithRequest:request] == <span class="literal">YES</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span> = [proto alloc];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [regLock unlock];</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> initWithRequest: request</span><br><span class="line">                      cachedResponse: cachedResponse</span><br><span class="line">                              client: client];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">self</span> init]) != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;request = [request <span class="keyword">copy</span>];</span><br><span class="line">        <span class="keyword">this</span>-&gt;cachedResponse = RETAIN(cachedResponse);</span><br><span class="line">        <span class="keyword">this</span>-&gt;client = client;    <span class="comment">// Not retained</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>NSURLProtocol</code>的初始化方法, 如果当前类是<code>NSURLProtocol</code>或者是<code>NSURLProtocolPlaceholder</code>, 则将<code>registered</code>注册过的类从最后一个依次往前取出来(这就是之前说的为什么后注册的会先被拦截), 如果<code>canInitWithRequest:</code>返回<code>YES</code>, 则初始化<code>self</code>, 如果<code>self</code>不为空, 将赋值<code>reques</code>、<code>cachedResponse</code>和<code>client</code> , 并返回.</p>
<h3 id="PS:_通过对NSURLProtocol的使用和内部实现进行了学习，又get到了一个黑魔法~~~">PS: 通过对NSURLProtocol的使用和内部实现进行了学习，又get到了一个黑魔法~~~</h3>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/05/深入理解KVC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          深入理解KVC
        
      </div>
    </a>
  
  
    <a href="/2017/10/08/深入理解NSNotificationCenter/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">深入理解NSNotificationCenter</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="初探NSURLProtocol" data-title="初探NSURLProtocol" data-url="http://yoursite.com/2017/10/16/初探NSURLProtocol/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"aeronxie"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Aeron_Xie
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>