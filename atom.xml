<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aeron_Xie</title>
  
  
  <link href="http://aeronxie.github.io/atom.xml" rel="self"/>
  
  <link href="http://aeronxie.github.io/"/>
  <updated>2023-03-25T14:39:55.557Z</updated>
  <id>http://aeronxie.github.io/</id>
  
  <author>
    <name>Aeron_Xie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Flutter Key</title>
    <link href="http://aeronxie.github.io/post/1ef5fef8.html"/>
    <id>http://aeronxie.github.io/post/1ef5fef8.html</id>
    <published>2019-09-01T07:57:56.000Z</published>
    <updated>2023-03-25T14:39:55.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不知不觉，发现距离上一次发文章已经一年多了，自从换了新公司之后，每天都是挺充实的，额。。别找理由。。就是懒~所以今年重新捡起这个博客，继续不间断更新最近都在研究Flutter相关的东西，接下来的文章应该都围绕Flutter</p></blockquote><span id="more"></span><blockquote><p>平时我们在使用Widget的时候，构造方法都会有一个Key这么个参数，但是我们一般都不会传这个参数，那么这个参数到底有什么用呢？ 下面就来研究下这个东东:</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们先来看下官方对Key的介绍：</p><ul><li>它是 Widgets, Elements and SemanticsNodes 的标识符</li><li>当新Widget的Key和Element相关联的当前Widget的Key相等时，才会将Element关联的Widget更新成最新的Widget</li><li>具有相同Parent的Elements，Key必须唯一</li><li>它有两个子类 LocalKey 和 GlobalKey</li></ul><ol><li>它决定一个Widget如何替换另一个Widget</li><li>如果两个Widget的runtimeType和key属性都相等的情况下，则新的widget通过更新Element（即通过使用新的Widget调用 [Element.update]）来替换旧的Widget。否则，旧的element将从树中被移除，新的Widget将被扩充到一个新的Element中，这个新的Element将被插入树中。</li><li>用GlobalKey作为Widget的Key是时，Element可以在Tree周围移动（即改变Parent）而不丢失状态。当找到新的Widget(它的key和type与相同位置的先前Widget前不匹配)，但在前一帧的树中的其他位置存在具有相同GlobalKey的Widget时，则将该Widget的Element移动到新的位置</li><li>一个Widget只有一个child的时候，这个child是不需要Key的</li></ol><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>通过上面的介绍我们大概能知道Key的作用，但是在Flutter中，有这么一些Key，我们先来看到底有哪些key：</p><p><img src="/images/flutter_key.png"></p><h4 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">factory</span> Key(<span class="built_in">String</span> value) = ValueKey&lt;<span class="built_in">String</span>&gt;;</span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">const</span> Key.empty();</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">Key是一个抽象类，只要一个工厂构造方法和一个常量构造方法</span><br><span class="line"></span><br><span class="line">#### LocalKey</span><br><span class="line">```dart </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalKey</span> <span class="keyword">extends</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Default constructor, used by subclasses.</span></span></span><br><span class="line">  <span class="keyword">const</span> LocalKey() : <span class="keyword">super</span>.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalKey继承自Key，它也是一个抽象类，只有一个构造方法</p><h4 id="ValueKey"><a href="#ValueKey" class="headerlink" title="ValueKey"></a>ValueKey</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueKey</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">LocalKey</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a key that delegates its [operator==] to the given value.</span></span></span><br><span class="line">  <span class="keyword">const</span> ValueKey(<span class="keyword">this</span>.value);</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The value to which this key delegates its [operator==]</span></span></span><br><span class="line">  <span class="keyword">final</span> T value;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">dynamic</span> other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other.runtimeType != runtimeType)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> ValueKey&lt;T&gt; typedOther = other;</span><br><span class="line">    <span class="keyword">return</span> value == typedOther.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> hashCode =&gt; hashValues(runtimeType, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ValueKey集成自LocalKey，构造方法需要传入一个value，这个value是一个泛型类，重写了==方法和hash方法，只有runtimeType跟value都相等的情况下，ValueKey才会被认为相等</p><h4 id="PageStorageKey"><a href="#PageStorageKey" class="headerlink" title="PageStorageKey"></a>PageStorageKey</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageStorageKey</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ValueKey</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a [ValueKey] that defines where [PageStorage] values will be saved.</span></span></span><br><span class="line">  <span class="keyword">const</span> PageStorageKey(T value) : <span class="keyword">super</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PageStorageKey是继承自ValueKey，传入一个value，它是用于保存Scrollable的偏移<br>Scrollable(实际是ScrollPositions)使用PageStorage保存它们的滚动偏移，每次滚动完成时，存储的滚动信息都会更新。<br>PageStorage用于保存和恢复比widget生命周期更长的值，这些值存储在per-route Map中，它的key由widget及它的祖先的PageStorageKeys定义</p><h4 id="ObjectKey"><a href="#ObjectKey" class="headerlink" title="ObjectKey"></a>ObjectKey</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectKey</span> <span class="keyword">extends</span> <span class="title">LocalKey</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a key that uses [identical] on [value] for its [operator==].</span></span></span><br><span class="line">  <span class="keyword">const</span> ObjectKey(<span class="keyword">this</span>.value);</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The object whose identity is used by this key&#x27;s [operator==].</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Object</span> value;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">dynamic</span> other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other.runtimeType != runtimeType)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> ObjectKey typedOther = other;</span><br><span class="line">    <span class="keyword">return</span> identical(value, typedOther.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> hashCode =&gt; hashValues(runtimeType, identityHashCode(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectKey也是集成自LocalKey，而且构造方法也是需要传入一个value，但是这个value是Object类型的，也就是说可以传任意类型，identical 方法返回的是两个Object的hashCode是否相等，当runtimeType跟value.hashCode都相等的情况下，ObjectKey才会被认为相等，它跟ValueKey的区别在于它比较的是value的引用，而ValueKey是直接比较值</p><h4 id="UniqueKey"><a href="#UniqueKey" class="headerlink" title="UniqueKey"></a>UniqueKey</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">A key that is only equal to itself.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniqueKey</span> <span class="keyword">extends</span> <span class="title">LocalKey</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a key that is equal only to itself.</span></span></span><br><span class="line">  <span class="comment">// ignore: prefer_const_constructors_in_immutables , never use const for this class</span></span><br><span class="line">  UniqueKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>UniqueKey也是继承自LocalKey, 而且只有一个构造方法，注释也写的很清楚了，它会生成一个唯一的hash，只跟自己相等</p><h4 id="GlobalKey"><a href="#GlobalKey" class="headerlink" title="GlobalKey"></a>GlobalKey</h4><p>简单介绍下：</p><ul><li>GlobalKey唯一标识Elements，它提供了与Element相关联的访问，如BuildContext、State（对于StatefulWidget）</li><li>不要在两个Widget中使用相同的GlobalKey</li><li>Global keys 是很昂贵的，如果你不需要访问BuildContext、Element、State这些的话，请尽量使用[Key], [ValueKey], [ObjectKey] 或者  [UniqueKey]</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalKey</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulWidget</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a [LabeledGlobalKey], which is a [GlobalKey] with a label used for</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">debugging.</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The label is purely for debugging and not used for comparing the identity</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">of the key.</span></span></span><br><span class="line">  <span class="keyword">factory</span> GlobalKey(&#123; <span class="built_in">String</span> debugLabel &#125;) =&gt; LabeledGlobalKey&lt;T&gt;(debugLabel);</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a global key without a label.</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Used by subclasses because the factory constructor shadows the implicit</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">constructor.</span></span></span><br><span class="line">  <span class="keyword">const</span> GlobalKey.constructor() : <span class="keyword">super</span>.empty();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;GlobalKey, <span class="built_in">Element</span>&gt; _registry = &lt;GlobalKey, <span class="built_in">Element</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _register(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    _registry[<span class="keyword">this</span>] = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _unregister(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_registry[<span class="keyword">this</span>] == element)</span><br><span class="line">      _registry.remove(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Element</span> <span class="keyword">get</span> _currentElement =&gt; _registry[<span class="keyword">this</span>];</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The build context in which the widget with this key builds.</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The current context is null if there is no widget in the tree that matches</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">this global key.</span></span></span><br><span class="line">  BuildContext <span class="keyword">get</span> currentContext =&gt; _currentElement;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The widget in the tree that currently has this global key.</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The current widget is null if there is no widget in the tree that matches</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">this global key.</span></span></span><br><span class="line">  Widget <span class="keyword">get</span> currentContext =&gt; _currentElement?.widget;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The [State] for the widget in the tree that currently has this global key.</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The current state is null if (1) there is no widget in the tree that</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">matches this global key, (2) that widget is not a [StatefulWidget], or the</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">associated [State] object is not a subtype of <span class="code">`T`</span>.</span></span></span><br><span class="line">  T <span class="keyword">get</span> currentState &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> element = _currentElement;</span><br><span class="line">    <span class="keyword">if</span> (element <span class="keyword">is</span> StatefulElement) &#123;</span><br><span class="line">      <span class="keyword">final</span> StatefulElement statefulElement = element;</span><br><span class="line">      <span class="keyword">final</span> State state = statefulElement.state;</span><br><span class="line">      <span class="keyword">if</span> (state <span class="keyword">is</span> T)</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下实现，我去掉了一些用于debug和异常判断的代码，为了方便查看，GlobalKey继承自Key，一个工厂构造方法（可以传入一个用于debug的string，内部使用LabeledGlobalKey）和一个常量构造方法，内部有几个属性，意味着你可以访问到currentContext、currentContext和currentState（如果是StatefullWidget），有一个_register和_unregister方法，他们都在什么时候被调用呢？<br>在Element被mount到树上的时候调用_register，如果是类型是GlobalKey，那么Element就会加入到一个静态Map里，unmount的时候调用_unregister被移除</p><h4 id="LabeledGlobalKey"><a href="#LabeledGlobalKey" class="headerlink" title="LabeledGlobalKey"></a>LabeledGlobalKey</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LabeledGlobalKey</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulWidget</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">GlobalKey</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a global key with a debugging label.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The label does not affect the key&#x27;s identity.</span></span></span><br><span class="line">  <span class="comment">// ignore: prefer_const_constructors_in_immutables , never use const for this class</span></span><br><span class="line">  LabeledGlobalKey(<span class="keyword">this</span>._debugLabel) : <span class="keyword">super</span>.constructor();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _debugLabel;</span><br><span class="line">&#125;</span><br><span class="line">LabeledGlobalKey继承自GlobalKey，并提供一个用于debugger的LabelString，GlobalKey的工厂构造方法就是采用LabeledGlobalKey来构造的</span><br><span class="line">GlobalObjectKey</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalObjectKey</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulWidget</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">GlobalKey</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a global key that uses [identical] on [value] for its [operator==].</span></span></span><br><span class="line">  <span class="keyword">const</span> GlobalObjectKey(<span class="keyword">this</span>.value) : <span class="keyword">super</span>.constructor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The object whose identity is used by this key&#x27;s [operator==].</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Object</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">dynamic</span> other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other.runtimeType != runtimeType)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> GlobalObjectKey&lt;T&gt; typedOther = other;</span><br><span class="line">    <span class="keyword">return</span> identical(value, typedOther.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> hashCode =&gt; identityHashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GlobalObjectKey继承自GlobalKey，提供一个value值，在构造的时候可以传入任意一个对象，当runtimeType跟value.hashCode都相等的时候GlobalObjectKey被认为相等</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="ValueKey-1"><a href="#ValueKey-1" class="headerlink" title="ValueKey"></a>ValueKey</h3><p>当你要使用请求数据或者id作为唯一标识的时候就可以使用ValueKey</p><h3 id="ObjectKey-1"><a href="#ObjectKey-1" class="headerlink" title="ObjectKey"></a>ObjectKey</h3><p>当有一个对象的属性值有可能相同时，这时候你无法保证给 Key 的值每次都会不同，但是，当这些属性组合起来的 Object 将具有唯一性，这时你可以使用ObjectKey</p><h3 id="UniqueKey-1"><a href="#UniqueKey-1" class="headerlink" title="UniqueKey"></a>UniqueKey</h3><p>如果 ObjectKey 都无法满足唯一性的时候，又想要确保每一个 Key 都具有唯一性，那么，你可以使用 UniqueKey，它将会通过该对象生成一个具有唯一性的 hashCode<br>不过这样做，每次 Widget 被构建时都会去重新生成一个新的 UniqueKey</p><h3 id="GlobalKey-1"><a href="#GlobalKey-1" class="headerlink" title="GlobalKey"></a>GlobalKey</h3><p>当你想要跨Widget访问状态时，或者Element，就可以使用GlobalKey，但是它使用比较昂贵，一般情况下能用以上三种Key解决的，尽量不要使用它，特别是在列表中使用GlobalKey，这会造成性能的损失</p><h3 id="PageStorageKey-1"><a href="#PageStorageKey-1" class="headerlink" title="PageStorageKey"></a>PageStorageKey</h3><p>可以记录滚动Widget的滚动偏移，如果你需要保存滚动的位置的时候可以使用PageStorageKey</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;不知不觉，发现距离上一次发文章已经一年多了，自从换了新公司之后，每天都是挺充实的，额。。别找理由。。就是懒~所以今年重新捡起这个博客，继续不间断更新最近都在研究Flutter相关的东西，接下来的文章应该都围绕Flutter&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Flutter" scheme="http://aeronxie.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>NSFastEnumeration</title>
    <link href="http://aeronxie.github.io/post/a454a4e0.html"/>
    <id>http://aeronxie.github.io/post/a454a4e0.html</id>
    <published>2018-04-07T15:13:33.000Z</published>
    <updated>2023-03-25T14:39:55.798Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好久没写些什么东西了，似乎快有半年了吧。也不知道要写些什么，最近也跳槽了，复习了一段时间，所以应该重新开启新的行程了。<br>废话不多说，今天来研究下<code>NSFastEnumeration</code>这个协议。</p></blockquote><span id="more"></span><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>遍历集合一般都想到使用<code>for</code>循环，这是一个很基本的办法，因此功能十分有限，通常会这样写代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.count; i++) &#123;</span><br><span class="line"><span class="type">id</span> obj = array[i];</span><br><span class="line"><span class="comment">// Do something with `obj`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们要遍历字典，就会先获取到字典所有的<code>key</code>，然后再通过<code>key</code>获取<code>value</code>,因为字典是无序的，所以无法根据特点的整数下标来直接访问其中的值. 这样就需要转化，就很麻烦。</p><h2 id="NSEnumerator"><a href="#NSEnumerator" class="headerlink" title="NSEnumerator"></a>NSEnumerator</h2><p>在<code>Objective-C 1.0</code>的时候，我们可以使用<code>NSEnumerator</code>来遍历， <code>NSEnumerator</code>是个抽象类，只定义了1个方法和一个属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> ObjectType)nextObject;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;ObjectType&gt; *allObjects;</span><br></pre></td></tr></table></figure><p>如果我们想遍历数组，可以这样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="built_in">NSEnumerator</span> *enumerator = [array objectEnumerator];</span><br><span class="line"><span class="type">id</span> obj;</span><br><span class="line"><span class="keyword">while</span> ((obj = [enumerator nextObject]) != <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="comment">// Do something with `obj`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法与<code>for</code>循环差不多，但是代码量似乎变多了</p><h2 id="NSFastEnumeration"><a href="#NSFastEnumeration" class="headerlink" title="NSFastEnumeration"></a>NSFastEnumeration</h2><p>在<code>Objective-C 2.0</code>引入了一种快速遍历的方法，我们可以直接使用<code>for in</code>关键字</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">id</span> obj <span class="keyword">in</span> array) &#123;</span><br><span class="line"><span class="comment">// Do something with `obj`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写是不是就简单了很多。但是这个<code>for in</code>只是一个语法糖, 但是具体底层是怎么实现的呢？ 我们先来看一下<code>NSArray</code>类的头文件<code>NSArray&lt;__covariant ObjectType&gt; : NSObject &lt;NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration&gt;</code> 会发现它实现了<code>NSFastEnumeration</code>这么个协议。也正是这个协议，支持了<code>for in</code>这种语法。</p><p>这个协议只有一个方法和一个结构体。</p><p><code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained _Nullable [_Nonnull])buffer count:(NSUInteger)len; </code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">    <span class="type">id</span> __<span class="keyword">unsafe_unretained</span> _Nullable * _Nullable itemsPtr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> * _Nullable mutationsPtr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> extra[<span class="number">5</span>];</span><br><span class="line">&#125; <span class="built_in">NSFastEnumerationState</span>;</span><br></pre></td></tr></table></figure><p>看到这个结构体。。。简直一脸懵逼。。。这是个什么玩意？ 于是只能去查下官方文档了，在官方<a href="https://developer.apple.com/library/content/samplecode/FastEnumerationSample/Introduction/Intro.html">demo</a>中我们看到了这个协议方法的实现，跟这个结构体的含义。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)countByEnumeratingWithState:(<span class="built_in">NSFastEnumerationState</span> *)state</span><br><span class="line">  objects:(<span class="type">id</span> __<span class="keyword">unsafe_unretained</span> [])stackbuf</span><br><span class="line">count:(<span class="built_in">NSUInteger</span>)stackbufLength &#123;</span><br><span class="line"><span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 使用 state-&gt;state 来保存当前遍历到了 _list 的什么位置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> countOfItemsAlreadyEnumerated = state-&gt;state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 countOfItemsAlreadyEnumerated 为 0 时，表示第一次调用这个方法</span></span><br><span class="line"><span class="keyword">if</span>(countOfItemsAlreadyEnumerated == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// state-&gt;mutationsPtr 是用来追踪集合在遍历过程中的突变</span></span><br><span class="line">        <span class="comment">// 它不能为 NULL ，也不应该指向 self</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 因为我们的 Array 类是不可变的，所以我们不需要追踪它的突变</span></span><br><span class="line">        <span class="comment">// 因此，我们将它指向 state-&gt;extra 的其中一个值</span></span><br><span class="line">        <span class="comment">// 如果你的集合是可变的，可以将 state-&gt;mutationsPtr 指向一个内部变量</span></span><br><span class="line">        <span class="comment">// 而这个内部变量的值会在你的集合突变时发生变化</span></span><br><span class="line">state-&gt;mutationsPtr = &amp;state-&gt;extra[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_STACKBUF <span class="comment">// Method One.</span></span></span><br><span class="line"> <span class="comment">// 判断我们是否已经遍历完 _list</span></span><br><span class="line"><span class="keyword">if</span>(countOfItemsAlreadyEnumerated &lt; _list.size()) &#123;</span><br><span class="line"><span class="comment">// 将 state-&gt;itemsPtr 指向调用者提供的 C 数组 stackbuf</span></span><br><span class="line">state-&gt;itemsPtr = stackbuf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 _list 中的元素填充到 stackbuf 中，直到以下两个条件中的任意一个满足时为止</span></span><br><span class="line">        <span class="comment">// 1. 已经遍历完 _list 中的所有元素</span></span><br><span class="line">        <span class="comment">// 2. 已经填充满 stackbuf</span></span><br><span class="line"><span class="keyword">while</span>((countOfItemsAlreadyEnumerated &lt; _list.size()) &amp;&amp; (count &lt; stackbufLength)) &#123;</span><br><span class="line"><span class="comment">// 取出 _list 中的元素填充到 stackbuf 中</span></span><br><span class="line">stackbuf[count] = _list[countOfItemsAlreadyEnumerated];</span><br><span class="line"><span class="comment">// 更新遍历位置</span></span><br><span class="line">countOfItemsAlreadyEnumerated++;</span><br><span class="line"><span class="comment">// 更新返回的 C 数组的长度，使之与 state-&gt;itemsPtr 中的元素个数相匹配</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// Method Two.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否已经遍历完 _list</span></span><br><span class="line"><span class="keyword">if</span> (countOfItemsAlreadyEnumerated &lt; _list.size()) &#123;</span><br><span class="line"><span class="comment">// 直接将 state-&gt;itemsPtr 指向内部的 C 数组指针，因为它的内存地址是连续的</span></span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">const</span> <span class="type">id</span> * const_array = _list.data();</span><br><span class="line">state-&gt;itemsPtr = (__typeof__(state-&gt;itemsPtr))const_array;</span><br><span class="line"><span class="comment">// 一次性返回了 _list 中的所有元素</span></span><br><span class="line">       <span class="comment">// 所以，countOfItemsAlreadyEnumerated 和 count 的值均为 _list 中的元素个数</span></span><br><span class="line">count = _list.size();</span><br><span class="line">countOfItemsAlreadyEnumerated = _list.size();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="comment">// 将本次调用得到的 countOfItemsAlreadyEnumerated 保存到 state-&gt;state 中</span></span><br><span class="line">    <span class="comment">// 因为 NSFastEnumeration 协议本身并没有用到 state-&gt;state</span></span><br><span class="line">    <span class="comment">// 所以，可以将这个值保留到下一次调用</span></span><br><span class="line">state-&gt;state = countOfItemsAlreadyEnumerated;</span><br><span class="line"><span class="comment">// 返回C数组长度</span></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将注释翻译一下，剩下的代码是这样，<code>countByEnumeratingWithState:</code> 一共有两种实现方式，通过宏来控制. 我们可以看出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* countByEnumeratingWithState是被外部循环调用的</span><br><span class="line">* 使用结构体指针<span class="built_in">NSFastEnumerationState</span>记录当前最新的遍历状态，循环的次数取决于参数stackbufLength缓冲区的大小。</span><br><span class="line">* <span class="built_in">NSFastEnumerationState</span>中state用来记录最后遍历的位置，itemsPtr指向缓冲区数组,mutationsPtr和extra是用来检测和控制原始数组是否改变</span><br><span class="line">* 当最终返回<span class="string">&#x27;count = 0&#x27;</span>是表示遍历结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面的了解后，接下来，我们通过一个小例子来说明<code>for in</code>是如果工作的.<br>简单的写了一个数组遍历的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="built_in">NSArray</span> *array = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">id</span> obj <span class="keyword">in</span> array) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们通过<code>clang -rewrite-objc main.m</code>, 然编译器翻译下<code>for in</code>，我们会看到一个<code>.cpp</code>的文件，里面代码实在是太多了, 我们找到我们写的那个地方,</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> obj;</span><br><span class="line"> <span class="comment">// 初始化结构体 NSFastEnumerationState</span></span><br><span class="line"><span class="keyword">struct</span> __objcFastEnumerationState enumState = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 初始化数组 stackbuf，缓冲区数组初始化固定的大小为16</span></span><br><span class="line"><span class="type">id</span> __rw_items[<span class="number">16</span>];</span><br><span class="line"><span class="type">id</span> l_collection = (<span class="type">id</span>) array;</span><br><span class="line">_WIN_NSUInteger limit =</span><br><span class="line">((_WIN_NSUInteger (*) (<span class="type">id</span>, SEL, <span class="keyword">struct</span> __objcFastEnumerationState *, <span class="type">id</span> *, _WIN_NSUInteger))(<span class="type">void</span> *)objc_msgSend)</span><br><span class="line">((<span class="type">id</span>)l_collection,</span><br><span class="line">sel_registerName(<span class="string">&quot;countByEnumeratingWithState:objects:count:&quot;</span>),</span><br><span class="line">&amp;enumState, (<span class="type">id</span> *)__rw_items, (_WIN_NSUInteger)<span class="number">16</span>);</span><br><span class="line"><span class="keyword">if</span> (limit) &#123;</span><br><span class="line"><span class="comment">// 获取 mutationsPtr 的初始值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> startMutations = *enumState.mutationsPtr;</span><br><span class="line"><span class="comment">// 外层的 do/while 循环，用于调用 - countByEnumeratingWithState:objects:count: 方法，获取 C 数组</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 内层的 do/while 循环，用于遍历获取到的 C 数组</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 判断 mutationsPtr 的值是否有发生变化，如果有则使用 objc_enumerationMutation 函数抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (startMutations != *enumState.mutationsPtr)</span><br><span class="line">objc_enumerationMutation(l_collection);</span><br><span class="line">obj = (<span class="type">id</span>)enumState.itemsPtr[counter++]; &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_q1_yw_3n1px5bb6019pv_7gmtb00000gn_T_main_6938ec_mi_0,obj);</span><br><span class="line"> &#125;;</span><br><span class="line">__continue_label_1: ;</span><br><span class="line">&#125; <span class="keyword">while</span> (counter &lt; limit);</span><br><span class="line">&#125; <span class="keyword">while</span> ((limit = ((_WIN_NSUInteger (*) (<span class="type">id</span>, SEL, <span class="keyword">struct</span> __objcFastEnumerationState *, <span class="type">id</span> *, _WIN_NSUInteger))(<span class="type">void</span> *)objc_msgSend)</span><br><span class="line">((<span class="type">id</span>)l_collection,</span><br><span class="line">sel_registerName(<span class="string">&quot;countByEnumeratingWithState:objects:count:&quot;</span>),</span><br><span class="line">&amp;enumState, (<span class="type">id</span> *)__rw_items, (_WIN_NSUInteger)<span class="number">16</span>)));</span><br><span class="line">obj = ((<span class="type">id</span>)<span class="number">0</span>);</span><br><span class="line">__break_label_1: ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">obj = ((<span class="type">id</span>)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实<code>for in</code>快速遍历是通过两层 <code>do/while</code> 循环来实现的, 外层循环负责调用 <code>- countByEnumeratingWithState:objects:count:</code>方法，获取 <code>C</code> 数组，内层循环则负责遍历获取到的 <code>C</code> 数组, 通过<code>mutationsPtr</code>值的变化来判断集合在遍历过程中是否突变. </p><h4 id="通过对NSFastEnumeration的学习，了解了for-in快速遍历是如何实现的"><a href="#通过对NSFastEnumeration的学习，了解了for-in快速遍历是如何实现的" class="headerlink" title="通过对NSFastEnumeration的学习，了解了for in快速遍历是如何实现的."></a>通过对<code>NSFastEnumeration</code>的学习，了解了<code>for in</code>快速遍历是如何实现的.</h4>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;好久没写些什么东西了，似乎快有半年了吧。也不知道要写些什么，最近也跳槽了，复习了一段时间，所以应该重新开启新的行程了。&lt;br&gt;废话不多说，今天来研究下&lt;code&gt;NSFastEnumeration&lt;/code&gt;这个协议。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Protocol" scheme="http://aeronxie.github.io/tags/Protocol/"/>
    
    <category term="Objective" scheme="http://aeronxie.github.io/tags/Objective/"/>
    
  </entry>
  
  <entry>
    <title>深入理解KVC</title>
    <link href="http://aeronxie.github.io/post/d5a83d96.html"/>
    <id>http://aeronxie.github.io/post/d5a83d96.html</id>
    <published>2017-11-05T14:15:18.000Z</published>
    <updated>2023-03-25T14:39:55.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>KVC（Key-value Coding）键值编码, 一个非正式的<code>Protocol</code>, 提供一种机制来间接访问对象的属性, 通俗来说就是可以者通过Key直接访问对象的属性，或者给对象的属性赋值, 而不需要显示的调用存取方法. 苹果的又一大黑魔法~~</p></blockquote><span id="more"></span><p>用法想必大家都很熟了, 这次来探究其内部原理.</p><p><code>NSObject</code>的<code>Category</code>,<code>NSKeyValueCoding</code>中, 有这么些方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@property (class, readonly) BOOL accessInstanceVariablesDirectly;</span><br><span class="line"></span><br><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line"></span><br><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (void)setNilValueForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="void-setValue-nullable-id-value-forKey-NSString-key"><a href="#void-setValue-nullable-id-value-forKey-NSString-key" class="headerlink" title="- (void)setValue:(nullable id)value forKey:(NSString *)key;"></a><code>- (void)setValue:(nullable id)value forKey:(NSString *)key;</code></h4><p>先来看下<code>- setValue: forKey:</code>这个方法, 给定一个标识属性的值和键，设置属性的值, 也就是说只要拿到属性名就可以给它赋值了.</p><p>其内部查找机制是: </p><ul><li>在对象所属类中，查找<code>-set&lt;key&gt;</code>方法, 如果找到了, 则先检查其参数类型, 如果不是对象指针类型且值为<code>nil</code>的话,则<code> -setNilValueForKey:</code> 会被调用, 其内部会抛出<code>NSInvalidArgumentException</code>, 我们可以通过覆盖<code>-setNilValueForKey:</code>方法做一些操作.  否则, 如果<code>-set&lt;key&gt;</code>方法的参数类型是一个对象指针类型, 则该方法就会以值作为参数调用. 如果方法的参数类型是其他类型, 则是在调用方法之前由 <code>- valueForKey:</code> 执行的 <code>NSNumber/NSValue</code> 转换的逆函数.</li><li>没有找到<code>-set&lt;key&gt;</code>方法, 如果对象类实现了<code>+ accessInstanceVariablesDirectly</code>并返回了<code>YES</code>, 那么则会按<code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 顺序查找与之匹配的实例变量, 如果找到了这样的一个实例变量，并且它的类型是一个对象指针类型，那么在实例变量的旧值首次被释放之后，该值被保留并且结果赋值给实例变量,  如果实例变量的类型是某种其他类型, 则其值将在与<code>NSNumber\NSValue</code>相同的转换类型之后设置.</li><li>没有找到<code>-set&lt;key&gt;</code>方法, 也没有找到与之相匹配的实例变量, <code>-setValue:forUndefinedKey:</code>方法则会被调用, 其内部抛出一个<code>NSUndefinedKeyException</code>, 我们也可以覆盖它对异常做些其他的操作.</li></ul><p>接下来我们看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface Test : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) NSInteger result;</span><br><span class="line">@property (nonatomic,   copy) NSString *test;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Test</span><br><span class="line"></span><br><span class="line">@dynamic test;</span><br><span class="line"></span><br><span class="line">- (void)setNilValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;-setNilValueForKey:, key = %@&quot;,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;-setValue:forUndefinedKey:, value = %@, key = %@&quot;,value,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test *test = [Test new];</span><br><span class="line">[test setValue:@&quot;hello&quot; forKey:@&quot;test&quot;];</span><br><span class="line">[test setValue:nil forKey:@&quot;result&quot;];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-10-29 18:25:39.179854+0800 Test[52096:19683376] -setValue:forUndefinedKey:, value = hello, key = test</span><br><span class="line">2017-10-29 18:25:39.180030+0800 Test[52096:19683376] -setNilValueForKey:, key = result</span><br></pre></td></tr></table></figure><ol><li>先寻找<code>-set&lt;key&gt;</code>方法, 这里使用了<code>@dynamic test;</code>也就是说,它没有了set方法,就是找不到<code>-set&lt;key&gt;</code>方法, 内部会调用<code>- setValue:forUndefinedKey</code>这个方法;  然后给<code>result</code>赋值为<code>nil</code>,参数类型不是指针类型, 会发现其内部调用了<code>-setNilValueForKey:</code>, 这也就是验证了上面所说的第一点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Test : NSObject &#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString *_test;</span><br><span class="line">    NSString *_isTest;</span><br><span class="line">    NSString *test;</span><br><span class="line">    NSString *isTest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>如果我们为<code>Test</code>类增加几个成员变量, <code>+ accessInstanceVariablesDirectly</code>并返回了<code>YES</code>, <code>test</code>依然是没有<code>set</code>方法, 但是打印后却发现<code>test-&gt;_test</code>的值为<code>hello</code>, 如果把<code>NSString *_test</code>删掉, <code>test-&gt; _isTest</code>的变成了<code>hello</code>, 再把<code>NSString *_isTest</code>删掉, <code>test-&gt;test</code>的值变成了<code>hello</code>, 最后把<code>NSString *test</code>删掉, <code>test-&gt;isTest</code>的的值是<code>hello</code>, 这也就验证上面所说的第二点.  如果<code>+ accessInstanceVariablesDirectly</code>返回了<code>NO</code>,那么这些成员变量将不会被赋值</p></li><li><p>当按步骤一和步骤二都没有找到相匹配的方法或者实例变量时, 直接调用 <code>-setValue:forUndefinedKey:</code>, 打印出<br><code>2017-10-29 19:30:59.330638+0800 Test[52548:19738481] -setValue:forUndefinedKey:, value = hello, key = test</code></p></li></ol><h4 id="nullable-id-valueForKey-NSString-key"><a href="#nullable-id-valueForKey-NSString-key" class="headerlink" title="- (nullable id)valueForKey:(NSString *)key;"></a><code>- (nullable id)valueForKey:(NSString *)key;</code></h4><p><code>给定一个标识属性或一对一关系的键，返回属性值或相关对象. 给出一个标识一对多关系的键，返回一个不可变数组或一个包含所有相关对象的不可变集</code></p><p>其内部查找机制:</p><ul><li>按照<code>-get&lt;Key&gt;</code>， <code>-&lt;key&gt;</code>, <code>-is&lt;Key&gt;</code>的顺序在对象类中查找这些方法, 如果找到这样的方法, 如果方法的结果类型是一个对象指针类型，则只返回结果, 如果结果的类型是<code>NSNumber</code>转换支持的一个类型，并返回一个NSNumber, 否则，转换完成并返回<code>NSValue</code></li><li>找不到简单的访问方法，则会按<code>-countOf&lt;Key&gt;</code>,<code>-indexIn&lt;Key&gt; OfObject：</code>, <code>- objectIn &lt;Key&gt; AtIndex：</code>以及 <code>- &lt;key&gt; AtIndexes :</code>(对应于 <code>-NSOrderedSet objectsAtIndexes</code>)的顺序查找. 如果找到计数方法和<code>indexOf</code>方法以及其他两种可能的方法中的至少一种方法，则返回响应所有<code>NSOrderedSet</code>方法的集合代理对象. 发送到集合代理对象的每个<code>NSOrderedSet</code>消息将导致<code>-countOf &lt;Key&gt;</code>，<code>-indexIn &lt;Key&gt; OfObject :</code>, <code>-objectIn &lt;Key&gt; AtIndex :</code>,和 <code>- &lt;key&gt; AtIndexes:</code> 被发送到 <code>-valueForKey</code>的原始接收者. 如果接收者的类也实现了一个可选方法，其名称与模式<code>-get &lt;Key&gt;：range</code>的匹配：该方法将在适当的情况下被使用以获得最佳性能.</li><li>如果找不到一个简单的访问方法或一组有序的访问方法, 在接收方的类中搜索其名称与模式匹配的方法 <code>-countOf&lt;Key&gt;</code> 和 <code>-objectIn&lt;Key&gt;AtIndex:</code> (对应于NSArray类定义的原始方法<code> -&lt;key&gt;AtIndexes:</code> (对应于 —[NSArray objectsAtIndexes:]). 如果找到一个count方法和其他两种可能的方法中的一个, 那么将返回一个响应所有NSArray方法的集合代理对象.发送到集合代理对象的每个NSArray消息都会导致一些消息 <code>-countOf&lt;Key&gt;</code>, <code>-objectIn&lt;Key&gt;AtIndex:</code>, 和 <code>-&lt;key&gt;AtIndexes:</code> 被发送到 <code>-valueForKey:</code>的原始接收者. 如果接收方的类也实现了一个可选的方法, 与它的名称匹配的 <code>-get&lt;Key&gt;:range:</code> 方法将在适合最佳性能时使用</li><li>如果找不到一个简单的存取器方法或一组有序集或数组访问方法,搜索接收者类的三个方法, 这些方法的名称按 <code>-countOf&lt;Key&gt;</code>, <code>-enumeratorOf&lt;Key&gt;</code>, <code>-memberOf&lt;Key&gt;:</code> 匹配(对应于NSSet类定义的原始方法). 如果找到所有三个这样的方法, 那么将返回一个响应所有NSSet方法的集合代理对象. 发送到集合代理对象的每个NSSet消息都会导致一些消息 <code>-countOf&lt;Key&gt;</code>, <code>-enumeratorOf&lt;Key&gt;</code>, 和 <code>-memberOf&lt;Key&gt;:</code> 被发送到 <code>-valueForKey:</code> 的原始接收者.</li><li>如果找不到简单的访问方法或集合访问方法集, 如果接收者的类 <code>+ accessInstanceVariablesDirectly</code> 属性返回<code>YES</code>,搜索对象的类的一个实例变量名称这个顺序与 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 匹配. 如果找到了这样一个实例变量, 那么返回的实例变量的值将返回, 与第1步中的NSNumber或NSValue的转换相同.</li><li>如果找不到简单的访问方法、集合访问方法集或实例变量, 则调用 <code>-valueForUndefinedKey:</code> 并返回. 其内部会抛出<code>NSUndefinedKeyException</code>, 我们也可以覆盖这个方法来做一些操作</li></ul><p>我们继续来看下例子,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test *test = [Test new];</span><br><span class="line">[test valueForKey:@&quot;test&quot;];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@implementation Test </span><br><span class="line"></span><br><span class="line">@dynamic test;</span><br><span class="line"></span><br><span class="line">- (id)test &#123;</span><br><span class="line">    NSLog(@&quot;-test&quot;);</span><br><span class="line">    return @&quot;hello&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)isTest &#123;</span><br><span class="line">    NSLog(@&quot;-isTest&quot;);</span><br><span class="line">    return @&quot;hello&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)valueForUndefinedKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;-valueForUndefinedKey:, key = %@&quot;,key);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>先找是否有<code>-get&lt;Key&gt;</code>方法, 我们发现打印出了<code>-getTest</code>, 我们接着把<code>- (id)getTest </code>方法删掉, 发现会打印出<code>-test</code>,如果在把<code>- (id)test</code>删掉, 则会打印出<code>-isTest</code>, 最后在把<code>-(id)isTest</code>删了, 我们发现打印了<code> -valueForUndefinedKey:, key = test</code>, 这也就验证了第一点所说</li></ul><p>我们也增加了这几个成员变量, </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Test : NSObject &#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString *_test;</span><br><span class="line">    NSString *_isTest;</span><br><span class="line">    NSString *test;</span><br><span class="line">    NSString *isTest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test *test = [Test new];</span><br><span class="line">[test setValue:@&quot;hello&quot; forKey:@&quot;test&quot;];</span><br></pre></td></tr></table></figure><ul><li><p>我们会发现<code>test-&gt;_test</code>的值会是<code>hello</code>，删掉<code>NSString *_test</code>之后发现<code>test-&gt;_isTest</code>的值是<code>_isTest</code>, 删除<code>NSString *_isTest</code>后，<code>test-&gt;test</code>的值是<code>hello</code>，最后删除<code>NSString *test</code>, <code>test-&gt;isTest</code>的值是<code>hello</code>，查找顺序是按 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code></p></li><li><p>最后我们将变量也去掉，最后就会打印出<code>-valueForUndefinedKey:, key = test</code>, 也就是找不到值了.</p></li></ul><h4 id="BOOL-validateValue-id-ioValue-forKey-NSString-inKey-error-NSError-outError"><a href="#BOOL-validateValue-id-ioValue-forKey-NSString-inKey-error-NSError-outError" class="headerlink" title="- (BOOL)validateValue:(id)ioValue forKey:(NSString *)inKey error:(NSError)outError;"></a><code>- (BOOL)validateValue:(id)ioValue forKey:(NSString *)inKey error:(NSError)outError;</code></h4><p>这是KVC提供属性值确认的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation Test </span><br><span class="line"></span><br><span class="line">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError &#123;</span><br><span class="line">    </span><br><span class="line">    if ([*ioValue isKindOfClass:[NSString class]] &amp;&amp; [*ioValue isEqualToString:@&quot;hello&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;匹配成功&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Test *test = [Test new];</span><br><span class="line"></span><br><span class="line">id value = @&quot;hello&quot;;</span><br><span class="line">NSString *key = @&quot;test&quot;;</span><br><span class="line">NSError *error;</span><br><span class="line">    </span><br><span class="line">BOOL result = [test validateValue:&amp;value forKey:key error:&amp;error];</span><br><span class="line">if (result) &#123;</span><br><span class="line">    NSLog(@&quot;键值匹配&quot;);</span><br><span class="line">    [test setValue:value forKey:key];</span><br><span class="line">&#125; else&#123;</span><br><span class="line">    NSLog(@&quot;键值不匹配&quot;); </span><br><span class="line">&#125;</span><br><span class="line">NSString *word = [test valueForKey:@&quot;test&quot;];</span><br><span class="line">NSLog(@&quot;word:%@&quot;,word);</span><br></pre></td></tr></table></figure><p>最后则打印出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-10-29 20:53:11.663274+0800 Test[53775:19851095] 匹配成功</span><br><span class="line">2017-10-29 20:53:11.663446+0800 Test[53775:19851095] 键值匹配</span><br><span class="line">2017-10-29 20:53:11.663605+0800 Test[53775:19851095] word:hello</span><br></pre></td></tr></table></figure><p>这样就给了我们一次纠错的机会, 需要指出的是，KVC是不会自动调用键值验证方法的，就是说我们如果想要键值验证则需要手动验证. 此方法的默认实现将在接收者的类中搜索名称与模式<code>-validate &lt;Key&gt;：error：</code>匹配的验证器方法, 如果找到这样的方法，则调用该方法并返回结果, 如果没有找到这样的方法，则返回YES.</p><h4 id="通过-nullable-id-valueForKey-NSString-key与-void-setValue-nullable-id-value-forKey-NSString-key-我们大概了解了KVC内部的实现原理-也了解了KVC给我们提供了一些纠错的方法-接下来我们也可以自己手动实现下KVC"><a href="#通过-nullable-id-valueForKey-NSString-key与-void-setValue-nullable-id-value-forKey-NSString-key-我们大概了解了KVC内部的实现原理-也了解了KVC给我们提供了一些纠错的方法-接下来我们也可以自己手动实现下KVC" class="headerlink" title="通过- (nullable id)valueForKey:(NSString *)key与- (void)setValue:(nullable id)value forKey:(NSString *)key, 我们大概了解了KVC内部的实现原理, 也了解了KVC给我们提供了一些纠错的方法,接下来我们也可以自己手动实现下KVC"></a>通过<code>- (nullable id)valueForKey:(NSString *)key</code>与<code>- (void)setValue:(nullable id)value forKey:(NSString *)key</code>, 我们大概了解了<code>KVC</code>内部的实现原理, 也了解了KVC给我们提供了一些纠错的方法,接下来我们也可以自己手动实现下KVC</h4><h3 id="KVC-的简单实现"><a href="#KVC-的简单实现" class="headerlink" title="KVC 的简单实现"></a>KVC 的简单实现</h3><h5 id="我们先来看下-void-setValue-id-value-forKey-NSString-key的实现："><a href="#我们先来看下-void-setValue-id-value-forKey-NSString-key的实现：" class="headerlink" title="我们先来看下- (void)setValue:(id)value forKey:(NSString *)key的实现："></a>我们先来看下<code>- (void)setValue:(id)value forKey:(NSString *)key</code>的实现：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class selfClass = [self class];</span><br><span class="line">SEL sel = NSSelectorFromString([self assemblySetterMethod:key]);</span><br><span class="line">Method setterMethod = class_getInstanceMethod(selfClass, sel);</span><br><span class="line">// 先在对象类查找是否有setter方法</span><br><span class="line">if (setterMethod) &#123;</span><br><span class="line">    char *argumentType = method_copyArgumentType(setterMethod, 2); // 第一个参数 self ，第二个参数 _cmd</span><br><span class="line">    NSString *type = [NSString stringWithCString:argumentType encoding:NSUTF8StringEncoding];</span><br><span class="line">    if (![type isEqualToString:@&quot;@&quot;]) &#123;  // @An object (whether statically typed or typed id) 表示一个对象</span><br><span class="line">        if (value == nil) &#123;</span><br><span class="line">            [self xf_setNilValueForKey:key];</span><br><span class="line">            return;</span><br><span class="line">        &#125; // 非指针类型方法调用</span><br><span class="line">        [self setterMsgsendWithArgumentType:argumentType sel:sel argument:value];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">((void (*)(id,SEL,id))objc_msgSend)(self,sel,value);</span><br></pre></td></tr></table></figure><ul><li> 先从当前类寻找是否有<code>getter</code>方法, 然后并获取到该方法, 通过<code>method_copyArgumentType</code>获取到方法的参数类型，如果不是指针类型并且<code>value</code>为<code>nil</code>, 则内部会直接调用<code>setNilValueForKey</code>方法，并抛出异常. 如果是非指针类型<code>value</code>不为空，则会通过参数类型调用其<code>setter</code>方法. 类型我们可以参照<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">苹果官方的文档</a>. 由于涉及到参数类型的改变, 我是直接通过<code>msgsend</code>方法来进行的, <code>((void (*)(id,SEL,char))objc_msgSend)(self,sel,[value charValue]);</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 无setter方法则查找成员变量, _&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;</span><br><span class="line">    // 首先判断是否需要寻找成员变量</span><br><span class="line">    if (![self.class xf_accessInstanceVariablesDirectly]) &#123;</span><br><span class="line">        [self xf_setValue:value forUndefinedKey:key];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Ivar *ivars = class_copyIvarList(selfClass, &amp;count);</span><br><span class="line">    // _&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;数组</span><br><span class="line">    NSArray&lt;NSString *&gt; *varibleKeys = [self convertKeyToInstanceVariable:key];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        const char *name = ivar_getName(ivar);</span><br><span class="line">        NSString *ivarName = [NSString stringWithCString:name encoding:NSUTF8StringEncoding];</span><br><span class="line">        </span><br><span class="line">        for (int j = 0; j &lt; varibleKeys.count; j++) &#123;</span><br><span class="line">            if ([ivarName isEqualToString:varibleKeys[j]]) &#123;</span><br><span class="line">                const char *type = ivar_getTypeEncoding(ivar);</span><br><span class="line">                if (*type != &#x27;@&#x27;) &#123; // 如果非指针类型而且值还为nil</span><br><span class="line">                    if (value == nil) &#123;</span><br><span class="line">                        free(ivars); ivars = NULL;</span><br><span class="line">                        [self xf_setNilValueForKey:key];</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                [self setValue:value forIvar:ivar]; // 给变量赋值</span><br><span class="line">                free(ivars); ivars = NULL; return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars); ivars = NULL;</span><br><span class="line">    [self xf_setValue:value forUndefinedKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p> 如果我们没能从类中找到<code>setter</code>方法, 则会按照<code>_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;</code>顺序进行变量查找,在此之前我们需要先进行判断<code>accessInstanceVariablesDirectly</code>, 是否允许查找变量, 默认则为<code>YES</code>.<br>我们可以通过<code>class_copyIvarList</code>方法拿到类中所有实例变量, 通过<code>ivar_getName</code>拿到变量名, 通过<code>ivar_getTypeEncoding</code>拿到变量的类型,然后对<code>key</code>进行逐一比对. 如果是非指针类型而且值还为<code>nil</code>,则会调用<code>setNilValueForKey</code>,否则会通过<code>object_setIvar</code>方法给变量进行赋值, 这里仍然需要对类型进行转换. </p></li><li><p> 如果<code>setter</code>方法跟变量都找不到的话则会调用<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>方法并抛出异常.</p></li></ul><h5 id="id-valueForKey-NSString-key-的实现"><a href="#id-valueForKey-NSString-key-的实现" class="headerlink" title="- (id)valueForKey:(NSString *)key  的实现"></a><code>- (id)valueForKey:(NSString *)key</code>  的实现</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 查找是否有这些方法  -get&lt;Key&gt;, -&lt;key&gt;, -is&lt;Key&gt;</span><br><span class="line">Class selfClass = [self class];</span><br><span class="line">unsigned int methodCount = 0;</span><br><span class="line">Method *methods = class_copyMethodList(selfClass, &amp;methodCount);</span><br><span class="line">if (methodCount &gt; 0) &#123;</span><br><span class="line">    NSArray *searchFunctions = [self convertGetterInstanceMethod:key];</span><br><span class="line">    for (int i = 0; i &lt; methodCount; i++) &#123;</span><br><span class="line">        SEL sel = method_getName(methods[i]);</span><br><span class="line">        NSString *methodName = NSStringFromSelector(sel);</span><br><span class="line">        for (int j = 0; j &lt; searchFunctions.count; j++) &#123;</span><br><span class="line">            if ([methodName isEqualToString:searchFunctions[j]]) &#123;</span><br><span class="line">                char *returnType = method_copyReturnType(methods[i]);</span><br><span class="line">                NSString *type = [NSString stringWithUTF8String:returnType];</span><br><span class="line">                if (![type  isEqual:@&quot;@&quot;]) &#123;  // 非指针类型</span><br><span class="line">                    NSNumber *result = [self getReturnValueForMethod:methods[i]];</span><br><span class="line">                    return result;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    id resultValue = ((id (*)(id,SEL))objc_msgSend)(self,sel);</span><br><span class="line">                    return resultValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 首先我们可以通过<code>class_copyMethodList</code>方法可以拿到类中所有的实例方法, 通过<code>method_getName</code>获取方法名, 通过<code>method_copyReturnType</code>获得方法的返回类型, 最后按<code>-get&lt;Key&gt;, -&lt;key&gt;, -is&lt;Key&gt;</code>顺序查找是否有这些方法，如果有且返回类型为非指针类型，则需要通过类型转换之后获取到返回值,如果是指针类型，则直接通过<code>id resultValue = ((id (*)(id,SEL))objc_msgSend)(self,sel);</code>拿到返回值.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 判断accessInstanceVariablesDirectly值,然后做是否搜寻实例变量操作</span><br><span class="line">if (![self.class xf_accessInstanceVariablesDirectly]) &#123;</span><br><span class="line">    [self xf_valueForUndefinedKey:key];</span><br><span class="line">&#125;</span><br><span class="line">unsigned int ivarCount = 0;</span><br><span class="line">//返回类中所有实例变量</span><br><span class="line">Ivar *ivars = class_copyIvarList(self.class, &amp;ivarCount);</span><br><span class="line">// 寻找变量 _&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;</span><br><span class="line">NSArray&lt;NSString *&gt; *keyNameArray = [self convertKeyToInstanceVariable:key];</span><br><span class="line">    </span><br><span class="line">for (unsigned int i = 0; i &lt; ivarCount; i++) &#123;</span><br><span class="line">    const char *ivarCName = ivar_getName(ivars[i]);</span><br><span class="line">    NSString *ivarName = [NSString stringWithCString:ivarCName encoding:NSUTF8StringEncoding];</span><br><span class="line">    for (NSUInteger j = 0; j &lt; keyNameArray.count; j++) &#123;</span><br><span class="line">        if ([ivarName isEqualToString:keyNameArray[j]]) &#123;</span><br><span class="line">            // 找到符合要求的ivar，根据对象类型进行相应操作</span><br><span class="line">            const char *ivarType = ivar_getTypeEncoding(ivars[i]);</span><br><span class="line">            if (*ivarType != &#x27;@&#x27;) &#123; // 非指针对象</span><br><span class="line">                return [self getValueForIvar:ivars[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            //指针对象</span><br><span class="line">            id ivarValue = object_getIvar(self, ivars[i]);</span><br><span class="line">            free(ivars); ivars = NULL;</span><br><span class="line">            return ivarValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 也是需要先判断<code>accessInstanceVariablesDirectly</code>允许是否查找变量, 如果是则按<code>_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;</code>顺序进行变量的查找, 步骤与<code>-setValue:forkey:</code>一致，这里就不再重复. 类型转换之后最后通过<code>object_getIvar</code>方法获取到变量的值.</li><li>如果如果<code>-get&lt;Key&gt;, -&lt;key&gt;, -is&lt;Key&gt;</code>方法跟<code>_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;</code>变量都找不到的话则会调用<code>- (id)valueForUndefinedKey:(NSString *)key</code>方法并抛出异常.</li></ul><h4 id="这里简单的实现了两个常用的方法，这里重点主要是类型的转换，通过这次学习，对KVC的原理有了进一步理解。"><a href="#这里简单的实现了两个常用的方法，这里重点主要是类型的转换，通过这次学习，对KVC的原理有了进一步理解。" class="headerlink" title="这里简单的实现了两个常用的方法，这里重点主要是类型的转换，通过这次学习，对KVC的原理有了进一步理解。"></a>这里简单的实现了两个常用的方法，这里重点主要是类型的转换，通过这次学习，对KVC的原理有了进一步理解。</h4><p>###PS：自己实现的KVC源码放在github上, 戳<a href="https://github.com/aeronxie/XFKVC">地址</a>~~</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;KVC（Key-value Coding）键值编码, 一个非正式的&lt;code&gt;Protocol&lt;/code&gt;, 提供一种机制来间接访问对象的属性, 通俗来说就是可以者通过Key直接访问对象的属性，或者给对象的属性赋值, 而不需要显示的调用存取方法. 苹果的又一大黑魔法~~&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Objective-C" scheme="http://aeronxie.github.io/tags/Objective-C/"/>
    
    <category term="KVC" scheme="http://aeronxie.github.io/tags/KVC/"/>
    
  </entry>
  
  <entry>
    <title>初探NSURLProtocol</title>
    <link href="http://aeronxie.github.io/post/fd52cee9.html"/>
    <id>http://aeronxie.github.io/post/fd52cee9.html</id>
    <published>2017-10-16T03:39:27.000Z</published>
    <updated>2023-03-25T14:39:54.178Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> NSURLProtocol 是 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html">URL Loading System</a> 中的一部分, 但是它十分的强大和牛逼, 可以说是苹果又一大黑魔法了, 它能够拦截所有的 <code>URL Loading System</code>发出的网络请求, 拦截之后就可以做各种自定义处理. 下面就来看下这个神奇的东西。。。</p></blockquote><span id="more"></span><h2 id="什么是NSURLProtocol"><a href="#什么是NSURLProtocol" class="headerlink" title="什么是NSURLProtocol"></a>什么是NSURLProtocol</h2><p><code>NSURLProtocol</code>是<code>URL Loading System</code>的一个重要组成部分, 看下官方给的结构图:</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/nsobject_hierarchy_2x.png"></p><p>URL加载系统包括<code>URL加载</code>、<code>认证&amp;证书</code>、<code>配置管理</code>、<code>缓存管理</code>、<code>Cookie存储</code>和<code>协议支持</code>这几个部分. <code>NSURLProtocol</code>看起来像是一个协议, 但是其并不是一个<code>Protocol</code>, 而是一个<code>Class</code>, 而且是一个<code>Abstract Class</code>. 来看下官方对它的解释:</p><blockquote><p>An NSURLProtocol object handles the loading of protocol-specific URL data. The NSURLProtocol class itself is an abstract class that provides the infrastructure for processing URLs with a specific URL scheme. You create subclasses for any custom protocols or URL schemes that your app supports.</p></blockquote><p>每一个<code>HTTP</code>请求开始时，<code>URL Loading System</code>就会创建一个合适的 <code>NSURLProtocol</code>对象处理对应的<code>URL</code>请求，我们不需要直接实例化一个<code>NSURLProtocol</code>子类, 而我们需要做的就是写一个继承自<code>NSURLProtocol</code>的类，并实现合适的抽象方法, 通过<code>-registerClass:</code>方法注册我们的协议类，然后<code>URL Loading System</code>就会在请求发出时使用我们创建的协议对象对该请求进行处理, 也就是说, 最后我们只需要写好继承自<code>NSURLProtocol</code>的子类即可.</p><h2 id="NSURLProtocol的使用"><a href="#NSURLProtocol的使用" class="headerlink" title="NSURLProtocol的使用"></a>NSURLProtocol的使用</h2><blockquote><p><code>NSURLProtocol</code>是如何实例化的？</p></blockquote><blockquote><p>那么<code>NSURLProtocol</code>是如何拦截<code>HTTP</code>请求的 ？</p></blockquote><blockquote><p>如何决定哪些请求需要处理哪些请求不需要处理？</p></blockquote><blockquote><p>对需要处理的请求做哪些操作？</p></blockquote><blockquote><p>如何发出<code>HTTP</code>请求后并且将<code>response</code>传递给调用者？</p></blockquote><p>首先来看下, <code>NSURLProtocol</code>都提供有哪些API.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request cachedResponse:(<span class="keyword">nullable</span> <span class="built_in">NSCachedURLResponse</span> *)cachedResponse client:(<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client;</span><br><span class="line">+ (<span class="type">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">+ (<span class="type">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)startLoading;</span><br><span class="line">- (<span class="type">void</span>)stopLoading;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="type">id</span>)propertyForKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">+ (<span class="type">void</span>)setProperty:(<span class="type">id</span>)value forKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSMutableURLRequest</span> *)request;</span><br><span class="line">+ (<span class="type">void</span>)removePropertyForKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSMutableURLRequest</span> *)request;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)registerClass:(Class)protocolClass;</span><br><span class="line">+ (<span class="type">void</span>)unregisterClass:(Class)protocolClass; </span><br></pre></td></tr></table></figure><p>之前说到过 <code>NSURLProtocol</code> 是一个抽象类，所以不能够直接使用必须被子类化之后才能使用.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomURLProtocol</span> : <span class="title">NSURLProtocol</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后需要注册它</p><p><code>[NSURLProtocol registerClass:[CustomURLProtocol class]]</code></p><h4 id="注册完成之后我们需要在子类中实现一些方法"><a href="#注册完成之后我们需要在子类中实现一些方法" class="headerlink" title="注册完成之后我们需要在子类中实现一些方法"></a>注册完成之后我们需要在子类中实现一些方法</h4><ul><li><code>+ (BOOL)canInitWithRequest:(NSURLRequest *)request</code></li></ul><p>每一次请求都会有一个<code>NSURLRequest</code>实例，通过拿到请求对象，我们就可以根据对应的请求选择是否处理该对象. 这个方法主要是说明你是否打算处理对应的<code>request</code>，如果不处理，返回<code>NO</code>，<code>URL Loading System</code>会使用系统默认的行为去处理；如果打算处理，则返回<code>YES</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey: URLProtocolKey inRequest:request]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *scheme = [[request URL] scheme];</span><br><span class="line">    <span class="keyword">if</span> ([scheme caseInsensitiveCompare:<span class="string">@&quot;http&quot;</span>] == <span class="built_in">NSOrderedSame</span> || [scheme caseInsensitiveCompare:<span class="string">@&quot;https&quot;</span>] == <span class="built_in">NSOrderedSame</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表示我们只处理<code>http</code>和<code>https</code>请求, 发现有一个<code>[NSURLProtocol propertyForKey:protocolKey inRequest:request]</code>判断, 这个方法表示这个请求是否已经被请求过了, 为了防止死循环, 这个接下来会说到</p><ul><li><code>+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request</code></li></ul><p>在这个方法中，我们可以对<code>request</code>对象进行处理, 如修改头部信息、URL重定向、修改host等,最后返回一个处理后的<code>request实例</code>, 如果不处理我们也可以直接返回<code>request</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b</code></li></ul><p>用于判断两个<code>request</code>是否相同，如果相同的话可以使用缓存数据，通常只需要调用父类的实现即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> requestIsCacheEquivalent:a toRequest:b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(nullable NSCachedURLResponse *)cachedResponse client:(nullable id &lt;NSURLProtocolClient&gt;)client</code></li></ul><p>该方法会创建一个<code>NSURLProtocol</code>实例，每一个网络请求都会创建一个新的实例, 在这里直接调用父类的方法，实例化一个对象并返回</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request cachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse client:(<span class="type">id</span> &lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="variable language_">super</span> initWithRequest:request cachedResponse:cachedResponse client:client];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// we do somthing log here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>- (void)startLoading</code></li></ul><p>拦截到网络请求，并且对网络请求进行定制处理以后, 我们需要将网络请求重新发送出去, 该方法就是转发的核心方法, 在该方法中, 我们把处理过的<code>request</code>重新发送出去, 可以是基于<code>NSURLConnection</code>、<code>NSURLSession</code>甚至<code>CFNetwork</code>.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)startLoading &#123;</span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [<span class="keyword">self</span>.request mutableCopy];</span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES forKey:URLProtocolKey inRequest:mutableReqeust];</span><br><span class="line">    <span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:mutableReqeust delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们又看到了<code>[NSURLProtocol setProperty:@YES forKey:URLProtocolKey inRequest:mutableReqeust]</code>,将这个<code>Property</code>设为了<code>YES</code>, 在<code>canInitWithRequest</code>需要判断, 为什么我们需要做这些个操作？ </p><p>因为<code>URL Loading System</code>在询问是否处理该请求的时候, 没加判断并返回了<code>YES</code>, 然后<code>URL Loading System</code>会创建一个<code>CustomURLProtocol</code>实例然后调用<code>startLoading</code>去获取数据, 重新发起一个请求, 然后又会走到<code>canInitWithRequest</code>,而在这个方法中又返回了<code>YES</code>,之后<code>URL Loading System</code>又会创建一个<code>CustomURLProtocol</code>实例, 然后就会出现无限循环下去. 所以我们应该保证每个<code>request</code>只被处理一次，所以需要通过<code>setProperty:forKey:inRequest:</code>标记那些已经处理过的<code>request</code>，然后在<code>canInitWithRequest:</code>中判断该<code>request</code>是否已经处理过了, 如果是则返回<code>NO</code></p><h4 id="如果我们拦截图片加载请求，本地有缓存的话就直接从本地加载没有再去请求-我们可以这么做"><a href="#如果我们拦截图片加载请求，本地有缓存的话就直接从本地加载没有再去请求-我们可以这么做" class="headerlink" title="如果我们拦截图片加载请求，本地有缓存的话就直接从本地加载没有再去请求, 我们可以这么做:"></a>如果我们拦截图片加载请求，本地有缓存的话就直接从本地加载没有再去请求, 我们可以这么做:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)startLoading &#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [[<span class="keyword">self</span> request] mutableCopy];</span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES forKey: URLProtocolKey inRequest:mutableReqeust];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *imageKey = <span class="keyword">self</span>.request.URL.absoluteString;</span><br><span class="line">    <span class="built_in">NSString</span> *localPath = [[SNImageCache sharedImageCache] cachedPathForKey:imageKey];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:localPath];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">NSURLResponse</span> *response = [[<span class="built_in">NSURLResponse</span> alloc] initWithURL:mutableReqeust.URL</span><br><span class="line">                                                            MIMEType:[<span class="built_in">NSData</span> sd_contentTypeForImageData:data]</span><br><span class="line">                                               expectedContentLength:data.length</span><br><span class="line">                                                    textEncodingName:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span></span><br><span class="line">              didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line">        [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">        [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:mutableReqeust delegate:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>- (void)stopLoading</code></li></ul><p>在请求完全结束之后取消对应的<code>request</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)stopLoading &#123;</span><br><span class="line">    [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSURLProtocolClient"><a href="#NSURLProtocolClient" class="headerlink" title="NSURLProtocolClient"></a>NSURLProtocolClient</h3><p>当我们把<code>request</code>发送出去之后, 当收到网络请求的响应，我们怎么把返回值返回给原来发送网络请求的地方呢？</p><p>这时我们需要用到<code>client</code>这个对象, 每一个<code>client</code>都实现了<code>NSURLProtocolClient</code>协议, 我们把<code>response</code>告诉<code>client</code>，也就是<code>URL Loading System</code>，让他来继续处理这个<code>response</code>，因为一切都是基于<code>URL Loading System</code>发生的，所以把<code>response</code>交给他，他会自动处理这个<code>response</code>并返回给发送<code>request</code>的地方</p><p>那么这个协议都有一些什么方法呢？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol wasRedirectedToRequest:(<span class="built_in">NSURLRequest</span> *)request redirectResponse:(<span class="built_in">NSURLResponse</span> *)redirectResponse;</span><br><span class="line">- (<span class="type">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol cachedResponseIsValid:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse;</span><br><span class="line">- (<span class="type">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response cacheStoragePolicy:(<span class="built_in">NSURLCacheStoragePolicy</span>)policy;</span><br><span class="line">- (<span class="type">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didLoadData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line">- (<span class="type">void</span>)URLProtocolDidFinishLoading:(<span class="built_in">NSURLProtocol</span> *)protocol;</span><br><span class="line">- (<span class="type">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didFailWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line">- (<span class="type">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge;</span><br><span class="line">- (<span class="type">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didCancelAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个<code>NSURLProtocol</code>的子类都有一个<code>client</code>对象来处理请求得到的<code>response</code>, 我们通常这样做, 就能将收到的消息通过<code>client</code>返回给<code>URL Loading System</code>:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是通过<code>NSURLConnection</code>请求的，所以需要通过其代理方法获取到数据, 在代理方法中将数据交给<code>client</code>，让其内部处理即可.</p><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>在使用<code>NSURLProtocol</code>的时候, 有几个坑是需要我们注意的:</p><ul><li><p><code>NSURLProtocol</code>可以拦截的网络请求包括<code>NSURLSession</code>，<code>NSURLConnection</code>以及<code>UIWebVIew</code>,基于<code>CFNetwork</code>的网络请求，以及<code>WKWebView</code>的请求是无法拦截的,详细可以查看<a href="http://www.openradar.me/search?query=nsurlprotocol">这个网站</a>.<br><code>AFNetworking</code>，<code>Alamofire</code>等这些第三方网络库都是基于<code>NSURLSession</code>或<code>NSURLConnection</code>的，所以这些网络库的网络请求都可以被<code>NSURLProtocol</code>拦截.<code>ASIHTTPRequest</code>等网路库都是基于<code>CFNetwork</code>的，所以这些网络库的网络请求都无法被<code>NSURLProtocol</code>拦截</p></li><li><p>如果需要<code>NSURLProtocol</code>来截获<code>NSURLSession</code>发出的请求，需要每一个<code>NSURLSession</code>在创建时配置的<code>NSURLSessionConfiguration</code>类的<code>protocolClasses</code>属性设置为自定义的<code>NSURLProtocol</code></p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultSessionConfiguration &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    configuration.protocolClasses = @[[CustomURLProtocol <span class="keyword">class</span>]];   </span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果文档也说了<code>You cannot use custom NSURLProtocol subclasses in conjunction with background sessions.</code>对于后台<code>Sessions</code>，是不支持自定义的<code>NSURLProtocol</code>的</p><ul><li><p>记得在<code>canInitWithRequest </code>方法里判断<code>if ([NSURLProtocol propertyForKey:protocolKey inRequest:request]) &#123;   return NO; &#125;</code>, 在<code>startLoading</code>方法里设置<code>[NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];</code><br>防止无限循环</p></li><li><p>若一个项目中存在多个<code>NSURLProtocol</code>，那么<code>NSURLProtocol</code>的拦截顺序跟注册顺序有关,多个<code>NSURLProtocol</code>拦截顺序为注册顺序的倒序，也就是后注册的<code>NSURLProtocol</code>会先被拦截. 对于通过配置<code>NSURLSessionConfiguration</code>对象的<code>protocolClasses</code>属性来注册的,<br><code>protocolClasses</code>这个数组里只有第一个<code>NSURLProtocol</code>会起作用,其他的都无效, 我们看下<code>OHHTTPStubs</code>库在注册时是如何处理的:</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> * urlProtocolClasses = [<span class="built_in">NSMutableArray</span> arrayWithArray:sessionConfig.protocolClasses];</span><br><span class="line">Class protoCls = OHHTTPStubsProtocol.class;</span><br><span class="line"><span class="keyword">if</span> (![urlProtocolClasses containsObject:protoCls]) &#123;</span><br><span class="line">    [urlProtocolClasses insertObject:protoCls atIndex:<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [urlProtocolClasses removeObject:protoCls];</span><br><span class="line">&#125;</span><br><span class="line">sessionConfig.protocolClasses = urlProtocolClasses;</span><br></pre></td></tr></table></figure><p>把自己的<code>NSURLProtocol</code>插入到<code>protocolClasses</code>的第一个，进行拦截, 拦截完成之后，又对其进行移除, 保证需要拦截的时候, 自己是在数组的第一个.</p><p>到这里, 对<code>HTTP</code>请求进行拦截就结束了, 我们通过<code>NSURLProtocol</code>对<code>request</code>做了各种神奇的事情, 但是它的强大还不止这些. </p><h2 id="NSURLProtocol实现"><a href="#NSURLProtocol实现" class="headerlink" title="NSURLProtocol实现"></a>NSURLProtocol实现</h2><p>了解了<code>NSURLProtocol</code>的使用之后, 我们再来看下它的内部实现. 这次依然用的是GNU源码.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableArray</span>*registered = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSLock</span>*regLock = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> ClassabstractClass = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> ClassplaceholderClass = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSURLProtocol</span>*placeholder = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">  <span class="keyword">if</span> (registered == <span class="literal">nil</span>) &#123;</span><br><span class="line">      abstractClass = [<span class="built_in">NSURLProtocol</span> <span class="keyword">class</span>];</span><br><span class="line">      placeholderClass = [<span class="built_in">NSURLProtocolPlaceholder</span> <span class="keyword">class</span>];</span><br><span class="line">      registered = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">      placeholder = (<span class="built_in">NSURLProtocol</span>*)<span class="built_in">NSAllocateObject</span>(placeholderClass, <span class="number">0</span>,</span><br><span class="line"><span class="built_in">NSDefaultMallocZone</span>());</span><br><span class="line">      regLock = [<span class="built_in">NSLock</span> new];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_NSHTTPURLProtocol <span class="keyword">class</span>]];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_NSHTTPSURLProtocol <span class="keyword">class</span>]];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_NSFTPURLProtocol <span class="keyword">class</span>]];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_NSFileURLProtocol <span class="keyword">class</span>]];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_NSAboutURLProtocol <span class="keyword">class</span>]];</span><br><span class="line">      [<span class="keyword">self</span> registerClass: [_NSDataURLProtocol <span class="keyword">class</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类初始化的时候会初始化一些类, 发现会默认注册了几个<code>XXXURLProtocol</code>, 这些类都是什么? </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The URL loading system provides support <span class="keyword">for</span> accessing resources using the following protocols:</span><br><span class="line"></span><br><span class="line">File Transfer Protocol (ftp:<span class="comment">//)</span></span><br><span class="line">Hypertext Transfer Protocol (http:<span class="comment">//)</span></span><br><span class="line">Hypertext Transfer Protocol with encryption (https:<span class="comment">//)</span></span><br><span class="line">Local file URLs (file:<span class="comment">///)</span></span><br><span class="line">Data URLs (data:<span class="comment">//)</span></span><br></pre></td></tr></table></figure><p>这就是<code>URL loading system</code>支持的这几个协议, 但是还有一个<code>_NSAboutURLProtocol</code>, <code>about</code>协议, 这个协议应该是web浏览器一个内部的协议, 这可以显示关于浏览器的信息.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)registerClass:(Class)protocolClass &#123;</span><br><span class="line">  <span class="keyword">if</span> ([protocolClass isSubclassOfClass: [<span class="built_in">NSURLProtocol</span> <span class="keyword">class</span>]] == <span class="literal">YES</span>) &#123;</span><br><span class="line">      [regLock lock];</span><br><span class="line">      [registered addObject: protocolClass];</span><br><span class="line">      [regLock unlock];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)unregisterClass:(Class)protocolClass &#123;</span><br><span class="line">[regLock lock];</span><br><span class="line">[registered removeObjectIdenticalTo: protocolClass];</span><br><span class="line">[regLock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是注册函数的实现, 其内部很简单, 如果<code>protocolClass</code>是<code>NSURLProtocol</code>的子类的话, 就往<code>registered</code>数组里添加, <code>registered</code>是一个静态全局数组. 用于存放注册的类. 而反注册则是将注册过的类直接从<code>registered</code>中移除.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">[<span class="keyword">self</span> subclassResponsibility: _cmd];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)startLoading &#123;</span><br><span class="line">[<span class="keyword">self</span> subclassResponsibility: _cmd];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)stopLoading &#123;</span><br><span class="line">[<span class="keyword">self</span> subclassResponsibility: _cmd];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个都是抽象方法, 内部什么都没做, 需要子类覆盖实现的. 如果没有实现, <code>- subclassResponsibility:</code> 则会以<code>exception</code>形式告诉<code>Dev</code>子类忘记覆盖实现了</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest: (<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法则是默认直接返回<code>request</code>对象, 如果子类不需要特殊处理<code>request</code>的话可以不用覆盖.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b &#123;</span><br><span class="line">  a = [<span class="keyword">self</span> canonicalRequestForRequest: a];</span><br><span class="line">  b = [<span class="keyword">self</span> canonicalRequestForRequest: b];</span><br><span class="line">  <span class="keyword">return</span> [a isEqual: b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>isEqual</code>判断, 两个<code>request</code>对象是不是同一个</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)setProperty:(<span class="type">id</span>)value forKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSMutableURLRequest</span> *)request &#123;</span><br><span class="line">[request _setProperty:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)propertyForKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line"><span class="keyword">return</span> [request _propertyForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个用于标记是否已经处理过请求的方法, 将<code>value</code>和<code>key</code>赋值给<code>request</code>, <code>request</code>是一个<code>NSURLRequest</code>对象, 其内部有一个<code>properties</code>可变字典, 用于存放标记过的<code>request</code>.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request cachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse client: (<span class="type">id</span> &lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client &#123;</span><br><span class="line">    </span><br><span class="line">    Class c = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (c == abstractClass || c == placeholderClass) &#123;</span><br><span class="line">        <span class="type">unsigned</span>    count;</span><br><span class="line">        DESTROY(<span class="keyword">self</span>);</span><br><span class="line">        [regLock lock];</span><br><span class="line">        count = [registered count];</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Class proto = [registered objectAtIndex: count];</span><br><span class="line">            <span class="keyword">if</span> ([proto canInitWithRequest:request] == <span class="literal">YES</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span> = [proto alloc];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [regLock unlock];</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> initWithRequest: request</span><br><span class="line">                      cachedResponse: cachedResponse</span><br><span class="line">                              client: client];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">self</span> init]) != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>-&gt;request = [request <span class="keyword">copy</span>];</span><br><span class="line">        <span class="variable language_">this</span>-&gt;cachedResponse = RETAIN(cachedResponse);</span><br><span class="line">        <span class="variable language_">this</span>-&gt;client = client;    <span class="comment">// Not retained</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>NSURLProtocol</code>的初始化方法, 如果当前类是<code>NSURLProtocol</code>或者是<code>NSURLProtocolPlaceholder</code>, 则将<code>registered</code>注册过的类从最后一个依次往前取出来(这就是之前说的为什么后注册的会先被拦截), 如果<code>canInitWithRequest:</code>返回<code>YES</code>, 则初始化<code>self</code>, 如果<code>self</code>不为空, 将赋值<code>reques</code>、<code>cachedResponse</code>和<code>client</code> , 并返回.</p><h3 id="PS-通过对NSURLProtocol的使用和内部实现进行了学习，又get到了一个黑魔法"><a href="#PS-通过对NSURLProtocol的使用和内部实现进行了学习，又get到了一个黑魔法" class="headerlink" title="PS: 通过对NSURLProtocol的使用和内部实现进行了学习，又get到了一个黑魔法~~~"></a>PS: 通过对NSURLProtocol的使用和内部实现进行了学习，又get到了一个黑魔法~~~</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; NSURLProtocol 是 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html&quot;&gt;URL Loading System&lt;/a&gt; 中的一部分, 但是它十分的强大和牛逼, 可以说是苹果又一大黑魔法了, 它能够拦截所有的 &lt;code&gt;URL Loading System&lt;/code&gt;发出的网络请求, 拦截之后就可以做各种自定义处理. 下面就来看下这个神奇的东西。。。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Objective-C" scheme="http://aeronxie.github.io/tags/Objective-C/"/>
    
    <category term="NSURL" scheme="http://aeronxie.github.io/tags/NSURL/"/>
    
    <category term="Network" scheme="http://aeronxie.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>深入理解NSNotificationCenter</title>
    <link href="http://aeronxie.github.io/post/66c23b87.html"/>
    <id>http://aeronxie.github.io/post/66c23b87.html</id>
    <published>2017-10-08T10:01:33.000Z</published>
    <updated>2023-03-25T14:39:55.655Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 这是 <code>iOS</code> 提供的一种 “同步的” 消息通知机制，观察者只要向消息中心注册， 即可接受其他对象发送来的消息，消息发送者和消息接受者两者可以互相一无所知，完全解耦。这种消息通知机制可以应用于任意时间和任何对象，观察者可以有多个，所以消息具有广播的性质.</p></blockquote><span id="more"></span><p>今天研究下其内部实现跟使用.先来看下官方给我们提供的几个API：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)addObserver:(<span class="type">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)postNotification:(<span class="built_in">NSNotification</span> *)notification;</span><br><span class="line">- (<span class="type">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br><span class="line">- (<span class="type">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="type">id</span>)observer;</span><br><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="type">id</span>)observer name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span> &lt;<span class="built_in">NSObject</span>&gt;)addObserverForName:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="type">id</span>)obj queue:(<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)queue usingBlock:(<span class="type">void</span> (^)(<span class="built_in">NSNotification</span> *note))block;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于<code>NSNotificationCenter </code>的源码苹果并没有开源，所以还是打算使用<a href="http://www.gnustep.org/resources/downloads.php">GNU源码</a>进行分析.</p><p><code>- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;</code> 我们经常会通过这个方法注册一个通知, 来看下内部是怎么样注册的</p><p><code>NSNotificationCenter</code>在初始化的时候就会初始化一个<code>Table</code>,这个<code>Table</code>会引用注册的<code>Observation</code>,我们来看下<code>Observation </code>的数据结构</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) != <span class="literal">nil</span>) &#123;</span><br><span class="line">      _table = newNCTable();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="keyword">struct</span>Obs &#123;</span><br><span class="line">  <span class="type">id</span>observer;<span class="comment">/* Object to receive message.*/</span></span><br><span class="line">  SELselector;<span class="comment">/* Method selector.*/</span></span><br><span class="line">  <span class="keyword">struct</span> Obs*next;<span class="comment">/* Next item in linked list.*/</span></span><br><span class="line">  <span class="type">int</span>retained;<span class="comment">/* Retain count for structure.*/</span></span><br><span class="line">  <span class="keyword">struct</span> NCTbl*link;<span class="comment">/* Pointer back to chunk table*/</span></span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Observation structure - One of these objects is created for</span></span><br><span class="line"><span class="comment"> * each -addObserver... request.  It holds the requested selector,</span></span><br><span class="line"><span class="comment"> * name and object.  Each struct is placed in one LinkedList,</span></span><br><span class="line"><span class="comment"> * as keyed by the NAME/OBJECT parameters.</span></span><br><span class="line"><span class="comment"> * If &#x27;next&#x27; is 0 then the observation is unused (ie it has been</span></span><br><span class="line"><span class="comment"> * removed from, or not yet added to  any list).  The end of a</span></span><br><span class="line"><span class="comment"> * list is marked by &#x27;next&#x27; being set to &#x27;ENDOBS&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>注释都比较清晰了，每次调用<code>addObserver</code>方法都会创建一个<code>Observation</code>结构体,其包括了<code>方法</code>、<code>name</code>和<code>object</code>, 每个结构体都会放在一个链表中, <code>NAME</code>或者<code>OBJECT</code>作为<code>key</code>, 如果其<code>next</code>为空，则表示<code>observation</code>未使用或者从链表中移除了或未添加到链表中,链表最后一个<code>next</code>节点会被设成<code>ENDOBS</code>.</p><p>但是唯一奇怪的是类型为<code>NCTbl</code>的结构体, 这个<code>NCTbl</code>是这个什么的东西？？？</p><p><code>NCTbl </code>的数据结构:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> NCTbl &#123;</span><br><span class="line">  Observation*wildcard;<span class="comment">/* Get ALL messages.*/</span></span><br><span class="line">  GSIMapTablenameless;<span class="comment">/* Get messages for any name.*/</span></span><br><span class="line">  GSIMapTablenamed;<span class="comment">/* Getting named messages only.*/</span></span><br><span class="line">  <span class="type">unsigned</span>lockCount;<span class="comment">/* Count recursive operations.*/</span></span><br><span class="line">  <span class="built_in">NSRecursiveLock</span>*_lock;<span class="comment">/* Lock out other threads.*/</span></span><br><span class="line">  Observation*freeList;</span><br><span class="line">  Observation**chunks;</span><br><span class="line">  <span class="type">unsigned</span>numChunks;</span><br><span class="line">  GSIMapTablecache[<span class="built_in">CACHESIZE</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span>chunkIndex;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span>cacheIndex;</span><br><span class="line">&#125; NCTable;</span><br></pre></td></tr></table></figure><p><code>NC table</code>这个结构是用来记录存储的<code>Observation</code>的内存使用情况，如果<code>Observation</code>被从<code>center</code>移除，内存将会还给<code>chunk table</code>的一个空<code>list</code>, 出于性能的考虑，<code>NC table</code>还提供了缓存机制，避免在频繁添加跟删除<code>Observation</code>时，不停的创建、销毁<code>table</code></p><p>了解这些数据结构之后，我们来看下<code>addObserver</code>这个方法内部干了什么:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>) addObserver: (<span class="type">id</span>)observer selector: (SEL)selector name: (<span class="built_in">NSString</span>*)name object: (<span class="type">id</span>)object &#123;</span><br><span class="line">  </span><br><span class="line">  Observation*list;</span><br><span class="line">  Observation*o;</span><br><span class="line">  GSIMapTablem;</span><br><span class="line">  GSIMapNoden;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  lockNCTable(TABLE);</span><br><span class="line"></span><br><span class="line">  o = obsNew(TABLE, selector, observer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">      n = GSIMapNodeForKey(NAMED, (GSIMapKey)(<span class="type">id</span>)name);</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">  m = mapNew(TABLE);</span><br><span class="line">  name = [name copyWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</span><br><span class="line">  GSIMapAddPair(NAMED, (GSIMapKey)(<span class="type">id</span>)name, (GSIMapVal)(<span class="type">void</span>*)m);</span><br><span class="line">  GS_CONSUMED(name)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  m = (GSIMapTable)n-&gt;value.ptr;</span><br><span class="line">     &#125;</span><br><span class="line">      n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">  o-&gt;next = ENDOBS;</span><br><span class="line">  GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  list = (Observation*)n-&gt;value.ptr;</span><br><span class="line">  o-&gt;next = list-&gt;next;</span><br><span class="line">  list-&gt;next = o;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object) &#123;</span><br><span class="line">      n = GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object);</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">  o-&gt;next = ENDOBS;</span><br><span class="line">  GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  list = (Observation*)n-&gt;value.ptr;</span><br><span class="line">  o-&gt;next = list-&gt;next;</span><br><span class="line">  list-&gt;next = o;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      o-&gt;next = WILDCARD;</span><br><span class="line">      WILDCARD = o;</span><br><span class="line">  &#125;</span><br><span class="line">  unlockNCTable(TABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉异常处理部分之后，大概代码是这样，如果在<code>table</code>中有相同的<code>name</code>的链表, 则取出<code>list</code>并增加一个新的节点;否则将新建一个. 如果有<code>object</code>, 且<code>table</code>中有, 则重新给<code>list</code>赋新值, 其就是一个<code>add</code>的过程.</p><p>接下来看下发送通知的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)postNotification:(<span class="built_in">NSNotification</span> *)notification;</span><br><span class="line">- (<span class="type">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br><span class="line">- (<span class="type">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br></pre></td></tr></table></figure><p>这三个方法内部都会执行<code>[self _postAndRelease: notification]</code>, 也就是说<code>_postAndRelease</code>才是发送通知的核心方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>) _postAndRelease: (<span class="built_in">NSNotification</span>*)notification &#123;</span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Find all the observers that specified neither NAME nor OBJECT.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (o = WILDCARD = purgeCollected(WILDCARD); o != ENDOBS; o = o-&gt;next) &#123;</span><br><span class="line">      GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Find the observers that specified OBJECT, but didn&#x27;t specify NAME.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (object) &#123;</span><br><span class="line">      n = GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object);</span><br><span class="line">      <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">  o = purgeCollectedFromMapNode(NAMELESS, n);</span><br><span class="line">  <span class="keyword">while</span> (o != ENDOBS) &#123;</span><br><span class="line">      GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">      o = o-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Find the observers of NAME, except those observers with a non-nil OBJECT</span></span><br><span class="line"><span class="comment">   * that doesn&#x27;t match the notification&#x27;s OBJECT).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">      n = GSIMapNodeForKey(NAMED, (GSIMapKey)((<span class="type">id</span>)name));</span><br><span class="line">      <span class="keyword">if</span> (n) &#123;</span><br><span class="line">  m = (GSIMapTable)n-&gt;value.ptr;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Now send all the notifications.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  count = GSIArrayCount(a);</span><br><span class="line">  <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      o = GSIArrayItemAtIndex(a, count).ext;</span><br><span class="line">      <span class="keyword">if</span> (o-&gt;next != <span class="number">0</span>) &#123;</span><br><span class="line">          [o-&gt;observer performSelector: o-&gt;selector</span><br><span class="line">                                withObject: notification];</span><br><span class="line">       &#125;</span><br><span class="line">         .......</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是发送通知的核心方法了,由于代码太多, 只列出了部分代码, 这个方法里面做了几件事情, 找出所有没有<code>name</code>也没有<code>object</code>的<code>observer</code>; 找出只有<code>object</code>没有<code>name</code>的<code>observer</code>; 找出除了不为<code>nil</code>与<code>notification&#39;s OBJECT</code>不匹配有<code>name</code>的<code>observer</code>; 最后遍历所有<code>observer</code>, 并调用<code>performSelector</code>.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>) performSelector: (SEL)aSelector withObject: (<span class="type">id</span>)anObject &#123;</span><br><span class="line">  IMP msg;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* The Apple runtime API would do:</span></span><br><span class="line"><span class="comment">   * msg = class_getMethodImplementation(object_getClass(self), aSelector);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  msg = objc_msg_lookup(<span class="keyword">self</span>, aSelector);</span><br><span class="line">  <span class="keyword">if</span> (!msg) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (*msg)(<span class="keyword">self</span>, aSelector, anObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>performSelector</code>这个方法的实现并不复杂，通过<code>runtime</code>的方法找出类中对应<code>aSelector</code>的<code>IMP</code>, 并返回函数指针</p><p>对应的移除通知函数跟添加通知也是差不多的机制,这里就不再展开了, 就是通过对应的<code>key</code>找到对应的<code>Observation</code>, 并从<code>Table</code>中移除</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="type">id</span>)observer;</span><br><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="type">id</span>)observer name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>了解了原理之后，我们来看下它的用法以及使用过程中需要注意的地方：</p><p>注册通知有两种方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)addObserver:(<span class="type">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br><span class="line">- (<span class="type">id</span> &lt;<span class="built_in">NSObject</span>&gt;)addObserverForName:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="type">id</span>)obj queue:(<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)queue usingBlock:(<span class="type">void</span> (^)(<span class="built_in">NSNotification</span> *note))block;</span><br></pre></td></tr></table></figure><ul><li>第一种是我们常使用的方法，注册观察者，并传入接收通知时需要执行的方法，如果<code>object</code>传<code>nil</code>的时候，表示可以接收到<code>name</code>相同的所有通知，如果不是<code>nil</code>，将只能接收到<code>name</code>和<code>object</code>都相同的通知</li><li>第二种方法是基于<code>Block</code>来添加观察者，这个观察者包括一个<code>queue</code>和一个<code>block</code>,并且会返回这个观察者对象,当接到通知时执行<code>block</code>所在的线程为添加观察者时传入的<code>queue</code>参数，<code>queue</code>也可以为<code>nil</code>，那么<code>block</code>就在通知所在的线程同步执行</li></ul><p>发送通知的三种方式:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)postNotification:(<span class="built_in">NSNotification</span> *)notification;</span><br><span class="line">- (<span class="type">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br><span class="line">- (<span class="type">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br></pre></td></tr></table></figure><ul><li>三种方式都是发送<code>NSNotification</code>对象给通知中心注册的观察者</li><li>发送通知通过<code>name</code>和<code>object</code>来确定来标识观察者,<code>name</code>和<code>object</code>两个参数的规则相同. 即当通知设置<code>name</code>为某个值时，那么只会发送给<code>name</code>相同的观察者,如果<code>name</code>为<code>nil</code>时那么就会对所有的观察者发送通知; 同理<code>object</code>指发送给某个特定对象通知，当设置为<code>nil</code>时表示所有对象都会通知, 那么如果同时设置<code>name</code>和<code>object</code>参数时就必须同时相同的观察者才能接收到通知. 如果两个参数都为<code>nil</code>那么就是所有观察者都会收到通知</li></ul><h4 id="在对象被释放前需要移除掉观察者，避免已经被释放的对象还接收到通知导致崩溃。"><a href="#在对象被释放前需要移除掉观察者，避免已经被释放的对象还接收到通知导致崩溃。" class="headerlink" title="在对象被释放前需要移除掉观察者，避免已经被释放的对象还接收到通知导致崩溃。"></a>在对象被释放前需要移除掉观察者，避免已经被释放的对象还接收到通知导致崩溃。</h4><p>移除通知有两种方式:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="type">id</span>)observer;</span><br><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="type">id</span>)observer name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br></pre></td></tr></table></figure><ul><li>第一种我们可以传入需要移除的<code>observer</code></li><li>第二种方式通过三个参数来移除指定某个观察者</li></ul><h2 id="NSNotificationQueue-通知队列"><a href="#NSNotificationQueue-通知队列" class="headerlink" title="NSNotificationQueue (通知队列)"></a>NSNotificationQueue (通知队列)</h2><p>通知队列就是将通知放入一个队列里，适当的时机将通知发出去。</p><h5 id="通知队列有2个重要的特性：通知合并和异步发送"><a href="#通知队列有2个重要的特性：通知合并和异步发送" class="headerlink" title="通知队列有2个重要的特性：通知合并和异步发送"></a>通知队列有2个重要的特性：<code>通知合并</code>和<code>异步发送</code></h5><h3 id="通知合并"><a href="#通知合并" class="headerlink" title="通知合并"></a><code>通知合并</code></h3><p>使用<code>NSNotificationQueue</code>的<code>enqueueNotification:postingStyle:coalesceMask:forModes:</code>方法，设置第三个参数<code>coalesceMask</code>的值，来指定不同的合并规则，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSNotificationCoalescing</span>) &#123;</span><br><span class="line">    <span class="built_in">NSNotificationNoCoalescing</span> = <span class="number">0</span>,   <span class="comment">// 不合并</span></span><br><span class="line">    <span class="built_in">NSNotificationCoalescingOnName</span> = <span class="number">1</span>,  <span class="comment">// 按name合并</span></span><br><span class="line">    <span class="built_in">NSNotificationCoalescingOnSender</span> = <span class="number">2</span>  <span class="comment">// 按object合并</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置合并规则后加入到通知队列中，通知队列会按照给定的合并规则，在之前入队的通知中查找，然后移除符合合并规则的通知，这样就达到了只发送一个通知的目的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNotification</span> *notification = [<span class="built_in">NSNotification</span> notificationWithName:<span class="string">@&quot;NotificationName&quot;</span> object:<span class="literal">nil</span>];</span><br><span class="line">[[<span class="built_in">NSNotificationQueue</span> defaultQueue] enqueueNotification:notification postingStyle:<span class="built_in">NSPostWhenIdle</span> coalesceMask:<span class="built_in">NSNotificationCoalescingOnName</span> | <span class="built_in">NSNotificationCoalescingOnSender</span> forModes:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a><code>异步发送</code></h3><p>使用一下方法方法，将通知加到通知队列中，就可以将一个通知异步的发送到当前的线程，这些方法调用后会立即返回，不用再等待通知的所有监听者都接收并处理完。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle;</span><br><span class="line">- (<span class="type">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle coalesceMask:(<span class="built_in">NSNotificationCoalescing</span>)coalesceMask forModes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br></pre></td></tr></table></figure><blockquote><p>第二个方法中，有一个modes参数，当指定了某种特定runloop mode后，该通知值有在当前runloop为指定mode的下，才会被发出 </p></blockquote><p><code>postingStyle</code>有三种类型:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSPostingStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">NSPostWhenIdle</span> = <span class="number">1</span>,  <span class="comment">// 空闲时发送</span></span><br><span class="line">    <span class="built_in">NSPostASAP</span> = <span class="number">2</span>,     <span class="comment">// 尽快发送</span></span><br><span class="line">    <span class="built_in">NSPostNow</span> = <span class="number">3</span>      <span class="comment">// 立刻发送</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过对<code>GNU</code>源码的学习，对通知机制与实现以及用法又有了进一步的理解, <code>NSNotificatonCenter</code>默认是以<code>同步</code>的方式发送通知的，也就是说，当一个对象发送了一个通知，只有当该通知的所有接受者都接受到了<code>NSNotificatonCenter</code>分发的通知消息并且处理完成后，发送通知的对象才能继续执行接下来的方法; 而<code>NSNotificationQueue</code>则可以将一个通知异步的发送到当前的线程，方法调用后会立即返回，不用再等待通知的所有监听者都接收并处理完, 通知队列也能完成对通知的合并.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 这是 &lt;code&gt;iOS&lt;/code&gt; 提供的一种 “同步的” 消息通知机制，观察者只要向消息中心注册， 即可接受其他对象发送来的消息，消息发送者和消息接受者两者可以互相一无所知，完全解耦。这种消息通知机制可以应用于任意时间和任何对象，观察者可以有多个，所以消息具有广播的性质.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Objective-C" scheme="http://aeronxie.github.io/tags/Objective-C/"/>
    
    <category term="通知" scheme="http://aeronxie.github.io/tags/%E9%80%9A%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>深入理解iOS各种锁</title>
    <link href="http://aeronxie.github.io/post/ad4ae88b.html"/>
    <id>http://aeronxie.github.io/post/ad4ae88b.html</id>
    <published>2017-09-29T09:41:56.000Z</published>
    <updated>2023-03-25T14:39:55.629Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🔐顾名思义。。锁上了表示就进不来，解锁后你才可以进来。。在开发中也是如此，在多线程开发中，就经常会使用到锁机制。锁是一种同步机制，用于在多线程的环境中对资源的访问限制，防止多个线程在同一时间操作资源.</p></blockquote><blockquote><p>不同的锁的性能与实现也是不一样的，我们就来研究下在iOS中的几种不同的锁~~</p></blockquote><span id="more"></span><p>我们先来看下这个图</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/2017031601.png"></p><p>这个是Y神在对锁的性能测试后得到的一个结论, 暂且不讨论性能，我们按从上到下来看下这些锁都是怎么样实现的。</p><h2 id="OSSpinLock（自旋锁）"><a href="#OSSpinLock（自旋锁）" class="headerlink" title="OSSpinLock（自旋锁）"></a>OSSpinLock（自旋锁）</h2><p><a href="https://en.wikipedia.org/wiki/Spinlock">SpinLock</a>又称自旋锁,线程通过<code>busy-wait-loop</code>的方式来获取锁，任时刻只有一个线程能够获得锁，其他线程忙等直到获得锁。其实现是通过标志位、 <code>test_and_set</code>指令执行原子性和while循坏对资源进行锁操作</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li><p>对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环(也就是忙等)在那里看是否该自旋锁的保持者已经释放了锁，这也就是自旋锁比互斥锁性能好的原因. 但是假设是时间较长的I/O操作，就会占用大量的CPU时间,从而使锁的效率降低，所以自旋锁比较适用锁使用者保持锁时间比较短的情况.</p></li><li><p>自旋锁不支持递归，如果递归调用的话会造成死锁. 所以递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁</p></li></ul><p>自旋锁使用起来比较简单：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OSSpinLock oslock = OS_SPINLOCK_INIT;</span><br><span class="line">OSSpinLockLock(&amp;oslock);</span><br><span class="line"><span class="comment">// do somthing</span></span><br><span class="line">OSSpinLockUnlock(&amp;oslock);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是自旋锁是有一个比较严重的bug，假设一个低优先级的线程获得了锁并访问了资源，这时一个高优先级的线程也尝试获得这个锁，此时它会处于<code>busy-wait</code>忙等状态从而占用大量 CPU 时间，此时低优先级线程无法与高优先级线程争夺 <code>CPU</code> 时间，从而导致任务不能完成无法释放 <code>lock</code>, 直到超时被操作系统抢占. 这就造成了优先级的反转.</p><h2 id="Dispatch-semaphore-信号量"><a href="#Dispatch-semaphore-信号量" class="headerlink" title="Dispatch_semaphore (信号量)"></a>Dispatch_semaphore (信号量)</h2><p>在<a href="https://opensource.apple.com/tarballs/libdispatch/">libdispatch源码</a>中，我们可以在<code>semaphore.h</code>文件发现其提供的API也是十分的简单，只有三个函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t dispatch_semaphore_create(<span class="type">long</span> value);  <span class="comment">// 创建一个信号</span></span><br><span class="line"><span class="type">long</span> dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);    <span class="comment">// 等待信号</span></span><br><span class="line"><span class="type">long</span> dispatch_semaphore_signal(dispatch_semaphore_t dsema);  <span class="comment">// 发送信号</span></span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore_signal</code>发送一个信号，会让信号总量加1,<code>dispatch_semaphore_wait</code>用于等待信号，让信号总量减1，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatch_atomic_dec(&amp;dsema-&gt;dsema_value) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉了中间的在不同架构下的优化部分，基本上就是这样</p><p><code>#define dispatch_atomic_dec(p)    __sync_sub_and_fetch((p), 1)</code> 这个宏调用的是<code>__sync_sub_and_fetch</code>, 这是个GCC的内置函数，它实现了减法的原子性操作, 将<code>dsema_value </code>的值减一，并把新的值赋给<code>dsema_value </code>,如果信号量的值减1之后大于等于0，表示有资源可用，那么直接返回0, 否则将会都到<code>_dispatch_semaphore_wait_slow </code>函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> _dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123;</span><br><span class="line">mach_timespec_t _timeout;</span><br><span class="line">kern_return_t kr;</span><br><span class="line">uint64_t nsec;</span><br><span class="line"><span class="type">long</span> orig;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="comment">// Mach semaphores appear to sometimes spuriously wake up.  Therefore,</span></span><br><span class="line"><span class="comment">// we keep a parallel count of the number of times a Mach semaphore is</span></span><br><span class="line"><span class="comment">// signaled.</span></span><br><span class="line"><span class="keyword">while</span> ((orig = dsema-&gt;dsema_sent_ksignals)) &#123;</span><br><span class="line"><span class="keyword">if</span> (dispatch_atomic_cmpxchg(&amp;dsema-&gt;dsema_sent_ksignals, orig, orig - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// From xnu/osfmk/kern/sync_sema.c:</span></span><br><span class="line"><span class="comment">// wait_semaphore-&gt;count = -1;  /* we don&#x27;t keep an actual count */</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The code above does not match the documentation, and that fact is</span></span><br><span class="line"><span class="comment">// not surprising. The documented semantics are clumsy to use in any</span></span><br><span class="line"><span class="comment">// practical way. The above hack effectively tricks the rest of the</span></span><br><span class="line"><span class="comment">// Mach semaphore logic to behave like the libdispatch algorithm.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// timeout() already calculates relative time left</span></span><br><span class="line">nsec = _dispatch_timeout(timeout);</span><br><span class="line">_timeout.tv_sec = (<span class="keyword">typeof</span>(_timeout.tv_sec))(nsec / <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">_timeout.tv_nsec = (<span class="keyword">typeof</span>(_timeout.tv_nsec))(nsec % <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br><span class="line">&#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Fall through and try to undo what the fast path did to dsema-&gt;dsema_value</span></span><br><span class="line"><span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line"><span class="keyword">while</span> ((orig = dsema-&gt;dsema_value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (dispatch_atomic_cmpxchg(&amp;dsema-&gt;dsema_value, orig, orig + <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Another thread called semaphore_signal().</span></span><br><span class="line"><span class="comment">// Fall through and drain the wakeup.</span></span><br><span class="line"><span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">&#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入这个方法，<code>timeout</code>有三种case：</p><ul><li><p>DISPATCH _TIME _NOW: 不等待, 如果<code>dsema_value</code>小于0，那么将其+1, 然后返回<code>KERN_OPERATION_TIMED_OUT</code>； 如果大于等于0，表示有资源可用，那么将会进入到again;</p></li><li><p>DISPATCH _TIME _FOREVER: 无线等待, <code>semaphore_wait</code>将无限等待到信号值等于于<code>KERN_ABORTED </code>;<br>等信号来了，跳转到again;</p></li><li><p>Default: 计时等待, <code>semaphore_timedwait(dsema-&gt;dsema_port, _timeout)</code>直到<code>timeout</code>或者<code>KERN_ABORTED</code>为止</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> dispatch_semaphore_signal(dispatch_semaphore_t dsema) &#123;</span><br><span class="line"><span class="keyword">if</span> (dispatch_atomic_inc(&amp;dsema-&gt;dsema_value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送信号与等待信号的函数差不多, <code>dispatch_atomic_inc</code>, <code>#define dispatch_atomic_inc(p)    __sync_add_and_fetch((p), 1)</code> 这也是一个GCC内置函数, 若信号值加1后大于零，表示有资源可用，那么直接返回0, 否则将会走到<code>_dispatch_semaphore_signal_slow </code>中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema) &#123;</span><br><span class="line">kern_return_t kr;</span><br><span class="line"></span><br><span class="line">_dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before dsema_sent_ksignals is incremented we can rely on the reference</span></span><br><span class="line"><span class="comment">// held by the waiter. However, once this value is incremented the waiter</span></span><br><span class="line"><span class="comment">// may return between the atomic increment and the semaphore_signal(),</span></span><br><span class="line"><span class="comment">// therefore an explicit reference must be held in order to safely access</span></span><br><span class="line"><span class="comment">// dsema after the atomic increment.</span></span><br><span class="line">_dispatch_retain(dsema);</span><br><span class="line"></span><br><span class="line">dispatch_atomic_inc(&amp;dsema-&gt;dsema_sent_ksignals);</span><br><span class="line"></span><br><span class="line">kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line"></span><br><span class="line">_dispatch_release(dsema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果信号量之前的值小于0，那么信号量加1；其核心是:<code>semaphore_signal(dsema-&gt;dsema_port)</code> 利用系统的信号量库实现发送信号量的功能，最后返回1, 表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程(当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒).</p><p>信号量使用起来也是比较简单的:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);   </span><br><span class="line">dispatch_semaphore_signal(semaphore);   </span><br><span class="line">dispatch_group_wait(semaphore, DISPATCH_TIME_FOREVER);   </span><br></pre></td></tr></table></figure><h2 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h2><p><code>pthread</code> 表示 <code>POSIX</code>标准的线程库，该标准定义了创建和操纵线程的一整套API, <code>pthread_mutex</code> 表示的是互斥锁</p><p>POSIX下抽象了一个锁类型的结构：<code>ptread _mutex _t</code>  我们可以看下在iOS中，是怎么定义的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __darwin_pthread_mutex_t pthread_mutex_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _opaque_pthread_mutex_t __darwin_pthread_mutex_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _opaque_pthread_mutex_t &#123;</span><br><span class="line"><span class="type">long</span> __sig;</span><br><span class="line"><span class="type">char</span> __opaque[__PTHREAD_MUTEX_SIZE__];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>ptread _mutex _t</code>其实就是一个<code>_opaque_pthread_mutex_t </code>结构体, 其原理与信号量类似,不使用忙等，而是阻塞线程并睡眠，需要进行上下文的切换. PS:一个线程只能申请一次锁，只有在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃.</p><p>因为<code>ptread _mutex _t</code>支持多种类型, 在申请加锁时，需要对锁的类型进行判断, 虽然实现跟信号量差不多，但是性能却略低一些.</p><p>我们来看下其提供的API</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建锁 可以传一个属性为 `pthread_mutexattr_t` 类型的参数</span></span><br><span class="line"><span class="type">int</span> pthread_mutex_init(pthread_mutex_t * __restrict,<span class="keyword">const</span> pthread_mutexattr_t * _Nullable __restrict);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请锁</span></span><br><span class="line"><span class="type">int</span> pthread_mutex_lock(pthread_mutex_t *);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="type">int</span> pthread_mutex_unlock(pthread_mutex_t *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  初始化互斥锁属性对象</span></span><br><span class="line"><span class="type">int</span> pthread_mutexattr_init(pthread_mutexattr_t *);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为所属性对象设置类型</span></span><br><span class="line"><span class="type">int</span> pthread_mutexattr_settype(pthread_mutexattr_t *, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">有以下几种类型</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mutex type attributes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTHREAD_MUTEX_NORMAL0       <span class="comment">// 普通</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTHREAD_MUTEX_ERRORCHECK1       <span class="comment">// errorcheck</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTHREAD_MUTEX_RECURSIVE2   <span class="comment">// 递归</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_NORMAL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会尝试加锁，如果该互斥锁已经锁定，则返回一个不为0的错误值，如果该互斥锁没有锁定，则返回0，表示尝试加锁成功</span></span><br><span class="line"><span class="type">int</span> pthread_mutex_trylock(pthread_mutex_t *);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁锁,销毁成功则会返回0,否则会返回错误码</span></span><br><span class="line"><span class="type">int</span> pthread_mutex_destroy(pthread_mutex_t *);</span><br></pre></td></tr></table></figure><p>来看下使用方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;       <span class="comment">// 定义一个锁属性对象</span></span><br><span class="line">pthread_mutexattr_init(&amp;attr);  <span class="comment">// 初始化锁属性对象</span></span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);  <span class="comment">// 为锁设置的属性类型</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;   <span class="comment">// 定义一个锁对象</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr) <span class="comment">// 创建锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex); <span class="comment">// 申请锁  </span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex); <span class="comment">// 释放锁  </span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex); <span class="comment">// 销毁锁</span></span><br></pre></td></tr></table></figure><h2 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h2><p>由于GNU的源码是开源的，也跟Cocoa的实现差不多，所以我们打算使用 <a href="http://www.gnustep.org/resources/downloads.php">GNU源码</a> 来分析<code>NSLock</code></p><p>我们先来看看<code>NSLock</code>的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>) initialize &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">BOOL</span>beenHere = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (beenHere == <span class="literal">NO</span>) &#123;</span><br><span class="line">      beenHere = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Initialise attributes for the different types of mutex.</span></span><br><span class="line"><span class="comment">       * We do it once, since attributes can be shared between multiple</span></span><br><span class="line"><span class="comment">       * mutexes.</span></span><br><span class="line"><span class="comment">       * If we had a pthread_mutexattr_t instance for each mutex, we would</span></span><br><span class="line"><span class="comment">       * either have to store it as an ivar of our NSLock (or similar), or</span></span><br><span class="line"><span class="comment">       * we would potentially leak instances as we couldn&#x27;t destroy them</span></span><br><span class="line"><span class="comment">       * when destroying the NSLock.  I don&#x27;t know if any implementation</span></span><br><span class="line"><span class="comment">       * of pthreads actually allocates memory when you call the</span></span><br><span class="line"><span class="comment">       * pthread_mutexattr_init function, but they are allowed to do so</span></span><br><span class="line"><span class="comment">       * (and deallocate the memory in pthread_mutexattr_destroy).</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      pthread_mutexattr_init(&amp;attr_normal);</span><br><span class="line">      pthread_mutexattr_settype(&amp;attr_normal, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">      pthread_mutexattr_init(&amp;attr_reporting);</span><br><span class="line">      pthread_mutexattr_settype(&amp;attr_reporting, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">      pthread_mutexattr_init(&amp;attr_recursive);</span><br><span class="line">      pthread_mutexattr_settype(&amp;attr_recursive, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* To emulate OSX behavior, we need to be able both to detect deadlocks</span></span><br><span class="line"><span class="comment">       * (so we can log them), and also hang the thread when one occurs.</span></span><br><span class="line"><span class="comment">       * the simple way to do that is to set up a locked mutex we can</span></span><br><span class="line"><span class="comment">       * force a deadlock on.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      pthread_mutex_init(&amp;deadlock, &amp;attr_normal);</span><br><span class="line">      pthread_mutex_lock(&amp;deadlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>NSLock</code>类初始化的时候，初始化了三种属性,<code>attr_normal </code>、<code>attr_reporting </code>、<code>attr_recursive </code>,对应的类型分别是<code>PTHREAD_MUTEX_NORMAL</code>、<code>PTHREAD_MUTEX_ERRORCHECK </code>、<code>PTHREAD_MUTEX_RECURSIVE </code>,<br>当执行<code>NSLock</code>的<code>init</code>方法时：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Use an error-checking lock.  This is marginally slower, but lets us throw</span></span><br><span class="line"><span class="comment"> * exceptions when incorrect locking occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">id</span>) init &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> != pthread_mutex_init(&amp;_mutex, &amp;attr_reporting)) &#123;</span><br><span class="line">    DESTROY(<span class="keyword">self</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的是属性为<code>attr_reporting</code>的锁，也就是<code>error-checking</code>锁, 这样性能相比于<code>attr_normal</code>的锁，会稍稍降低，因为它会在发生提示时牺牲一定的性能来换取提示错误信息</p><p>它提供了两个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 内部调用的还是`pthread_mutex`的 `pthread_mutex_trylock `方法, 如果尝试加锁成功则返回YES否则为NO</span></span><br><span class="line">- (<span class="type">BOOL</span>)tryLock &#123;</span><br><span class="line">    <span class="type">int</span> err = pthread_mutex_trylock(&amp;_mutex);</span><br><span class="line">   <span class="keyword">return</span> (<span class="number">0</span> == err) ? <span class="literal">YES</span> : <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法会在所指定 `Date` 之前尝试加锁，会阻塞线程，如果在指定时间之前都不能加锁，则返回 NO，指定时间之前能加锁，则返回 YES</span></span><br><span class="line">- (<span class="type">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="type">int</span> err = pthread_mutex_trylock(&amp;_mutex);</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == err) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">if</span> (EDEADLK == err) &#123;</span><br><span class="line">  _NSLockError(<span class="keyword">self</span>, _cmd, <span class="literal">NO</span>)\<span class="number">3</span></span><br><span class="line">   &#125;</span><br><span class="line">      sched_yield();</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">while</span> ([limit timeIntervalSinceNow] &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sched_yield </code>函数可以使用另一个级别等于或高于当前线程的线程先运行.如果没有符合条件的线程，那么这个函数将会立刻返回然后继续执行当前线程的程序.</p><p><code>NSLcok</code>使用起来也是比较简单的，因为遵循了<code>&lt;NSLocking&gt;</code>协议，协议中仅有两个方法，<code>- (void)lock;``- (void)unlock;</code> 所以<code>NSLock</code>对象可以直接调用这俩个方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([lock tryLock]) &#123; <span class="comment">// 尝试加锁，如果失败返回NO，不会阻塞该线程</span></span><br><span class="line">[lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ([lock lockBeforeDate:date]) &#123; <span class="comment">// 在Date之前尝试加锁，如果不能加锁，则返回NO</span></span><br><span class="line">[lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NSCondition（条件变量）"><a href="#NSCondition（条件变量）" class="headerlink" title="NSCondition（条件变量）"></a>NSCondition（条件变量）</h2><p>使用<code>NSCondition</code>（条件变量）对象来控制进程的同步，即可实现生产者消费者问题。其内部是通过<code>pthread_cond_t </code>来实现. <code>NSCondition</code>是利用线程间共享的全局变量进行同步的一种机制，<code>NSCondition</code>也实现了<code>NSLocking</code>协议，因此也可以调用<code>lock</code>、 <code>unlock</code>来实现线程的同步, 为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起.</p><h4 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h4><p>首先要创建公用的NSCondition实例。然后：</p><ul><li>消费者取得锁，取产品，如果没有，则wait，这时会释放锁，直到有线程唤醒它去消费产品；</li><li>生产者制造产品，首先也是要取得锁，然后生产，再发signal，这样可唤醒wait的消费者。</li></ul><p><code>NSCondition</code>提供了这么些API：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)wait; <span class="comment">// 让当前线程处于等待状态</span></span><br><span class="line">- (<span class="type">BOOL</span>)waitUntilDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="type">void</span>)signal; <span class="comment">// CPU发信号告诉线程不用在等待，可以继续执行</span></span><br><span class="line">- (<span class="type">void</span>)broadcast; <span class="comment">// 唤醒等待的所有线程 </span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒在此NSCondition对象上等待的所有线程    </span></span><br><span class="line">- (<span class="type">void</span>)broadcast &#123;</span><br><span class="line">  pthread_cond_broadcast(&amp;_condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSCondition 的初始化方法，通过`pthread_cond_init`创建一个条件对象，并初始化一个属性为`attr_reporting `的锁</span></span><br><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> != pthread_cond_init(&amp;_condition, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">  DESTROY(<span class="keyword">self</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> != pthread_mutex_init(&amp;_mutex, &amp;attr_reporting)) &#123;</span><br><span class="line">  pthread_cond_destroy(&amp;_condition);</span><br><span class="line">  DESTROY(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒在此NSCondition对象上等待的单个线程</span></span><br><span class="line">- (<span class="type">void</span>)signal &#123;</span><br><span class="line">  pthread_cond_signal(&amp;_condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法让线程一直等待</span></span><br><span class="line">- (<span class="type">void</span>)wait &#123;</span><br><span class="line">  pthread_cond_wait(&amp;_condition, &amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一直等待直到超时时间</span></span><br><span class="line">- (<span class="type">BOOL</span>)waitUntilDate: (<span class="built_in">NSDate</span>*)limit &#123;</span><br><span class="line">  <span class="built_in">NSTimeInterval</span> t = [limit timeIntervalSince1970];</span><br><span class="line">  <span class="type">double</span> secs, subsecs;</span><br><span class="line">  <span class="keyword">struct</span> timespec timeout;</span><br><span class="line">  <span class="type">int</span> retVal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Split the float into seconds and fractions of a second</span></span><br><span class="line">  subsecs = modf(t, &amp;secs);</span><br><span class="line">  timeout.tv_sec = secs;</span><br><span class="line">  <span class="comment">// Convert fractions of a second to nanoseconds</span></span><br><span class="line">  timeout.tv_nsec = subsecs * <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置等待条件变量cond，如果超时，则返回；如果等待到条件变量cond，也返回 </span></span><br><span class="line">   retVal = pthread_cond_timedwait(&amp;_condition, &amp;_mutex, &amp;timeout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (retVal == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retVal == EINVAL) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;Invalid arguments to pthread_cond_timedwait&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面来看下使用方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消费者</span></span><br><span class="line">- (<span class="type">void</span>)createConsumenr &#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">[condition lock];</span><br><span class="line">    <span class="keyword">while</span> (products.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;wait for products&quot;</span>);</span><br><span class="line">        [condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    [products removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;comsume a product&quot;</span>);</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建生产者</span></span><br><span class="line">- (<span class="type">void</span>)createProducter &#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line"> [condition lock];</span><br><span class="line">    [products addObject:[[<span class="built_in">NSObject</span> alloc] init]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;produce a product&quot;</span>);</span><br><span class="line">    [condition signal];</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>condition</code>进入到判断条件中，<code>products.count == 0</code>时，<code>condition</code>调用<code>wait</code>使当前线程处于等待状态；其他线程开始访问<code>products</code>，当<code>NSObject</code>创建完成并加入到<code>products</code>时，cpu发出<code>single</code>的信号时，处于等待的线程被唤醒，开始执行<code>[products removeObjectAtIndex:0]</code></p><h2 id="pthread-mutex-recursive"><a href="#pthread-mutex-recursive" class="headerlink" title="pthread_mutex (recursive)"></a>pthread_mutex (recursive)</h2><p>这个就是上文说的<code>pthread_mutex </code>, 但它的属性类型是<code>PTHREAD_MUTEX_RECURSIVE</code>, 也就是支持递归，允许一个线程递归的申请锁，而不会造成死锁. 这与等会说到的<code>NSRecursiveLock</code>实现类似</p><h2 id="NSRecursiveLock（递归锁）"><a href="#NSRecursiveLock（递归锁）" class="headerlink" title="NSRecursiveLock（递归锁）"></a>NSRecursiveLock（递归锁）</h2><p>我们来看下它的实现,</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">  [<span class="built_in">NSLock</span> <span class="keyword">class</span>];<span class="comment">// Ensure mutex attributes are set up.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> != pthread_mutex_init(&amp;_mutex, &amp;attr_recursive)) &#123;</span><br><span class="line">  DESTROY(<span class="keyword">self</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它在类初始化的时候，调用的是<code>NSLock </code>类的初始化方法，也就是初始化了三种<code>attributes</code>, 然后在<code>init</code>的时候，初始化了属性为<code>attr_recursive</code>的锁，也就是递归锁，也就是说它支持递归和循环, <code>NSRecursiveLock</code> 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功, 所以不会造成死锁.</p><p>因为内部判断了锁的类型，所以性能会比<code>pthread_mutex(recursive)</code> 要低一些</p><h2 id="NSConditionLock-（条件锁）"><a href="#NSConditionLock-（条件锁）" class="headerlink" title="NSConditionLock （条件锁）"></a>NSConditionLock （条件锁）</h2><p>其实条件锁也是一个生产者-消费者模式，内部通过<code>NSCondition</code>来实现. <code>NSConditionLock</code>会持有一个 <code>NSCondition</code> 对象和 <code>_condition_value</code> 属性，在初始化时就会对这个属性进行赋值 ,默认的<code>init</code>, <code>value</code>则为<code>0</code>, 我们来看下它的方法实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithCondition: <span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithCondition:(<span class="built_in">NSInteger</span>)value &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">nil</span> == (_condition = [<span class="built_in">NSCondition</span> new])) &#123;</span><br><span class="line">  DESTROY(<span class="keyword">self</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         _condition_value = value;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中很重要的一个属性便是<code>condition</code>,外部传入的<code>condition</code>与内部相同才会获取到<code>lock</code>对象，反之阻塞当前线程，直到<code>condition</code>相同, 这其实是一个消费者方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者方法</span></span><br><span class="line">- (<span class="type">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)value &#123;</span><br><span class="line">  [_condition lock];</span><br><span class="line">  <span class="keyword">while</span> (value != _condition_value) &#123;</span><br><span class="line">      [_condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者方法</span></span><br><span class="line">- (<span class="type">void</span>)unlockWithCondition:(<span class="built_in">NSInteger</span>)value &#123;</span><br><span class="line">  _condition_value = value;</span><br><span class="line">  [_condition broadcast];</span><br><span class="line">  [_condition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是解锁的时候并不是<code>condition</code>相同才能解锁, 而是给<code>_condition_value </code>赋值并通过<code>broadcast</code>方法唤醒在此<code>NSCondition</code>对象上等待的所有线程, 最后解锁 </p><p>我们来看下使用方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSConditionLock</span> *lock = [[<span class="built_in">NSConditionLock</span> alloc] initWithCondition:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1    </span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lockWhenCondition:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;线程1&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2   </span></span><br><span class="line"> <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);<span class="comment">//以保证让线程2的代码后执行</span></span><br><span class="line">        <span class="keyword">if</span> ([lock tryLockWhenCondition:<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;线程2&quot;</span>);</span><br><span class="line">            [lock unlockWithCondition:<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;线程2解锁成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程3</span></span><br><span class="line"> <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">2</span>);<span class="comment">//以保证让线程2的代码后执行</span></span><br><span class="line">        <span class="keyword">if</span> ([lock tryLockWhenCondition:<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;线程3&quot;</span>);</span><br><span class="line">            [lock unlock];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;线程3解锁成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程4</span></span><br><span class="line"> <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">3</span>);<span class="comment">//以保证让线程2的代码后执行</span></span><br><span class="line">        <span class="keyword">if</span> ([lock tryLockWhenCondition:<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;线程4&quot;</span>);</span><br><span class="line">            [lock unlockWithCondition:<span class="number">1</span>];    </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;线程4解锁成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">01</span>:<span class="number">03.235</span> LuaTest[<span class="number">72076</span>:<span class="number">8074748</span>] 线程<span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">01</span>:<span class="number">03.236</span> LuaTest[<span class="number">72076</span>:<span class="number">8074748</span>] 线程<span class="number">2</span>解锁成功</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">01</span>:<span class="number">04.232</span> LuaTest[<span class="number">72076</span>:<span class="number">8074747</span>] 线程<span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">01</span>:<span class="number">04.232</span> LuaTest[<span class="number">72076</span>:<span class="number">8074747</span>] 线程<span class="number">3</span>解锁成功</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">01</span>:<span class="number">05.234</span> LuaTest[<span class="number">72076</span>:<span class="number">8074770</span>] 线程<span class="number">4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">01</span>:<span class="number">05.235</span> LuaTest[<span class="number">72076</span>:<span class="number">8074770</span>] 线程<span class="number">4</span>解锁成功</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">01</span>:<span class="number">05.235</span> LuaTest[<span class="number">72076</span>:<span class="number">8074767</span>] 线程<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面代码先输出了 <code>线程 2</code>，因为<code>线程 1</code> 的加锁条件不满足，初始化时候的 <code>condition</code> 参数为 0，而加锁条件是 <code>condition</code> 为 1，所以加锁失败。<code>locakWhenCondition</code> 与 lock 方法类似，加锁失败会阻塞线程，所以<code>线程 1</code> 会被阻塞着，而 <code>tryLockWhenCondition</code> 方法就算条件不满足，也会返回 NO，不会阻塞当前线程。回到上面的代码，<code>线程 2</code> 执行了 <code>[lock unlockWithCondition:2]</code> 所以 <code>Condition</code> 被修改成了 <code>2</code>。而<code>线程 3</code> 的加锁条件是 <code>Condition</code> 为 <code>2</code>， 所以<code>线程 3</code> 才能加锁成功，<code>线程 3</code> 执行了 <code>[lock unlock]</code>; 解锁成功且不改变 <code>Condition</code> 值。<code>线程 4</code> 的条件也是 <code>2</code>，所以也加锁成功，解锁时将 <code>Condition</code> 改成 <code>1</code>。这个时候<code>线程 1</code> 终于可以加锁成功，解除了阻塞。 假如<code>线程4``unlockWithCondition </code>解锁条件为<code>非1</code>, 内部<code>conditon</code>值不一致, 那么<code>线程1</code>将会永久阻塞.</p><p>从上面可以得出，NSConditionLock 还可以实现任务之间的依赖。</p><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="@Synchronized"></a>@Synchronized</h2><p>先来看下用法，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span> (obj) &#123;</span><br><span class="line"><span class="comment">// do something            </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是只需要传入一个对象，就可以使代码块实现同步</p><p>我们在<code>Xcode</code>中选择<code>Product -&gt; Perform Action -&gt; Assemble &#39;main.m&#39;</code>, 我们便能看到汇编代码…</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/5AEA053C-6EED-41CE-A29B-69EB444F2E9D.png"></p><p>我们会发现两个比较陌生的方法调用 <code>_objc_sync_enter</code>和 <code>_objc_sync_exit</code>  emmmmmm ？ </p><p>… 我们只调用了<code>synchronized </code>… 莫非就是这个函数的底层实现？ 我们到<a href="https://opensource.apple.com/tarballs/objc4/">objc源码找找</a>, 在<code>objc-sync.mm</code>中找到了这两个函数的实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on &#x27;obj&#x27;. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with &#x27;obj&#x27; if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> objc_sync_enter(<span class="type">id</span> obj) &#123;</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData *data = id2data(obj, ACQUIRE);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的注释已经很清楚了，这个方法的实现用的是递归锁，首先判断<code>obj</code>是否存在，如果存在则通过<code>obj</code>创建一个<code>SyncData </code>对象，然后调用<code>lock</code>，否则则直接调用<code>objc_sync_nil ()</code>方法，这是一个空方法，啥都没干,也就是说如果直接调用<code>@synchronized(nil)</code>的话，其实什么都没有做，也不会创建锁.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SyncData &#123;</span><br><span class="line">    <span class="keyword">struct</span> SyncData* nextData;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class="line">    int32_t threadCount;  <span class="comment">// number of THREADS using this block</span></span><br><span class="line">    recursive_mutex_t mutex;</span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure><p><code>SyncData </code>包括<code>nextData</code>、<code>object </code>、<code>threadCount (线程数)</code>、<code>mutex (递归锁)</code></p><p>我们来看下方法是如何通过<code>obj</code>获取到<code>data</code>的，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Fast cache: two fixed pthread keys store a single SyncCacheItem. </span></span><br><span class="line"><span class="comment">  This avoids malloc of the SyncCache for threads that only synchronize </span></span><br><span class="line"><span class="comment">  a single object at a time.</span></span><br><span class="line"><span class="comment">  SYNC_DATA_DIRECT_KEY  == SyncCacheItem.data</span></span><br><span class="line"><span class="comment">  SYNC_COUNT_DIRECT_KEY == SyncCacheItem.lockCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> SyncList &#123;</span><br><span class="line">    SyncData *data;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line">    SyncList() : data(<span class="literal">nil</span>), lock(fork_unsafe_lock) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use multiple parallel lists to decrease contention among unrelated objects.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="keyword">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></table></figure><p>发现定义了<code>sDataLists </code>，一个<code>SyncList</code> 结构体数组,</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">unsigned</span> <span class="type">int</span> indexForPointer(<span class="keyword">const</span> <span class="type">void</span> *p) &#123;</span><br><span class="line">    uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; operator[] (<span class="keyword">const</span> <span class="type">void</span> *p) &#123; </span><br><span class="line">   <span class="keyword">return</span> array[indexForPointer(p)].value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过哈希算法将传入<code>obj</code>映射到数组上的一个下标, 是将对象指针在内存的地址,映射到另一个内存空间来存放<code>SyncList</code>,这样能够保证不会发生数组越界，当调用<code>objc_sync_enter </code>时，通过<code>obj</code>内存地址的哈希值找到 <code>SyncData</code>,并调用<code>lock</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// End synchronizing on &#x27;obj&#x27;. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> objc_sync_exit(<span class="type">id</span> obj) &#123;</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_sync_exit </code>方法也差不多，通过<code>obj</code>内存地址的哈希值找到 <code>SyncData</code>,并调用<code>tryUnlock</code>,如果返回true,则表示解锁成功，否则是失败</p><h2 id="NSDistributedLock-分布式锁"><a href="#NSDistributedLock-分布式锁" class="headerlink" title="NSDistributedLock (分布式锁)"></a>NSDistributedLock (分布式锁)</h2><p><code>NSDistributedLock</code>与其他锁不太一样, 它没有实现<code>NSLocking</code>协议, 它底层是基于文件系统实现的互斥锁，会自动创建用于标识的临时文件或文件夹，执行完后自动清除临时文件或文件夹；可以在多个进程或多个程序之间需要构建互斥的场景中使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">  <span class="keyword">if</span> (mgr == <span class="literal">nil</span>) &#123;</span><br><span class="line">      mgr = RETAIN([<span class="built_in">NSFileManager</span> defaultManager]);</span><br><span class="line">      [[<span class="built_in">NSObject</span> leakAt: &amp;mgr] release];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithPath:(<span class="built_in">NSString</span>*)aPath &#123;</span><br><span class="line">  <span class="built_in">NSString</span>*lockDir;</span><br><span class="line">  <span class="type">BOOL</span>isDirectory;</span><br><span class="line"></span><br><span class="line">  _lockPath = [[aPath stringByStandardizingPath] <span class="keyword">copy</span>];</span><br><span class="line">  _lockTime = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  lockDir = [_lockPath stringByDeletingLastPathComponent];</span><br><span class="line">  <span class="keyword">if</span> ([mgr fileExistsAtPath: lockDir isDirectory: &amp;isDirectory] == <span class="literal">NO</span>) &#123;</span><br><span class="line">      DESTROY(<span class="keyword">self</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">if</span> (isDirectory == <span class="literal">NO</span>) &#123;</span><br><span class="line">      DESTROY(<span class="keyword">self</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ([mgr isWritableFileAtPath: lockDir] == <span class="literal">NO</span>) &#123;</span><br><span class="line">      DESTROY(<span class="keyword">self</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ([mgr isExecutableFileAtPath: lockDir] == <span class="literal">NO</span>) &#123;</span><br><span class="line">      DESTROY(<span class="keyword">self</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从它的初始化方法便能够看出内部是基于<code>NSFileManager</code>文件系统实现的，由于其没有实现<code>NSLocking</code>协议，所以没有会阻塞线程的<code>lock</code>方法，取而代之的是非阻塞的<code>tryLock</code>方法, <code>NSDistributedLock</code>只有在锁持有者显式地释放后才会被释放. 如果你的程序在一个<code>NSDistributedLock </code>的时候崩溃了，其他客户端无法访问该受保护的资源。在这种情况下，你可以使用<code>breadLock</code>方法来打破现存的锁以便你可以获取它, 但是通常应该避免打破锁，除非你确定拥有进程已经死亡并不可能再释放该锁. 和其他类型的锁一样，当你使用<code>NSDistributedLock</code>对象时，你也可以通过调用<code>unlock</code>方法来释放它</p><h3 id="PS：花了快一星期零零碎碎的时间，研究了一下这些🔐，发现收货良多，从🔐的使用到实现都有了更进一步的认识-以及对锁的性能也有了进一步的理解"><a href="#PS：花了快一星期零零碎碎的时间，研究了一下这些🔐，发现收货良多，从🔐的使用到实现都有了更进一步的认识-以及对锁的性能也有了进一步的理解" class="headerlink" title="PS：花了快一星期零零碎碎的时间，研究了一下这些🔐，发现收货良多，从🔐的使用到实现都有了更进一步的认识.以及对锁的性能也有了进一步的理解."></a>PS：花了快一星期零零碎碎的时间，研究了一下这些🔐，发现收货良多，从🔐的使用到实现都有了更进一步的认识.以及对锁的性能也有了进一步的理解.</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🔐顾名思义。。锁上了表示就进不来，解锁后你才可以进来。。在开发中也是如此，在多线程开发中，就经常会使用到锁机制。锁是一种同步机制，用于在多线程的环境中对资源的访问限制，防止多个线程在同一时间操作资源.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;不同的锁的性能与实现也是不一样的，我们就来研究下在iOS中的几种不同的锁~~&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Objective-C" scheme="http://aeronxie.github.io/tags/Objective-C/"/>
    
    <category term="lock" scheme="http://aeronxie.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>强大的Fishhook</title>
    <link href="http://aeronxie.github.io/post/fc046380.html"/>
    <id>http://aeronxie.github.io/post/fc046380.html</id>
    <published>2017-09-25T02:15:00.000Z</published>
    <updated>2023-03-25T14:39:55.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在iOS中，如果我们需要替换一个函数的实现，我们会想到通过<code>Method Swizzle</code>来实现，其实也就是通过<code>runtime</code>提供的API在运行时将函数的实现给替换了，正是因为<code>Objective-C</code>是动态语言,所以我们可以通过<code>runtime</code>做各种事情。。。但是如果是静态语言（C），我们是否也可以将函数<code>hook</code>住呢？</p></blockquote><span id="more"></span><h5 id="答案也是肯定的-Facebook提供了一个强大的库Fishhook，静态语言我们也仍然可以hook住接下来，我们就来分析下这个强大的库是如何实现的"><a href="#答案也是肯定的-Facebook提供了一个强大的库Fishhook，静态语言我们也仍然可以hook住接下来，我们就来分析下这个强大的库是如何实现的" class="headerlink" title="答案也是肯定的,Facebook提供了一个强大的库Fishhook，静态语言我们也仍然可以hook住接下来，我们就来分析下这个强大的库是如何实现的"></a>答案也是肯定的,<code>Facebook</code>提供了一个强大的库<a href="https://github.com/facebook/fishhooks">Fishhook</a>，静态语言我们也仍然可以hook住<del>接下来，我们就来分析下这个强大的库是如何实现的</del></h5><p>先来看下官方的解释:</p><p><code>dyld</code> 通过更新 <code>Mach-O</code> 二进制文件 <code>__DATA</code> 段中的指针来绑定 <code>lazy</code> 和 <code>non-lazy</code> 的符号(在 Mach-O 中，相对应的就是 <code>_nl_symbol_ptr</code>（non-lazy符号表）和 <code>_la_symbol_ptr</code>（lazy符号表）, 这两个指针表，保存了与符号表表对应的函数指针。<br>) ，<code>fishhook</code> 先确定某一个符号在 <code>__DATA</code> 段中的位置，然后保存原符号对应的函数指针，并使用新的函数指针覆盖原有符号的函数指针，实现重绑定。</p><p>##源码<br>在<code>fishhook</code>的<code>.h</code>文件中，只有很少的东西，两个函数接口和一个结构体</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> rebinding &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">char</span> *name;  </span><br><span class="line">  <span class="type">void</span> *replacement;  <span class="comment">// 被替换的函数</span></span><br><span class="line">  <span class="type">void</span> **replaced;    <span class="comment">// 替换函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For each rebinding in rebindings, rebinds references to external, indirect</span></span><br><span class="line"><span class="comment"> * symbols with the specified name to instead point at replacement for each</span></span><br><span class="line"><span class="comment"> * image in the calling process as well as for all future images that are loaded</span></span><br><span class="line"><span class="comment"> * by the process. If rebind_functions is called more than once, the symbols to</span></span><br><span class="line"><span class="comment"> * rebind are added to the existing list of rebindings, and if a given symbol</span></span><br><span class="line"><span class="comment"> * is rebound more than once, the later rebinding will take precedence.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rebind_symbols(<span class="keyword">struct</span> rebinding rebindings[], size_t rebindings_nel);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Rebinds as above, but only in the specified image. The header should point</span></span><br><span class="line"><span class="comment"> * to the mach-o header, the slide should be the slide offset. Others as above.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rebind_symbols_image(<span class="type">void</span> *header,</span><br><span class="line">                         intptr_t slide,</span><br><span class="line">                         <span class="keyword">struct</span> rebinding rebindings[],</span><br><span class="line">                         size_t rebindings_nel);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="rebind-symbols"><a href="#rebind-symbols" class="headerlink" title="rebind_symbols"></a>rebind_symbols</h2><p>先来看一下<code>rebind_symbols</code>函数</p><p><code>int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);</code> </p><p>这个方法便是我们用于实现hook的方法，我们来看下实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rebind_symbols(<span class="keyword">struct</span> rebinding rebindings[], size_t rebindings_nel) &#123;</span><br><span class="line">  <span class="type">int</span> retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">  <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If this was the first call, register callback for image additions (which is also invoked for</span></span><br><span class="line">  <span class="comment">// existing images, otherwise, just run on existing images</span></span><br><span class="line">  <span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint32_t c = _dyld_image_count();</span><br><span class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数传递了一个<code>rebinding</code>结构体数组，以及数组的个数，在 <code>rebind_symbols</code> 函数中，首先调用了 <code>prepend_rebindings</code> 函数，传入了 <code>_rebindings_head</code>， <code>rebindings</code> 数组，以及数组个数 . 如果<code>retval</code>小于0，则直接返回<code>retval </code>，如果<code>retval</code>大于0，并且<code>_rebindings_head-&gt;next </code>为空，则直接调用<code>_dyld_register_func_for_add_image </code> 注册回调函数<code>_rebind_symbols_for_image </code>, 如果<code>_rebindings_head-&gt;next </code>不为空，则直接执行回调函数</p><p><code>dyld</code> 加载镜像（image ，在 Mach-O 中，所有的可执行文件、dylib、Bundle 都是 image）时，会为增加的镜像注册回调函数并执行（包括已经存在的镜像）。传入镜像的<code>mach_header</code> 和 <code>slide</code>，同时也会为所有已加载的 <code>image</code> 执行回调。</p><h2 id="prepend-rebindings"><a href="#prepend-rebindings" class="headerlink" title="prepend_rebindings"></a>prepend_rebindings</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> prepend_rebindings(<span class="keyword">struct</span> rebindings_entry **rebindings_head,</span><br><span class="line">                              <span class="keyword">struct</span> rebinding rebindings[],</span><br><span class="line">                              size_t nel) &#123;</span><br><span class="line">  <span class="keyword">struct</span> rebindings_entry *new_entry = (<span class="keyword">struct</span> rebindings_entry *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebindings_entry));</span><br><span class="line">  <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  new_entry-&gt;rebindings = (<span class="keyword">struct</span> rebinding *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebinding) * nel);</span><br><span class="line">  <span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    free(new_entry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  memcpy(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebinding) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rebindings_entry &#123;</span><br><span class="line">  <span class="keyword">struct</span> rebinding *rebindings;</span><br><span class="line">  size_t rebindings_nel;</span><br><span class="line">  <span class="keyword">struct</span> rebindings_entry *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> rebindings_entry *_rebindings_head;</span><br></pre></td></tr></table></figure><p>首先定义一个 <code>rebindings_entry</code> 类型的 <code>new_entry</code> 结构体，并初始化，给 <code>new_entry</code> 以及 <code>new_entry-&gt;rebindings</code> 分配内存。 然后通过<code>memcpy </code>函数拷贝传入的 <code>rebindings</code>数组 到 <code>new_entry-&gt;rebindings</code> 中 , 同时给 <code>new_entry-&gt;rebindings_nel</code> 赋值数组的个数，将 <code>new_entry-&gt;next</code> 赋值<code>_rebindings_head 内的值</code> ,最后再使 <code>_rebindings_head</code> 与 <code>new_entry</code> 指向同一个地址 , 也就是将<code>new_entry </code>添加到 <code>_rebings_head</code> 这个链表的头部</p><h2 id="rebind-symbols-for-image"><a href="#rebind-symbols-for-image" class="headerlink" title="rebind _symbols _for _image"></a>rebind _symbols _for _image</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header *header,</span><br><span class="line">                                      intptr_t slide) &#123;</span><br><span class="line">    rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>_rebind_symbols_for_image </code> 函数中仅仅是调了<code>rebind_symbols_for_image </code></p><p>而<code>rebind_symbols_for_image </code>才是核心函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> rebind_symbols_for_image(<span class="keyword">struct</span> rebindings_entry *rebindings,</span><br><span class="line">                                     <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *header,</span><br><span class="line">                                     intptr_t slide) &#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  segment_command_t *cur_seg_cmd;                 <span class="comment">// segment_command_64</span></span><br><span class="line">  segment_command_t *linkedit_segment = <span class="literal">NULL</span>;     <span class="comment">//segment_command_64</span></span><br><span class="line">  <span class="keyword">struct</span> symtab_command* symtab_cmd = <span class="literal">NULL</span>;       <span class="comment">// LC_SYMTAB</span></span><br><span class="line">  <span class="keyword">struct</span> dysymtab_command* dysymtab_cmd = <span class="literal">NULL</span>;   <span class="comment">// LC_DYSYMTAB</span></span><br><span class="line"></span><br><span class="line">  uintptr_t cur = (uintptr_t)header + <span class="keyword">sizeof</span>(mach_header_t);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//遍历寻找__LINKEDIT</span></span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">      <span class="comment">//遍历寻找lc_symtab</span></span><br><span class="line">      symtab_cmd = (<span class="keyword">struct</span> symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">     <span class="comment">//遍历寻找lc_dysymtab</span></span><br><span class="line">      dysymtab_cmd = (<span class="keyword">struct</span> dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">================================Import=======================================</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find base symbol/string table addresses</span></span><br><span class="line">  uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="type">char</span> *strtab = (<span class="type">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">=============================================================================</span><br><span class="line"></span><br><span class="line">  cur = (uintptr_t)header + <span class="keyword">sizeof</span>(mach_header_t);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        section_t *sect =</span><br><span class="line">          (section_t *)(cur + <span class="keyword">sizeof</span>(segment_command_t)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">        <span class="comment">// sect为Section，symtab为符号表，strtab字符串表，indirect_symtab动态符号表（indirect symbol table）</span></span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数主要是在寻找<code>__LINKEDIT</code>、<code>LC_DYSYMTAB</code>、<code>LC_SYMTAB</code>的信息, 并计算符号表的地址</p><p><code>__LINKEDIT段</code>: 含有为动态链接库使用的原始数据，比如符号，字符串，重定位表条目等等</p><p><code>ASLR</code>：<code>Address space layout randomization</code>，将可执行程序随机加载载到内存中,这里的随机只是偏移，而不是打乱，就是通过内核将<code>Mach-O</code>的段偏移某个随机（slide）系数. 也就是说程序的基址等于__LINKEDIT的地址减去偏移量，然后再加上ASLR造成的偏移</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链接时程序的基址 = slider(ASLR偏移) + __LINKEDIT内存地址 - __LINKEDIT文件偏移</span></span><br><span class="line">uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符号表的地址 = 基址 + 符号表偏移量</span></span><br><span class="line">nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串表的地址 = 基址 + 字符串表偏移量</span></span><br><span class="line"><span class="type">char</span> *strtab = (<span class="type">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态符号表地址 = 基址 + 动态符号表偏移量</span></span><br><span class="line">uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br></pre></td></tr></table></figure><p>之后然后再次遍<code>loadcommands</code>，查找整个镜像中的 <code>SECTION_TYPE</code> 为 <code>S_LAZY_SYMBOL_POINTERS</code> 或者 <code>S_NON_LAZY_SYMBOL_POINTERS</code> 的 <code>section</code>，并调用<code>perform_rebinding_with_section </code>对<code>__nl_symbol_ptr</code>以及<code>__la_symbol_ptr</code>进行<code>rebind</code></p><h2 id="perform-rebinding-with-section"><a href="#perform-rebinding-with-section" class="headerlink" title="perform _rebinding _with _section"></a>perform _rebinding _with _section</h2><p>接下来还有一个很重要的函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> perform_rebinding_with_section(<span class="keyword">struct</span> rebindings_entry *rebindings,</span><br><span class="line">                                           section_t *section,</span><br><span class="line">                                           intptr_t slide,</span><br><span class="line">                                           nlist_t *symtab,</span><br><span class="line">                                           <span class="type">char</span> *strtab,</span><br><span class="line">                                           uint32_t *indirect_symtab) &#123;</span><br><span class="line">                                           </span><br><span class="line">    <span class="comment">// `nl_symbol_ptr`和`la_symbol_ptr`section中的`reserved1`字段指明对应的`indirect symbol table`起始的index</span></span><br><span class="line">    <span class="comment">// 动态符号表中第一个解析的符号的起始地址</span></span><br><span class="line">  uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">  <span class="type">void</span> **indirect_symbol_bindings = (<span class="type">void</span> **)((uintptr_t)slide + section-&gt;addr);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="type">void</span> *); i++) &#123;</span><br><span class="line">    uint32_t symtab_index = indirect_symbol_indices[i];</span><br><span class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">    <span class="type">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">    <span class="keyword">if</span> (strnlen(symbol_name, <span class="number">2</span>) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> rebindings_entry *cur = rebindings;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strcmp(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">          &#125;</span><br><span class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">          <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过 <code>indirect_symtab</code> + <code>section-&gt;reserved1</code> 获取 <code>indirect_symbol_indices</code>，也就是符号表的数组</p></li><li><p>通过 <code>(void **)((uintptr_t)slide + section-&gt;addr)</code> 获取函数指针列表 <code>indirect_symbol_bindings</code></p></li><li><p>遍历符号表数组 <code>indirect_symbol_indices</code> 中的所有符号表中，获取其中的符号表索引 <code>symtab_index</code></p></li><li><p>通过符号表索引 <code>symtab_index</code> 获取符号表中某一个 <code>n_list</code> 结构体，得到字符串表中的索引 <code>symtab[symtab _index].n_un.n_strx</code></p></li><li><p>最后在字符串表中获得符号的名字 <code>char *symbol_name</code></p></li></ul><p>最后就是将符号表中的 <code>symbol_name</code> 与 <code>rebinding</code> 中的名字 <code>name</code> 进行比较，如果匹配，进行实现替换，达到函数替换的目的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序运行时，动态链接的 <code>C</code> 函数地址会记录在<code>__DATA segment</code> 的<code>la_symbol_ptr</code>中；初始时，程序只知道函数的符号名而不知道函数的实现地址；首次调用时，程序通过<code>__TEXT segment</code>中的<code>stub_helper</code>取得绑定信息，通过<code>dyld_stub_binder</code>来更新<code>la_symbol_ptr</code>中的符号实现地址；这样，再次调用时，就可以通过<code>la_symbol_ptr</code>直接找到函数的实现；如果要实现函数的替换，只需要修改<code>__la_symbol_ptr</code>中的符号实现地址.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在iOS中，如果我们需要替换一个函数的实现，我们会想到通过&lt;code&gt;Method Swizzle&lt;/code&gt;来实现，其实也就是通过&lt;code&gt;runtime&lt;/code&gt;提供的API在运行时将函数的实现给替换了，正是因为&lt;code&gt;Objective-C&lt;/code&gt;是动态语言,所以我们可以通过&lt;code&gt;runtime&lt;/code&gt;做各种事情。。。但是如果是静态语言（C），我们是否也可以将函数&lt;code&gt;hook&lt;/code&gt;住呢？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Objective-C" scheme="http://aeronxie.github.io/tags/Objective-C/"/>
    
    <category term="C++" scheme="http://aeronxie.github.io/tags/C/"/>
    
    <category term="Mach-O" scheme="http://aeronxie.github.io/tags/Mach-O/"/>
    
  </entry>
  
  <entry>
    <title>Mach-O与有趣的dyld</title>
    <link href="http://aeronxie.github.io/post/dd841de.html"/>
    <id>http://aeronxie.github.io/post/dd841de.html</id>
    <published>2017-09-11T06:49:01.000Z</published>
    <updated>2023-03-25T14:39:55.770Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在程序启动的时候,我们总是认为程序的入口是从main函数开始的,但是在此之前, <code>dyld</code>已经干了很多事情了, 那什么是<code>dyld</code>呢? 它能够干什么, 它又有什么作用呢? 接下来, 就来研究下这个神奇的东西…</p></blockquote><span id="more"></span><h2 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h2><p>我们先来看下<code>Mach-O</code>, 在OS X 与 iOS 系统上的可执行文件格式是<code>Mach-O</code>, 我们编译过程产生的.O文件,以及程序的可执行文件, 动态库等都是<code>Mach-O</code>文件. 我们来看看下<code>Mach-O</code>结构:</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/852671-9fde036a1ce9d902.jpg"></p><p><strong>Mach-o包含三个基本区域:</strong></p><ul><li>头部（header structure）保存了一些基本信息，包括了该文件运行的平台、文件类型、LoadCommands的个数等.</li><li>加载命令（load commands） 在加载Mach-O文件时会使用这里的数据来确定内存的分布以及相关的加载命令, 如main函数的加载地址, 程序所需的dyld的文件路径, 以及相关依赖库的文件路径</li><li>Data（数据） 包含多个段（segment），每个段可以拥有零个或多个区域（section）每一个段（segment）都拥有一段虚拟地址映射到进程的地址空间</li></ul><p>我们可以从<code>loader.h</code>里面找到header的结构:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mach_header_64 &#123;</span><br><span class="line">uint32_tmagic;<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">cpu_type_tcputype;<span class="comment">/* cpu specifier */</span></span><br><span class="line">cpu_subtype_tcpusubtype;<span class="comment">/* machine specifier */</span></span><br><span class="line">uint32_tfiletype;<span class="comment">/* type of file */</span></span><br><span class="line">uint32_tncmds;<span class="comment">/* number of load commands */</span></span><br><span class="line">uint32_tsizeofcmds;<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">uint32_tflags;<span class="comment">/* flags */</span></span><br><span class="line">uint32_treserved;<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>magic:</code> 魔数,用于确认该文件是用64位还是32位</p><p><code>cputype:</code> CPU类型</p><p><code>cpusubtype:</code>机器类型</p><p><code>filetype:</code>文件类型</p><p><code>ncmds:</code> 加载的指令条数</p><p><code>sizeofcmds:</code> 所有加载的指令大小</p><p><code>flags:</code> 标志位</p><p><code>reserved:</code> 保留字段 （32位无此字段）</p><p>接下来我们在来看下<code>load_command:</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> load_command &#123;</span><br><span class="line">uint32_t cmd;<span class="comment">/* type of load command */</span></span><br><span class="line">uint32_t cmdsize;<span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个很好理解, <code>cmd</code> 是加载指令的类型, <code>cmdsize</code> 是指令的总大小</p><p>64位下在<code>segment_command</code>结构:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> segment_command_64 &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">uint32_tcmd;<span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">uint32_tcmdsize;<span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line"><span class="type">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment name */</span></span><br><span class="line">uint64_tvmaddr;<span class="comment">/* memory address of this segment */</span></span><br><span class="line">uint64_tvmsize;<span class="comment">/* memory size of this segment */</span></span><br><span class="line">uint64_tfileoff;<span class="comment">/* file offset of this segment */</span></span><br><span class="line">uint64_tfilesize;<span class="comment">/* amount to map from the file */</span></span><br><span class="line">vm_prot_tmaxprot;<span class="comment">/* maximum VM protection */</span></span><br><span class="line">vm_prot_tinitprot;<span class="comment">/* initial VM protection */</span></span><br><span class="line">uint32_tnsects;<span class="comment">/* number of sections in segment */</span></span><br><span class="line">uint32_tflags;<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>cmd:</code> 就是加载指令的类型, <code>#define    LC_SEGMENT_64    0x19    /* 64-bit segment of this file to be mapped */</code> 这里<code>LC_SEGMENT_64</code>意思是将文件中64位的段映射到进程的地址空间</p><p><code>vmaddr:</code> 段虚拟内存的地址</p><p><code>vmsize: </code> 虚拟内存大小</p><p><code>fileoff:</code> 段在文件中的偏移</p><p><code>filesize:</code> 文件大小</p><p><code>nsects:</code> 该段里有多少个section</p><p>64位下的<code>section</code>结构:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> section_64 &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line"><span class="type">char</span>sectname[<span class="number">16</span>];<span class="comment">/* name of this section */</span></span><br><span class="line"><span class="type">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment this section goes in */</span></span><br><span class="line">uint64_taddr;<span class="comment">/* memory address of this section */</span></span><br><span class="line">uint64_tsize;<span class="comment">/* size in bytes of this section */</span></span><br><span class="line">uint32_toffset;<span class="comment">/* file offset of this section */</span></span><br><span class="line">uint32_talign;<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">uint32_treloff;<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">uint32_tnreloc;<span class="comment">/* number of relocation entries */</span></span><br><span class="line">uint32_tflags;<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">uint32_treserved1;<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">uint32_treserved2;<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">uint32_treserved3;<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sectname:</code> section的名称</p><p><code>segname:</code> 该section所属的segment</p><p><code>addr:</code> 该section的内存地址</p><p><code>size:</code> 该section的大小</p><p><code>offset:</code> 该section的文件偏移</p><p><code>align:</code> 该section的内存对齐</p><p><code>reloff:</code> 重定位入口的文件偏移</p><p><code>nreloc:</code> 需要重定位的数量</p><p><code>flags:</code> 标志位 （section类型和属性）</p><p><code>reserved1 </code> 保留字段（偏移和索引）</p><p><code>reserved2:</code> 保留字段 （数量和大小）</p><p><code>reserved3:</code> 保留字段</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SECT_TEXT<span class="string">&quot;__text&quot;</span><span class="comment">/* the real text part of the text */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SECT_DATA<span class="string">&quot;__data&quot;</span><span class="comment">/* the real initialized data section */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SECT_BSS<span class="string">&quot;__bss&quot;</span><span class="comment">/* the real uninitialized data section*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SEG_OBJC<span class="string">&quot;__OBJC&quot;</span><span class="comment">/* objective-C runtime segment */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECT_OBJC_SYMBOLS <span class="string">&quot;__symbol_table&quot;</span>  <span class="comment">/* symbol table */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECT_OBJC_STRINGS <span class="string">&quot;__selector_strs&quot;</span>  <span class="comment">/* string table */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SEG_ICON <span class="string">&quot;__ICON&quot;</span><span class="comment">/* the icon segment */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在头文件中, 我们还找到了一些用于存放不同类型数据的段:</p><p><code>&quot;__text&quot;:</code> 源代码编译后的机器指令就放在这个段中, 也称为代码段<br><code>&quot;__data&quot;:</code> 初始化全局变量和静态变量就放在这个段<br><code>&quot;__bss&quot;:</code>  未初始化的全局变量和静态变量放在这个段<br><code>&quot;__OBJC&quot;:</code> runtime 段<br><code>&quot;__symbol_table&quot;:</code> 符号表<br><code>&quot;__selector_strs&quot;:</code> 方法名字符串表<br><code>&quot;__ICON&quot;:</code> 图标段</p><h2 id="什么是dyld"><a href="#什么是dyld" class="headerlink" title="什么是dyld"></a>什么是dyld</h2><p><code>The dynamic loader for Darwin/OS X is called dyld, and it is responsible for loading all frameworks, dynamic libraries, and bundles (plug-ins) needed by a process.</code> 苹果文档是这么解释的, 就是动态加载器, 它负责加载程序所需要的所有的<code>frameworks</code>, 动态库以及插件. <a href="https://developer.apple.com/library/content/releasenotes/DeveloperTools/RN-dyld/">更多详情</a></p><p>由于<a href="https://opensource.apple.com/tarballs/dyld/">dyld</a>是开源的, 所以我们可以下载源码,探其究竟. 这里我用的是<code>    dyld-97.1.tar.gz</code> </p><p>我们都知道iOS的系统frameworks都是动态链接的,系统内核做好启动程序的初始准备后, 就会将控制权交给 <code>dyld</code> 负责剩下的工作, (<code>dyld</code>是运行在<code>用户态</code>的， 这里由<code>内核态</code>切到了<code>用户态</code>）</p><p><em><strong>系统使用动态链接好处:</strong></em></p><ul><li>代码共用：多个程序都动态链接了相同的<code>lib</code>, 但它们在内存和磁盘中中只有一份</li><li>易于维护：由于被依赖的 <code>lib</code> 是程序执行时才链接的, 所以更新这些 <code>lib</code> 很方便</li><li>减少可执行文件体积：相比静态链接, 动态链接在编译时不需要打包进去, 所以可执行文件的体积要小很多</li></ul><h2 id="dyld接手"><a href="#dyld接手" class="headerlink" title="dyld接手"></a>dyld接手</h2><p>当dyld接手后, 它干了什么？</p><p>我们看到了这样一段注释</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line"><span class="comment">// sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br></pre></td></tr></table></figure><p><code>uintptr_t  _main(const struct mach_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[]) </code><br>意思是说这个是<code>dyld</code>入口点, 内核加载<code>dyld</code>并跳去执行<code>__dyld_start(复杂初始化一些寄存器然后执行_main函数)</code>最后返回<code>main()</code>函数的地址</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t _main(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header* mainExecutableMH, uintptr_t mainExecutableSlide, <span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span>* argv[], <span class="keyword">const</span> <span class="type">char</span>* envp[], <span class="keyword">const</span> <span class="type">char</span>* apple[]) &#123;</span><br><span class="line">setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line">sExecPath = apple[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">sMainExecutable-&gt;setNeverUnload();</span><br><span class="line">gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line"><span class="comment">// load shared cache</span></span><br><span class="line">checkSharedRegionDisable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="keyword">if</span>( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="type">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">loadInsertedDylib(*lib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">sInsertedDylibCount = sAllImages.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// link main executable</span></span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line">link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">gLinkContext.bindFlat = <span class="literal">true</span>;</span><br><span class="line">gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">&#125;</span><br><span class="line">result = (uintptr_t)sMainExecutable-&gt;getMain();</span><br><span class="line"></span><br><span class="line"><span class="comment">// link any inserted libraries</span></span><br><span class="line"><span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line"><span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">link(image, sEnv.DYLD_BIND_AT_LAUNCH, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">initializeMainExecutable(); <span class="comment">// run all initializers</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要负责主要负责初始化程序环境, 将可执行文件以及相应的依赖库与插入库加载进内存生成对应的<code>ImageLoader</code>类的<code>image(镜像文件)</code>对象，对这些image进行链接，调用各image的初始化方法等(注:这里多数事情都是递归的，从底向上的方法调用)，其中<code>runtime</code>也是在这个过程中被初始化</p><p>这里对<code>ImageLoader</code>的解释是:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageLoader is an abstract base class.  To support loading a particular executable</span></span><br><span class="line"><span class="comment">// file format, you make a concrete subclass of ImageLoader.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For each executable file (dynamic shared object) in use, an ImageLoader is instantiated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The ImageLoader base class does the work of linking together images, but it knows nothing</span></span><br><span class="line"><span class="comment">// about any particular file format.</span></span><br></pre></td></tr></table></figure><p>对上面生成的<code>Image</code>进行进行链接, 其主要做的事有对<code>image</code>进行<code>load(加载)</code>,<code>rebase(基地址复位)</code>，<code>bind(外部符号绑定)</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> ImageLoader::link(<span class="keyword">const</span> LinkContext&amp; context, <span class="type">bool</span> forceLazysBound, <span class="type">bool</span> preflightOnly, <span class="keyword">const</span> RPathChain&amp; loaderRPaths)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 递归加载所有依赖库进内存</span></span><br><span class="line"><span class="variable language_">this</span>-&gt;recursiveLoadLibraries(context,loaderRPaths);<span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 递归对自己以及依赖库进行复基址复位</span></span><br><span class="line"> <span class="variable language_">this</span>-&gt;recursiveRebase(context);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 对库中所有nolazy的符号进行bind, 一般的情况下多数符号都是lazy-bind的, 他们只有在第一次使用的时候才进行bind</span></span><br><span class="line"> <span class="variable language_">this</span>-&gt;recursiveBind(context, forceLazysBound);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后执行<code>initializeMainExecutable ()</code>, 调用所有<code>image</code>的<code>Initalizer</code>方法进行初始化</p><p>由于 <code>runtime</code> 向 <code>dyld</code> 绑定了回调，当 <code>image</code> 加载到内存后, <code>dyld</code> 会通知 <code>runtime</code> . <code>runtime</code>的初始化方法是<code>_objc_init</code>, 我们可以在程序中打一个符号断点, 这个断点会先与<code>main()</code>函数断点断下, 说明这些方法都是在main函数之前执行</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/14DD71F0-A1C3-4672-B4FE-166B3FA95F6E.png"></p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/923493B7-123E-4743-8A77-0B9587E3D03A.png"></p><p>从调用栈我们可以看到<code>dyld</code>递归调用<code>ImageLoader</code>初始化方法之后, 就会调用<code>libSystem_initializer</code>, 之后调用<code>libdipatch_init</code>, 最后才会走到<code>_objc_init</code>也就是<code>runtime</code>的初始化方法, <code>runtime</code>的初始化之后, 接下来 <code>load_images</code> 中调用 <code>call_load_methods</code> 方法，遍历所有加载进来的 Class, 调用 类的<code>load</code>方法, 并初始化相应依赖库里的类结构.</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/67EBFA2E-E882-4353-8257-2A5615DB392D.png"></p><p>到这里, 我们依然还是在<code>main()</code>函数之前, 当所有依赖库的<code>Initializer</code>都调用完后, <code>dyld::_main()</code>函数会返回程序的<code>main</code>函数地址, 然后<code>main</code>函数被调用.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>系统先读取程序的可执行文件(Mach-O), 从里面获得<code>dyld</code>的路径，然后加载<code>dyld</code>，<code>dyld</code>调用<code>_main(const struct mach_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[])</code>去初始化运行环境，开启缓存策略，加载程序相关依赖库(其中也包含我们的可执行文件)，并对这些库进行链接，最后递归调用每个依赖库的初始化方法，在这一步，<code>runtime</code>被初始化, 当所有依赖库的初始化后，轮到最后一位(程序可执行文件)进行初始化，在这时<code>runtime</code>会对项目中所有类进行类结构初始化，然后调用所有类的<code>load</code>方法, 最后<code>dyld::_main()</code>返回<code>main</code>函数地址，最终main函数被调用, 之后便来到了熟悉的程序入口.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在程序启动的时候,我们总是认为程序的入口是从main函数开始的,但是在此之前, &lt;code&gt;dyld&lt;/code&gt;已经干了很多事情了, 那什么是&lt;code&gt;dyld&lt;/code&gt;呢? 它能够干什么, 它又有什么作用呢? 接下来, 就来研究下这个神奇的东西…&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Objective-C" scheme="http://aeronxie.github.io/tags/Objective-C/"/>
    
    <category term="Mach-O" scheme="http://aeronxie.github.io/tags/Mach-O/"/>
    
  </entry>
  
  <entry>
    <title>深入理解GCD</title>
    <link href="http://aeronxie.github.io/post/7563b745.html"/>
    <id>http://aeronxie.github.io/post/7563b745.html</id>
    <published>2017-09-02T06:34:42.000Z</published>
    <updated>2023-03-25T14:39:55.625Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近看到了一些关于GCD的一些问题,看了下不是很清楚,发现这些问题还是很有意思的, 所以决定研究下<a href="https://opensource.apple.com/tarballs/libdispatch/">GCD的源码</a>,过程中还是找到了很多神奇的地方,作为学习的记录,于是写下了这个文章作为学习的笔记。。。<br>看的时候是最新的 <code>libdispatch-84.5.tar.gz</code> 的版本，这个版本跟之前版本不太一样，不过总体上没有太大的改变。。。</p></blockquote><span id="more"></span><h6 id="1-dispatch-async-函数如何实现，分发到主队列和全局队列有什么区别，一定会新建线程执行任务么？"><a href="#1-dispatch-async-函数如何实现，分发到主队列和全局队列有什么区别，一定会新建线程执行任务么？" class="headerlink" title="1. dispatch_async 函数如何实现，分发到主队列和全局队列有什么区别，一定会新建线程执行任务么？"></a>1. <code>dispatch_async</code> 函数如何实现，分发到主队列和全局队列有什么区别，一定会新建线程执行任务么？</h6><h6 id="2-dispatch-sync-函数如何实现，为什么说-GCD-死锁是队列导致的而不是线程，死锁不是操作系统的概念么？"><a href="#2-dispatch-sync-函数如何实现，为什么说-GCD-死锁是队列导致的而不是线程，死锁不是操作系统的概念么？" class="headerlink" title="2. dispatch_sync 函数如何实现，为什么说 GCD 死锁是队列导致的而不是线程，死锁不是操作系统的概念么？"></a>2. <code>dispatch_sync</code> 函数如何实现，为什么说 GCD 死锁是队列导致的而不是线程，死锁不是操作系统的概念么？</h6><h6 id="3-信号量是如何实现的，有哪些使用场景？"><a href="#3-信号量是如何实现的，有哪些使用场景？" class="headerlink" title="3. 信号量是如何实现的，有哪些使用场景？"></a>3. 信号量是如何实现的，有哪些使用场景？</h6><h6 id="4-dispatch-group-的等待与通知-dispatch-once-如何实现？"><a href="#4-dispatch-group-的等待与通知-dispatch-once-如何实现？" class="headerlink" title="4. dispatch_group 的等待与通知,dispatch_once 如何实现？"></a>4. <code>dispatch_group</code> 的等待与通知,<code>dispatch_once</code> 如何实现？</h6><h6 id="5-dispatch-source-用来做定时器如何实现，有什么优点和用途？"><a href="#5-dispatch-source-用来做定时器如何实现，有什么优点和用途？" class="headerlink" title="5. dispatch_source 用来做定时器如何实现，有什么优点和用途？"></a>5. <code>dispatch_source</code> 用来做定时器如何实现，有什么优点和用途？</h6><h6 id="6-dispatch-suspend-和-dispatch-resume-如何实现，队列的的暂停和计时器的暂停有区别么？"><a href="#6-dispatch-suspend-和-dispatch-resume-如何实现，队列的的暂停和计时器的暂停有区别么？" class="headerlink" title="6. dispatch_suspend 和 dispatch_resume 如何实现，队列的的暂停和计时器的暂停有区别么？"></a>6. <code>dispatch_suspend</code> 和 <code>dispatch_resume</code> 如何实现，队列的的暂停和计时器的暂停有区别么？</h6><h5 id="打开源码，我们能看到大概的结构，先来看下提供给我们的接口"><a href="#打开源码，我们能看到大概的结构，先来看下提供给我们的接口" class="headerlink" title="打开源码，我们能看到大概的结构，先来看下提供给我们的接口:"></a>打开源码，我们能看到大概的结构，先来看下提供给我们的接口:</h5><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/31AC72C3-2E11-4209-8E2B-312FE085BEAF.jpeg"></p><p>接下来，分析下开发常用到一些函数。</p><h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *val, <span class="type">void</span> (^block)(<span class="type">void</span>)) &#123;</span><br><span class="line"><span class="keyword">struct</span> Block_basic *bb = (<span class="type">void</span> *)block;</span><br><span class="line">dispatch_once_f(val, block, (<span class="type">void</span> *)bb-&gt;Block_invoke);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dispatch_once_f(<span class="built_in">dispatch_once_t</span> *val, <span class="type">void</span> *ctxt, <span class="type">void</span> (*func)(<span class="type">void</span> *)) &#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> *vval = val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatch_atomic_cmpxchg(val, <span class="number">0</span>l, <span class="number">1</span>l)) &#123;</span><br><span class="line">func(ctxt);</span><br><span class="line">dispatch_atomic_barrier();</span><br><span class="line">*val = ~<span class="number">0</span>l;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">_dispatch_hardware_pause();</span><br><span class="line">&#125; <span class="keyword">while</span> (*vval != ~<span class="number">0</span>l);</span><br><span class="line"></span><br><span class="line">dispatch_atomic_barrier();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="这个函数官方文档的是这样描述的-“Executes-a-block-object-once-and-only-once-for-the-lifetime-of-an-application-”-就是说在程序的生命周期内block只执行一次"><a href="#这个函数官方文档的是这样描述的-“Executes-a-block-object-once-and-only-once-for-the-lifetime-of-an-application-”-就是说在程序的生命周期内block只执行一次" class="headerlink" title="这个函数官方文档的是这样描述的, “Executes a block object once and only once for the lifetime of an application.” 就是说在程序的生命周期内block只执行一次."></a>这个函数官方文档的是这样描述的, “Executes a block object once and only once for the lifetime of an application.” 就是说在程序的生命周期内block只执行一次.</h5><h5 id="dispatch-once-函数内部调用了-dispatch-once-f-在dispatch-once-f中发现了几个奇怪的宏"><a href="#dispatch-once-函数内部调用了-dispatch-once-f-在dispatch-once-f中发现了几个奇怪的宏" class="headerlink" title="dispatch_once 函数内部调用了 dispatch_once_f, 在dispatch_once_f中发现了几个奇怪的宏."></a><code>dispatch_once</code> 函数内部调用了 <code>dispatch_once_f</code>, 在<code>dispatch_once_f</code>中发现了几个奇怪的宏.</h5><ul><li><code>dispatch_atomic_cmpxchg</code>: <code>#define dispatch_atomic_cmpxchg(p, o, n)    __sync_bool_compare_and_swap((p), (o), (n))</code> …what ?? <code>__sync_bool_compare_and_swap</code> 这是个什么玩意？？查了下发现这是一种原子操作的一种技术<a href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS</a>, CAS可以用于实现无锁数据结构, 这里就不展开了</li><li><code>dispatch_atomic_barrier </code>:  </li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__i386__) || defined(__x86_64__)</span></span><br><span class="line"><span class="comment">/* GCC emits nothing for __sync_synchronize() on i386/x86_64. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dispatch_atomic_barrier()__asm__ __volatile__(<span class="string">&quot;mfence&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dispatch_atomic_barrier()__sync_synchronize()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Please upgrade to GCC 4.2 or newer.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个宏定义在不同的系统架构上有不同的实现, 其实就是一种原子操作</p><ul><li><code>_dispatch_hardware_pause </code>: <code>#define _dispatch_hardware_pause() asm(&quot;pause&quot;)</code>, pause是一个<a href="http://blog.csdn.net/misterliwei/article/details/3951103">汇编指令</a></li></ul><h5 id="函数在执行的时候-传进来一个类型为dispatch-once-t-的参数，dispatch-once-t-这个类型其实就是long类型-val如果没有初始化则值为0-当走到if的时候-与0比较相等-dispatch-atomic-cmpxchg-返回了YES-就会执行func函数-其实就是外面传进来的block-并把-val-置成1-如果第二次再走这个函数-dispatch-atomic-cmpxchg-则会返回NO-就只会走else后面的语句-block就不会再执行了-所以这就能保证dispatch-once-函数只能执行一次的原因-其核心就是-sync-bool-compare-and-swap-p-o-n-。"><a href="#函数在执行的时候-传进来一个类型为dispatch-once-t-的参数，dispatch-once-t-这个类型其实就是long类型-val如果没有初始化则值为0-当走到if的时候-与0比较相等-dispatch-atomic-cmpxchg-返回了YES-就会执行func函数-其实就是外面传进来的block-并把-val-置成1-如果第二次再走这个函数-dispatch-atomic-cmpxchg-则会返回NO-就只会走else后面的语句-block就不会再执行了-所以这就能保证dispatch-once-函数只能执行一次的原因-其核心就是-sync-bool-compare-and-swap-p-o-n-。" class="headerlink" title="函数在执行的时候,传进来一个类型为dispatch_once_t 的参数，dispatch_once_t 这个类型其实就是long类型, * val如果没有初始化则值为0, 当走到if的时候, 与0比较相等,dispatch_atomic_cmpxchg 返回了YES, 就会执行func函数,其实就是外面传进来的block, 并把*val 置成1, 如果第二次再走这个函数, dispatch_atomic_cmpxchg 则会返回NO, 就只会走else后面的语句, block就不会再执行了, 所以这就能保证dispatch_once 函数只能执行一次的原因,其核心就是__sync_bool_compare_and_swap((p),(o),(n))。"></a>函数在执行的时候,传进来一个类型为<code>dispatch_once_t </code>的参数，<code>dispatch_once_t </code>这个类型其实就是<code>long</code>类型, * val如果没有初始化则值为0, 当走到if的时候, 与0比较相等,<code>dispatch_atomic_cmpxchg </code>返回了YES, 就会执行func函数,其实就是外面传进来的block, 并把*val 置成1, 如果第二次再走这个函数, <code>dispatch_atomic_cmpxchg </code>则会返回NO, 就只会走else后面的语句, block就不会再执行了, 所以这就能保证<code>dispatch_once </code>函数只能执行一次的原因,其核心就是<code>__sync_bool_compare_and_swap((p),(o),(n))</code>。</h5><h5 id="PS-平时我们在开发时-经常会用这个函数来写单例"><a href="#PS-平时我们在开发时-经常会用这个函数来写单例" class="headerlink" title="PS: 平时我们在开发时,经常会用这个函数来写单例,"></a>PS: 平时我们在开发时,经常会用这个函数来写单例,</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">id</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> Class *_sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们需要把这个单例释放,我们可以把<code>static Class *_sharedInstance = nil;</code>这一句放到函数外边, 外面直接将_sharedInstance置空即可,但是如果需要重新创建单例的话, 则还需要把<code>onceToken</code>置为0, 不置为0的话就不会走block了。</p><h2 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> dq, <span class="type">void</span> (^work)(<span class="type">void</span>)) &#123;</span><br><span class="line">dispatch_async_f(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> dispatch_async_f(<span class="built_in">dispatch_queue_t</span> dq, <span class="type">void</span> *ctxt, dispatch_function_t func) &#123;</span><br><span class="line">dispatch_continuation_t dc = fastpath(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlike dispatch_sync_f(), we do NOT need to check the queue width,</span></span><br><span class="line"><span class="comment">// the &quot;drain&quot; function will do this test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dc) &#123;</span><br><span class="line"><span class="keyword">return</span> _dispatch_async_f_slow(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dc-&gt;do_vtable = (<span class="type">void</span> *)DISPATCH_OBJ_ASYNC_BIT;</span><br><span class="line">dc-&gt;dc_func = func;</span><br><span class="line">dc-&gt;dc_ctxt = ctxt;</span><br><span class="line"></span><br><span class="line">_dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="“Submits-a-block-for-asynchronous-execution-on-a-dispatch-queue-and-returns-immediately-”-在一个队列提交一个异步执行的block-并立刻返回"><a href="#“Submits-a-block-for-asynchronous-execution-on-a-dispatch-queue-and-returns-immediately-”-在一个队列提交一个异步执行的block-并立刻返回" class="headerlink" title="“Submits a block for asynchronous execution on a dispatch queue and returns immediately.” 在一个队列提交一个异步执行的block,并立刻返回."></a>“Submits a block for asynchronous execution on a dispatch queue and returns immediately.” 在一个队列提交一个异步执行的block,并立刻返回.</h5><p><code>dispatch_async </code>内部执行了<code>dispatch_async_f </code>,把block转成了function执行~~在这里我们发现了 <code>fastpath </code>这个神奇的东西, 点进去这个宏。。发现是一个<code>__builtin_expect</code>函数,这个可以用来优化执行速度的</p><ul><li>fastpath表示条件更可能成立</li><li>slowpath表示条件更不可能成立</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define fastpath(x)((typeof(x))__builtin_expect((long)(x), ~0l))</span><br><span class="line">#define slowpath(x)((typeof(x))__builtin_expect((long)(x), 0l))</span><br></pre></td></tr></table></figure><p>先从<code>_dispatch_continuation_alloc_cacheonly</code>取出是否有cache的dc；若有dc存在，那么给dc赋值，然后push到dq中去；假设没有cache，那么进入到<code>_dispatch_async_f_slow </code>创建一个<code>dispatch_continuation</code>对象(从堆中获取)来存放function，然后push到队列后面, 我们先来看下 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> dispatch_continuation_t _dispatch_continuation_alloc_cacheonly(<span class="type">void</span>) &#123;</span><br><span class="line">dispatch_continuation_t dc = fastpath(_dispatch_thread_getspecific(dispatch_cache_key));</span><br><span class="line"><span class="keyword">if</span> (dc) &#123;</span><br><span class="line">_dispatch_thread_setspecific(dispatch_cache_key, dc-&gt;do_next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们用到了<a href="http://blog.csdn.net/ctthuangcheng/article/details/9357917">TSD(Thread-Specific Data)</a> 也就是线程私有数据。这里不展开。如果能取到dc, 则为它设置线程私有数据并返回. </p><p><code>dc-&gt;do_vtable = (void *)DISPATCH_OBJ_ASYNC_BIT</code> </p><p>GCD队列的异步就是通过<code>DISPATCH_OBJ_ASYNC_BIT </code>这个bit标识来实现的，全部的标识有如下几种:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_OBJ_ASYNC_BIT0x1  <span class="comment">// 异步</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_OBJ_BARRIER_BIT0x2  <span class="comment">// 阻塞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_OBJ_GROUP_BIT0x4  <span class="comment">// 组</span></span></span><br></pre></td></tr></table></figure><h2 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> dq, <span class="type">void</span> (^work)(<span class="type">void</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line"><span class="keyword">if</span> (slowpath(dq == &amp;_dispatch_main_q)) &#123;</span><br><span class="line"><span class="keyword">return</span> _dispatch_sync_slow(dq, work);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">struct</span> Block_basic *bb = (<span class="type">void</span> *)work;</span><br><span class="line">dispatch_sync_f(dq, work, (dispatch_function_t)bb-&gt;Block_invoke);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> dispatch_sync_f(<span class="built_in">dispatch_queue_t</span> dq, <span class="type">void</span> *ctxt, dispatch_function_t func) &#123;</span><br><span class="line"><span class="keyword">typeof</span>(dq-&gt;dq_running) prev_cnt;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> old_dq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dq-&gt;dq_width == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> dispatch_barrier_sync_f(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) ensure that this thread hasn&#x27;t enqueued anything ahead of this call</span></span><br><span class="line"><span class="comment">// 2) the queue is not suspended</span></span><br><span class="line"><span class="keyword">if</span> (slowpath(dq-&gt;dq_items_tail) || slowpath(DISPATCH_OBJECT_SUSPENDED(dq))) &#123;</span><br><span class="line">_dispatch_sync_f_slow(dq);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prev_cnt = dispatch_atomic_add(&amp;dq-&gt;dq_running, <span class="number">2</span>) - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slowpath(prev_cnt &amp; <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (dispatch_atomic_sub(&amp;dq-&gt;dq_running, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">_dispatch_wakeup(dq);</span><br><span class="line">&#125;</span><br><span class="line">_dispatch_sync_f_slow(dq);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">_dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line">func(ctxt);</span><br><span class="line">_dispatch_workitem_inc();</span><br><span class="line">_dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slowpath(dispatch_atomic_sub(&amp;dq-&gt;dq_running, <span class="number">2</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">_dispatch_wakeup(dq);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="“Submits-a-block-object-for-execution-on-a-dispatch-queue-and-waits-until-that-block-completes-”-这个函数是在一个队列提交一个执行的block-并需要等待block必须执行完之后函数才返回"><a href="#“Submits-a-block-object-for-execution-on-a-dispatch-queue-and-waits-until-that-block-completes-”-这个函数是在一个队列提交一个执行的block-并需要等待block必须执行完之后函数才返回" class="headerlink" title="“Submits a block object for execution on a dispatch queue and waits until that block completes.”  这个函数是在一个队列提交一个执行的block,并需要等待block必须执行完之后函数才返回."></a>“Submits a block object for execution on a dispatch queue and waits until that block completes.”  这个函数是在一个队列提交一个执行的block,并需要等待block必须执行完之后函数才返回.</h5><p>发现<code>dispatch_sync </code>无论走哪个分支，最后走的都是<code>dispatch_sync_f</code>,通过<code>_dispatch_Block_copy</code>或者<code>Block_basic</code>来实现block到function的转换.<br>如果是串行队列(dq_width==1)的话必须要等待前面的任务执行完成之后才能执行该任务,然后调用<code>dispatch_barrier_sync_f</code>,barrier的实现是依靠信号量机制来同步任务的执行.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dispatch_barrier_sync_f(<span class="built_in">dispatch_queue_t</span> dq, <span class="type">void</span> *ctxt,dispatch_function_t func) &#123;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) ensure that this thread hasn&#x27;t enqueued anything ahead of this call</span></span><br><span class="line"><span class="comment">// 2) the queue is not suspended</span></span><br><span class="line"><span class="comment">// 3) the queue is not weird</span></span><br><span class="line"><span class="keyword">if</span> (slowpath(dq-&gt;dq_items_tail)</span><br><span class="line">|| slowpath(DISPATCH_OBJECT_SUSPENDED(dq))</span><br><span class="line">|| slowpath(!_dispatch_queue_trylock(dq))) &#123;</span><br><span class="line"><span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line">func(ctxt);</span><br><span class="line">_dispatch_workitem_inc();</span><br><span class="line">_dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line">_dispatch_queue_unlock(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前是处于队列尾部,队列不为暂停状态,且使用_dispatch_queue_trylock检查队列则会执行<code>_dispatch_barrier_sync_f_slow</code>函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> _dispatch_barrier_sync_f_slow(<span class="built_in">dispatch_queue_t</span> dq, <span class="type">void</span> *ctxt, dispatch_function_t func) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// It&#x27;s preferred to execute synchronous blocks on the current thread</span></span><br><span class="line"><span class="comment">// due to thread-local side effects, garbage collection, etc. However,</span></span><br><span class="line"><span class="comment">// blocks submitted to the main thread MUST be run on the main thread</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dispatch_barrier_sync_slow2_s dbss2 = &#123;</span><br><span class="line">.dbss2_dq = dq,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">.dbss2_func = func,</span><br><span class="line">.dbss2_ctxt = ctxt,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.dbss2_sema = _dispatch_get_thread_semaphore(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> dispatch_barrier_sync_slow_s &#123;</span><br><span class="line">DISPATCH_CONTINUATION_HEADER(dispatch_barrier_sync_slow_s);</span><br><span class="line">&#125; dbss = &#123;</span><br><span class="line">.do_vtable = (<span class="type">void</span> *)DISPATCH_OBJ_BARRIER_BIT,</span><br><span class="line">.dc_func = _dispatch_barrier_sync_f_slow_invoke,</span><br><span class="line">.dc_ctxt = &amp;dbss2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">===============================Important=============================</span><br><span class="line">_dispatch_queue_push(dq, (<span class="type">void</span> *)&amp;dbss);</span><br><span class="line">dispatch_semaphore_wait(dbss2.dbss2_sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">_dispatch_put_thread_semaphore(dbss2.dbss2_sema);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line"><span class="comment">// Main queue bound to main thread</span></span><br><span class="line"><span class="keyword">if</span> (dbss2.dbss2_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">_dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line">func(ctxt);</span><br><span class="line">_dispatch_workitem_inc();</span><br><span class="line">_dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line">dispatch_resume(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数中，使用<code>_dispatch_queue_push</code>将我们的block压入<code>main queue</code>的FIFO队列中，然后等待信号量，ready后被唤醒. 假如我们调用的<code>dispatch_sync</code>函数一直不返回,而且<code>main queue</code>被阻塞，而我们的block又需要等待main queue来执行它, 就会出现死锁. 所以 GCD 死锁是队列导致的而不是线程.</p><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dispatch_after(dispatch_time_t when, <span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t work) &#123;</span><br><span class="line"><span class="comment">// test before the copy of the block</span></span><br><span class="line"><span class="keyword">if</span> (when == DISPATCH_TIME_FOREVER) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dispatch_after_f(when, queue, _dispatch_Block_copy(work), _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> dispatch_after_f(dispatch_time_t when, <span class="built_in">dispatch_queue_t</span> queue, <span class="type">void</span> *ctxt, <span class="type">void</span> (*func)(<span class="type">void</span> *)) &#123;</span><br><span class="line">uint64_t delta;</span><br><span class="line"><span class="keyword">if</span> (when == DISPATCH_TIME_FOREVER) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this function can and should be optimized to not use a dispatch source</span></span><br><span class="line">again:</span><br><span class="line">delta = _dispatch_timeout(when);</span><br><span class="line"><span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> dispatch_async_f(queue, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!dispatch_source_timer_create(DISPATCH_TIMER_INTERVAL, delta, <span class="number">0</span>, <span class="literal">NULL</span>, queue, ^(dispatch_source_t ds) &#123;</span><br><span class="line"><span class="type">long</span> err_dom, err_val;</span><br><span class="line"><span class="keyword">if</span> ((err_dom = dispatch_source_get_error(ds, &amp;err_val))) &#123;</span><br><span class="line">dispatch_assert(err_dom == DISPATCH_ERROR_DOMAIN_POSIX);</span><br><span class="line">dispatch_assert(err_val == ECANCELED);</span><br><span class="line">func(ctxt);</span><br><span class="line">dispatch_release(ds);<span class="comment">// MUST NOT be _dispatch_release()</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dispatch_source_cancel(ds);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)) &#123;</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="“Enqueue-a-block-for-execution-at-the-specified-time-”-延时提交用于执行的block"><a href="#“Enqueue-a-block-for-execution-at-the-specified-time-”-延时提交用于执行的block" class="headerlink" title="“Enqueue a block for execution at the specified time.” 延时提交用于执行的block."></a>“Enqueue a block for execution at the specified time.” 延时提交用于执行的block.</h5><p>同上内部会走<code>dispatch_after_f </code>这个函数,实现将block跟function之间的转换, 如果外面传进来的时间为<code>DISPATCH_TIME_FOREVER </code>,则直接返回, <code>when</code>为0, 则执行<code>dispatch_async_f </code>,内部是依赖<code>dispatch_source</code>定时器来实现延迟执行, 如果没有使用到<code>dispatch source</code>, function则会被优化。</p><h2 id="dispatch-get-global-queue"><a href="#dispatch-get-global-queue" class="headerlink" title="dispatch_ get_ global_queue"></a>dispatch_ get_ global_queue</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_get_global_queue(<span class="type">long</span> priority, <span class="type">unsigned</span> <span class="type">long</span> flags) &#123;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _dispatch_get_root_queue(priority, flags &amp; DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="type">long</span> priority, <span class="type">bool</span> overcommit) &#123;</span><br><span class="line"><span class="keyword">if</span> (overcommit) <span class="keyword">switch</span> (priority) &#123;</span><br><span class="line"><span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line"><span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line"><span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line"><span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (priority) &#123;</span><br><span class="line"><span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line"><span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line"><span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line"><span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="“Returns-a-system-defined-global-concurrent-queue-with-the-specified-quality-of-service-class-”-返回一个系统定义的全局并发队列-并可以指定执行的服务质量"><a href="#“Returns-a-system-defined-global-concurrent-queue-with-the-specified-quality-of-service-class-”-返回一个系统定义的全局并发队列-并可以指定执行的服务质量" class="headerlink" title="“Returns a system-defined global concurrent queue with the specified quality of service class.”  返回一个系统定义的全局并发队列, 并可以指定执行的服务质量"></a>“Returns a system-defined global concurrent queue with the specified quality of service class.”  返回一个系统定义的全局并发队列, 并可以指定执行的服务质量</h5><p>我们会看到有个<code>DISPATCH_QUEUE_OVERCOMMIT </code>这么个玩意。。点进去看。发现官方是这么描述的, 首先它是一个枚举, 系统会开启一个新的线程去执行block, 无论此时计算机有多忙~ <code>OVERCOMMIT</code>用来控制线程数能不能超越物理内核数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @enum dispatch_queue_flags_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @constant DISPATCH_QUEUE_OVERCOMMIT</span></span><br><span class="line"><span class="comment"> * The queue will create a new thread for invoking blocks, regardless of how</span></span><br><span class="line"><span class="comment"> * busy the computer is.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">DISPATCH_QUEUE_OVERCOMMIT = <span class="number">0x2</span>ull,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过此方法<code>_dispatch_get_root_queue</code>获取对应的一个全局队列。有这三种优先级以及是否是OVERCOMMIT</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_HIGH = <span class="number">2</span>,</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT = <span class="number">0</span>,</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_LOW = <span class="number">-2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们来看一个图, 图中描述了线程和队列的关系<br><img src="http://7xoijj.com1.z0.glb.clouddn.com/gcd-pool.png"></p><p>每一个<code>_dispatch_root_queue</code>包含一个线程池<code>_dispatch_root_queue_context</code><br>4-9是全局队列,1是主队列,2是一个管理队列,用来管理 GCD内部任务, 3暂时没使用. 队列 的 <code>dq_width</code> 被设置为 UINT32_MAX，表示这些队列不限制并发数.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> dispatch_queue_s _dispatch_root_queues[] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">.do_ctxt = &amp;_dispatch_root_queue_contexts[<span class="number">0</span>],</span><br><span class="line"></span><br><span class="line">.dq_label = <span class="string">&quot;com.apple.root.low-priority&quot;</span>,</span><br><span class="line">.dq_running = <span class="number">2</span>,</span><br><span class="line">.dq_width = <span class="built_in">UINT32_MAX</span>,</span><br><span class="line">.dq_serialnum = <span class="number">4</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">.do_ctxt = &amp;_dispatch_root_queue_contexts[<span class="number">1</span>],</span><br><span class="line"></span><br><span class="line">.dq_label = <span class="string">&quot;com.apple.root.low-overcommit-priority&quot;</span>,</span><br><span class="line">.dq_running = <span class="number">2</span>,</span><br><span class="line">.dq_width = <span class="built_in">UINT32_MAX</span>,</span><br><span class="line">.dq_serialnum = <span class="number">5</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">.do_ctxt = &amp;_dispatch_root_queue_contexts[<span class="number">2</span>],</span><br><span class="line"></span><br><span class="line">.dq_label = <span class="string">&quot;com.apple.root.default-priority&quot;</span>,</span><br><span class="line">.dq_running = <span class="number">2</span>,</span><br><span class="line">.dq_width = <span class="built_in">UINT32_MAX</span>,</span><br><span class="line">.dq_serialnum = <span class="number">6</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">.do_ctxt = &amp;_dispatch_root_queue_contexts[<span class="number">3</span>],</span><br><span class="line"></span><br><span class="line">.dq_label = <span class="string">&quot;com.apple.root.default-overcommit-priority&quot;</span>,</span><br><span class="line">.dq_running = <span class="number">2</span>,</span><br><span class="line">.dq_width = <span class="built_in">UINT32_MAX</span>,</span><br><span class="line">.dq_serialnum = <span class="number">7</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">.do_ctxt = &amp;_dispatch_root_queue_contexts[<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">.dq_label = <span class="string">&quot;com.apple.root.high-priority&quot;</span>,</span><br><span class="line">.dq_running = <span class="number">2</span>,</span><br><span class="line">.dq_width = <span class="built_in">UINT32_MAX</span>,</span><br><span class="line">.dq_serialnum = <span class="number">8</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">.do_ctxt = &amp;_dispatch_root_queue_contexts[<span class="number">5</span>],</span><br><span class="line"></span><br><span class="line">.dq_label = <span class="string">&quot;com.apple.root.high-overcommit-priority&quot;</span>,</span><br><span class="line">.dq_running = <span class="number">2</span>,</span><br><span class="line">.dq_width = <span class="built_in">UINT32_MAX</span>,</span><br><span class="line">.dq_serialnum = <span class="number">9</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_THREAD_COUNT 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dispatch_root_queue_context_s &#123;</span><br><span class="line">pthread_workqueue_t dgq_kworkqueue;</span><br><span class="line">uint32_t dgq_pending;</span><br><span class="line">uint32_t dgq_thread_pool_size;</span><br><span class="line">dispatch_semaphore_t dgq_thread_mediator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_ROOT_QUEUE_COUNT (DISPATCH_QUEUE_PRIORITY_COUNT * 2)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> dispatch_root_queue_context_s _dispatch_root_queue_contexts[] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">.dgq_thread_mediator = &amp;_dispatch_thread_mediator[<span class="number">0</span>],</span><br><span class="line">.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.dgq_thread_mediator = &amp;_dispatch_thread_mediator[<span class="number">1</span>],</span><br><span class="line">.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.dgq_thread_mediator = &amp;_dispatch_thread_mediator[<span class="number">2</span>],</span><br><span class="line">.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.dgq_thread_mediator = &amp;_dispatch_thread_mediator[<span class="number">3</span>],</span><br><span class="line">.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.dgq_thread_mediator = &amp;_dispatch_thread_mediator[<span class="number">4</span>],</span><br><span class="line">.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.dgq_thread_mediator = &amp;_dispatch_thread_mediator[<span class="number">5</span>],</span><br><span class="line">.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>dispatch_root_queue_context_s </code>这个结构体就是队列对应的线程实现, 一个context就是一个线程池, 最大线程数为255</p><h2 id="dispatch-get-current-queue"><a href="#dispatch-get-current-queue" class="headerlink" title="dispatch_ get_current _queue"></a>dispatch_ get_current _queue</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_get_current_queue(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> _dispatch_queue_get_current() ?: _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">dispatch_queue_t</span> _dispatch_queue_get_current(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们获取当前运行队列的时候是通过TSD(Thread-Specific-Data)来获取的, 如果没有当前队列, 则会通过<code>_dispatch_get_root_queue </code>这个方法获取取一个优先级为<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>的队列</p><h2 id="dispatch-get-main-queue"><a href="#dispatch-get-main-queue" class="headerlink" title="dispatch _get _main _queue"></a>dispatch _get _main _queue</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_get_main_queue(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_dispatch_main_q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dispatch_queue_s _dispatch_main_q = &#123;</span><br><span class="line">.do_vtable = &amp;_dispatch_queue_vtable,</span><br><span class="line">.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">.do_targetq = &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_COUNT / <span class="number">2</span>],</span><br><span class="line"></span><br><span class="line">.dq_label = <span class="string">&quot;com.apple.main-thread&quot;</span>,</span><br><span class="line">.dq_running = <span class="number">1</span>,</span><br><span class="line">.dq_width = <span class="number">1</span>,</span><br><span class="line">.dq_serialnum = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>获取主队列, <code>dq_width</code> 等于1表示是一个串行队列, 支持overcommit, 且优先级为Default</p><h3 id="讲了这么多GCD的源码-现在来说一下会常用到的API"><a href="#讲了这么多GCD的源码-现在来说一下会常用到的API" class="headerlink" title="讲了这么多GCD的源码, 现在来说一下会常用到的API:"></a>讲了这么多GCD的源码, 现在来说一下会常用到的API:</h3><h2 id="dispatch-source"><a href="#dispatch-source" class="headerlink" title="dispatch_source"></a>dispatch_source</h2><p> 我们常用来实现定时器, 但是它跟<code>NSTimer</code>有什么区别呢？<br> 首相<code>NSTimer</code>依赖于runloop, 由于runloop需要处理很多任务，导致NSTimer的精度降低. 如果忘了停止, 还会造成循环引用. <code>dispatch_source_t</code>是由系统触发,所以精度很高, 下面是通过<code>dispatch_source_t</code> 创建一个计时器.</p><p>我们可以通过<code>dispatch_source_t dispatch_source_create(dispatch_source_type_t type,uintptr_t handle,unsigned long mask,dispatch_queue_t _Nullable queue);</code> 创建一个timer, 第一个参数是设置源的类型, 第二个参数可以理解为句柄、索引或id,假如要监听进程，需要传入进程的ID, 第三个参数可以理解为描述, 提供更详细的描述, 让它知道具体要监听啥, 第四个参数就是一个队列, 用来处理所有的响应.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">  </span><br><span class="line">  dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, <span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>);        <span class="comment">//开始时间</span></span><br><span class="line"></span><br><span class="line">  uint64_t interval = <span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>;     <span class="comment">//间隔时间</span></span><br><span class="line"></span><br><span class="line">  dispatch_source_set_timer(_timer, start, interval, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  dispatch_source_set_event_handler(_timer, ^&#123;    <span class="comment">// 设置响应dispatch源事件的block</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;------do something------&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//启动</span></span><br><span class="line">  dispatch_resume(_timer);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果需要停止</span></span><br><span class="line">  dispatch_source_cancel(_timer);            </span><br><span class="line">  dispatch_release(_timer);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>取消<code>dispatch source</code>是一个异步操作，即虽然在调用了<code>dispatch_source_cancel</code>函数之后,<code>dispatch source</code>不能再接收到任何事件,但它还可以继续处理在队列中的事件,直到在队列中的最后一个事件被执行完成后,<code>dispatch source</code>才会执行cancellation handler句柄. 一般情况下是取消了dispatch source后，立即释放掉该对象.</p><h2 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch _suspend / dispatch _resume"></a>dispatch _suspend / dispatch _resume</h2><p><code>dispatch_suspend</code> 可以挂起我们正在执行的队列, 追加到<code>Dispatch Queue</code>中但尚未执行的处理在此之后停止执行, 需要注意的地方是, 这个方法并不会立即暂停正在运行的block,而是在当前block执行完成后,暂停后续的block执行.</p><p><code>dispatch _resume</code>则是唤醒已经挂起的que</p><h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><p><code>void dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t))</code><br>这个方法提交一个block块到一个分发的队里,以供多次调用.第一个参数是指需要执行的次数, 第二个参数是执行的队列(假设队列是并发队列,则会并发执行block任务,GCD会帮我们管理并发, 不会造成线程爆炸), 第三个参数则是需要执行的block.  </p><p><code>dispatch_apply</code>是一个同步调用, 需要block任务全部执行完后才返回.</p><h2 id="dispatch-benchmark"><a href="#dispatch-benchmark" class="headerlink" title="dispatch_benchmark"></a>dispatch_benchmark</h2><p><code>uint64_t dispatch_benchmark(size_t count, void (^block)(void));</code></p><p>这个函数可以帮助我们测量计算n次block任务的时间, 也就是说可以直接返回一个时间, 相比于其他的<code>CFAbsoluteTimeGetCurrent </code>相减, 方便很多.</p><h2 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h2><blockquote><p>这个也就是我们经常说的信号量了,信号量其实就是一个资源计数器,对信号量有两个操作来达到互斥, 分别是P和V操作, 设信号量值为1,当一个进程1运行时, 使用资源, 进行其进行P操作, 对信号量值减1, 也就是资源数少了1个. 这时信号量值为0, 系统中规定当信号量值为0时, 必须等待, 信号量值不为零才能继续操作. 这时如果进程2想要运行, 那么也必须进行P操作, 但是此时信号量为0, 所以无法减1, 即不能P操作, 也就阻塞. 这样就达到了进程1排他访问. 当进程1运行结束后, 释放资源, 进行V操作, 资源数重新加1, 这是信号量的值变为1. 这时进程2发现资源数不为0, 信号量能进行P操作了, 立即执行P操作. 信号量值又变为0. 进程2达到了排他访问. </p><p>所以我们可以通过信号量来达到线程同步的问题.</p></blockquote><p>我们可以通过<code>dispatch_semaphore_t dispatch_semaphore_create(long value)</code>来创建一个信号量</p><p><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</code> 等待信号</p><p><code>long dispatch_semaphore_signal(dispatch_semaphore_t dsema)</code> 使用这个函数来发送一个信号</p><h2 id="dispatch-group-enter-dispatch-group-leave"><a href="#dispatch-group-enter-dispatch-group-leave" class="headerlink" title="dispatch _group _enter / dispatch _group _leave"></a>dispatch _group _enter / dispatch _group _leave</h2><p><code>dispatch_group_enter</code> : 告诉group, 下面的任务马上要放到group中执行了.</p><p><code>dispatch_group_leave</code> : 告诉group, 任务执行完了, 该任务要从group中移除了.</p><p><code>dispatch_group_wait</code> : 会阻塞当前线程(所以不能放在主线程调用)一直等待; 当group上任务完成,或者等待时间超过设置的超时时间会结束等待. </p><p>需要注意的是前两个函数必须成对使用, 否则则会永远等待.</p><p><code>dispatch_group_notify</code> 通常我们应该使用这个, 不会阻塞当前线程，马上返回.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由于工作比较忙, 也都是在空闲时间看的源码, 陆陆续续写了一个星期, 虽然有些地方理解的不是很好, 但是收获却不少, 作为学习的笔记记录了下来.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近看到了一些关于GCD的一些问题,看了下不是很清楚,发现这些问题还是很有意思的, 所以决定研究下&lt;a href=&quot;https://opensource.apple.com/tarballs/libdispatch/&quot;&gt;GCD的源码&lt;/a&gt;,过程中还是找到了很多神奇的地方,作为学习的记录,于是写下了这个文章作为学习的笔记。。。&lt;br&gt;看的时候是最新的 &lt;code&gt;libdispatch-84.5.tar.gz&lt;/code&gt; 的版本，这个版本跟之前版本不太一样，不过总体上没有太大的改变。。。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Objective-C" scheme="http://aeronxie.github.io/tags/Objective-C/"/>
    
    <category term="GCD" scheme="http://aeronxie.github.io/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>iOS11带来的新变化</title>
    <link href="http://aeronxie.github.io/post/a7828452.html"/>
    <id>http://aeronxie.github.io/post/a7828452.html</id>
    <published>2017-07-02T08:58:46.000Z</published>
    <updated>2023-03-25T14:39:55.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS11-新功能"><a href="#iOS11-新功能" class="headerlink" title="iOS11 新功能"></a>iOS11 新功能</h2><blockquote><p>最近在调研iOS11的新功能和API适配问题，以及对线上产品的影响，然后就写下了这篇文章。。。</p></blockquote><p>我们首先来看一下iOS11的新功能~~</p><span id="more"></span><ul><li>通知中心</li></ul><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/ED4B6C1B-9E75-4F0C-8012-CE51EBCB6E6C.png"></p><p>这个通知中心变化很大，移动数据开关终于有了，然后还有录屏，长按每一个模块都可以进入到选项，这个控制中心我们可以自定义，需要在<code>设置-控制中心-自定控制</code>设置。</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/3EEBF2CC-2B8B-4711-9E16-3CC4701FD491.png"></p><ul><li><p>iOS11终于支持GIF图的保存了</p></li><li><p>文件管理器，有了Files这个App，不同的应用也可以调用同样的文件。同时，用户可以为文件添加不同颜色的标签，以便于进行文件分类。而和Finder不同的是，iOS11中的Files功能要偏弱一些，并没有提供完整的目录树，也不能访问系统文件。 </p></li></ul><h2 id="新增框架"><a href="#新增框架" class="headerlink" title="新增框架"></a>新增框架</h2><p><a href="https://developer.apple.com/documentation/arkit">ARKit</a> <code>增强现实技术的一个框架</code></p><p><a href="https://developer.apple.com/documentation/colorsync">ColorSync</a> <code>这个目前还是beta版,这个里面目前只有三个常量。。。不知道用来干啥</code></p><p><a href="https://developer.apple.com/documentation/vision">Vision</a> <code>用于脸部识别、对象追踪框架</code></p><p><a href="https://developer.apple.com/documentation/identitylookup">IdentityLookup</a> <code>用于短信过滤的框架,可以用来开发一个app扩展来拦截系统 SMS 和 MMS 的信息</code></p><p><a href="https://developer.apple.com/documentation/coreml">Core ML</a> <code>机器学习框架</code></p><p><a href="https://developer.apple.com/documentation/devicecheck">DeviceCheck</a> <code>用于生成设备唯一的token,通过服务器与 Apple 服务器通讯，并为单个设备设置 2bit 的数据</code></p><p><a href="https://developer.apple.com/documentation/fileprovider">FileProvider</a><br>&amp;<a href="https://developer.apple.com/documentation/fileproviderui">FileProviderUI</a> <code>提供一套 Files app 的界面，可以获取到用户设备上或者云端的文件</code></p><p><a href="https://developer.apple.com/documentation/corenfc">Core NFC</a> <code>NFC近场通讯框架</code></p><p><a href="https://developer.apple.com/documentation/pdfkit">PDFKit</a> <code>用于操作PDF的框架</code></p><h2 id="新增API"><a href="#新增API" class="headerlink" title="新增API"></a>新增API</h2><p><a href="https://developer.apple.com/documentation/uikit/drag_and_drop">Drag and Drop</a>  <code>一个支持拖拽的框架,UITextView和UITextField原生支持拖拽，UICollectionView和UITableView的拖拽有专用的 delegate 来表示拖拽的发生和结束,可以对任意UIView的子类定义拖拽行为</code></p><p><a href="https://developer.apple.com/videos/play/wwdc2017/206/">Auto Fill</a> <code>从 iCloud Keychain 中获取密码,可以自动填充。UITextInputTraits的textContentType中添加username和password，对的textView 或者 textField 的 contentType 进行配置，就可以在要求输入用户名密码时获取键盘上方的自动填充，帮助用户快速登录。</code></p><p><a href="https://developer.apple.com/documentation/coreimage/cibarcodedescriptor">CIBarcodeDescriptor</a> <code>在CoreImage里新增加了CIBarcodeDescriptor,以支持检测，解码和创建具有二进制内容的条形码</code></p><p><a href="https://developer.apple.com/documentation/uikit/uidocumentbrowserviewcontroller">UIDocumentBrowserViewController</a> <code>在UIKit中新增了,添加了UIDocumentBrowserViewController视图控制器，用于浏览存储在本地和iCloud的文档</code></p><p><a href="https://developer.apple.com/documentation/uikit/uifontmetrics">UIFontMetrics</a> <code>UIKit中新增的一个类,一个用于创建根据当前选定的文本大小进行缩放的自定义字体的对象.</code></p><p><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitycontentsizecategoryimageadjusting">UIAccessibilityContentSizeCategoryImageAdjusting</a> <code>一种用于缩放辅助功能文本大小的图像的协议</code></p><h3 id="iOS11新增大标题"><a href="#iOS11新增大标题" class="headerlink" title="iOS11新增大标题"></a>iOS11新增大标题</h3><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/2170491-f0fd3e0d1ac00b94.png"></p><p>在 iOS11 中，iOS提供了统一的实现方法即 Large Title，我们可以很轻松地实现上述效果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationController.navigationBar.prefersLargeTitles = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.navigationController.navigationItem.largeTitleDisplayMode = <span class="built_in">UINavigationItemLargeTitleDisplayModeAutomatic</span>;</span><br></pre></td></tr></table></figure><p><code>prefersLargeTitles</code>属性控制大标题是否显示<br><code>largeTitleDisplayMode</code>属性是一个枚举，</p><p><code>UINavigationItemLargeTitleDisplayModeAutomatic</code><br><code>UINavigationItemLargeTitleDisplayModeAlways</code><br><code>UINavigationItemLargeTitleDisplayModeNever</code><br>用于控制显示的模式，默认显示大标题，而当屏幕向上滑动的时候标题缩小恢复到过去的小标题样式</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/9F65C887-C6A9-4C77-BB8C-2A9C02D952B4.png"></p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/55D8D47B-73A9-4DC5-B877-AA941526CC88.png"></p><p>iOS中还提供了快速加入🔍的方法，跟TableView配合，就可以自动隐藏展示。。。<br>只需要加入如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationItem.searchController = [[<span class="built_in">UISearchController</span> alloc] initWithSearchResultsController:<span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">self</span>.navigationItem.hidesSearchBarWhenScrolling = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/ios11.gif"></p><h2 id="API调整"><a href="#API调整" class="headerlink" title="API调整"></a>API调整</h2><ul><li><p>iOS11下，苹果对相册的权限key做了调整，原来的 <a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW17">NSPhotoLibraryUsageDescription</a> ，在iOS11之后，改成了<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW73">NSPhotoLibraryAddUsageDescription</a></p></li><li><p>tableView在iOS中可能会出现一个黑框，原因是<code>automaticallyAdjustsScrollViewInsets</code>这个属性在iOS11过期了,我们需要使用UIScrollView的<code>contentInsetAdjustmentBehavior</code>属性来替代它.<br><code>tableView.contentInsetAdjustmentBehavior=UIScrollViewContentInsetAdjustmentNever;</code></p></li><li><p>关于TableView的API更新比较多，十多个，<a href="https://developer.apple.com/documentation/uikit/views_and_controls/table_views?changes=latest_minor&language=objc">更多关于TableView的API更新请戳这里</a></p></li></ul><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/E6ADA0DC-3AFE-40AF-B23A-913562AE2EF5.png"></p><ul><li><a href="https://developer.apple.com/documentation/uikit/uiscrollview?changes=latest_minor&language=objc">关于Scrollview的API更新</a></li></ul><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/128DCE3F-E513-4A54-978A-0796333E1B1E.png"></p><ul><li><a href="https://developer.apple.com/documentation/uikit/views_and_controls/collection_views?changes=latest_minor&language=objc">关于CollectionView的API更新</a></li></ul><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/D9BCD965-EF34-42D3-A634-619C9C4F59ED.png"></p><blockquote><p><a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS_11_0.html#//apple_ref/doc/uid/TP40017637-SW1">更多API更新请戳这里</a></p></blockquote><blockquote><p>ScrollView、TableView和CollectionView是项目中常用的控件，而且更新比较多，暂时列举这些，还有UIVIew等，大家请直接到<a href="https://developer.apple.com/documentation/uikit?changes=latest_minor&language=objc">官方文档查看</a></p></blockquote><h2 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h2><ul><li>添加了 GitHub 集成。</li></ul><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/50DA0DF7-3143-42C3-A157-C1140CCCA3FB.png"></p><ul><li>可以在<code>xcassets</code>里添加自定义颜色，然后在代码或者 IB 中使用这个颜色。</li></ul><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/E406BC4D-F323-48F1-98DD-F76F3E302C88.png"></p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/B7037544-6D80-49EE-95F0-ECB4D6BEC9D4.png"></p><ul><li>可以进行同局域网的无线部署和调试</li></ul><p>我们可以通过<code>command+shift+2</code>开启设备管理,然后并且勾上<code>connect via network</code>,直到左上角出现一个互联网的图标。之后我们便可以进行无线调试了</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/2DA3A668-F8B6-429C-986A-D24A58743DCF.png"></p><ul><li>Xcode9 还新增了检查修改UI是否在主线程中执行，如图</li></ul><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/B469A824-89DA-47AC-BC09-948A135D86A2.png"></p><p>我们可以看到，这里提示我们有两个地方我们在子线程修改了UI。</p><blockquote><p>还有什么新功能欢迎补充哦~~~</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;iOS11-新功能&quot;&gt;&lt;a href=&quot;#iOS11-新功能&quot; class=&quot;headerlink&quot; title=&quot;iOS11 新功能&quot;&gt;&lt;/a&gt;iOS11 新功能&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近在调研iOS11的新功能和API适配问题，以及对线上产品的影响，然后就写下了这篇文章。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们首先来看一下iOS11的新功能~~&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS11" scheme="http://aeronxie.github.io/tags/iOS11/"/>
    
    <category term="Xcode" scheme="http://aeronxie.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Runloop</title>
    <link href="http://aeronxie.github.io/post/cf8f80df.html"/>
    <id>http://aeronxie.github.io/post/cf8f80df.html</id>
    <published>2017-06-20T04:39:01.000Z</published>
    <updated>2023-03-25T14:39:55.649Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在研究检测页面卡顿的问题，发现基本上都是基于Runloop的，所以打算把Runloop再好好复习一遍，于是就把学习的过程记录一下。</p></blockquote><h6 id="在OSX-iOS-系统中，提供了两个对象：NSRunLoop（线程不安全）-和-CFRunLoopRef（线程安全）。但是NSRunloop是闭源的，我们无法直接查看到内部实现，但是CFRunLoopRef是开源的，CFRunLoopRef-在-CoreFoundation-框架内，它提供了纯-C-函数的-API，接下来我们就分析一下CFRunLoopRef的内部实现。目前最新的版本是-CF-855-17"><a href="#在OSX-iOS-系统中，提供了两个对象：NSRunLoop（线程不安全）-和-CFRunLoopRef（线程安全）。但是NSRunloop是闭源的，我们无法直接查看到内部实现，但是CFRunLoopRef是开源的，CFRunLoopRef-在-CoreFoundation-框架内，它提供了纯-C-函数的-API，接下来我们就分析一下CFRunLoopRef的内部实现。目前最新的版本是-CF-855-17" class="headerlink" title="在OSX/iOS 系统中，提供了两个对象：NSRunLoop（线程不安全） 和 CFRunLoopRef（线程安全）。但是NSRunloop是闭源的，我们无法直接查看到内部实现，但是CFRunLoopRef是开源的，CFRunLoopRef 在 CoreFoundation 框架内，它提供了纯 C 函数的 API，接下来我们就分析一下CFRunLoopRef的内部实现。目前最新的版本是 CF-855.17."></a>在OSX/iOS 系统中，提供了两个对象：<code>NSRunLoop</code>（线程不安全） 和 <code>CFRunLoopRef</code>（线程安全）。但是<code>NSRunloop</code>是闭源的，我们无法直接查看到内部实现，但是<code>CFRunLoopRef</code>是<a href="https://opensource.apple.com/tarballs/CF/">开源</a>的，<code>CFRunLoopRef</code> 在 <code>CoreFoundation</code> 框架内，它提供了纯 C 函数的 API，接下来我们就分析一下<code>CFRunLoopRef</code>的内部实现。目前最新的版本是 <code>CF-855.17</code>.</h6><span id="more"></span><p>在开发中，我们可以通过两种方式来获取线程，</p><p>NSThread：</p><ul><li><p><code>[NSThread mainThread]</code>获取主线程</p></li><li><p><code>[NSThread currentThread]</code>获取当前线程</p></li></ul><p>pthread：</p><ul><li><p><code>pthread_main_np()</code> 获取主线程</p></li><li><p><code>pthread_self()</code> 获取当前线程</p></li></ul><blockquote><p>CFRunLoop 是基于 pthread 来管理的。</p></blockquote><h5 id="可以看出这两者是一一对应的，但是没有找到这两者的转换方式-不过我们可以用pthread-t-pthread-from-mach-thread-np-mach-port-t-进行pthread-t-和mach-port-t-两者的转换。-task-threads-这个函数可以返回任务中的线程列表。"><a href="#可以看出这两者是一一对应的，但是没有找到这两者的转换方式-不过我们可以用pthread-t-pthread-from-mach-thread-np-mach-port-t-进行pthread-t-和mach-port-t-两者的转换。-task-threads-这个函数可以返回任务中的线程列表。" class="headerlink" title="可以看出这两者是一一对应的，但是没有找到这两者的转换方式. 不过我们可以用pthread_t pthread_from_mach_thread_np(mach_port_t)进行pthread_t 和mach_port_t 两者的转换。 task_threads 这个函数可以返回任务中的线程列表。"></a>可以看出这两者是一一对应的，但是没有找到这两者的转换方式. 不过我们可以用<code>pthread_t pthread_from_mach_thread_np(mach_port_t)</code>进行<code>pthread_t </code>和<code>mach_port_t </code>两者的转换。 <code>task_threads </code>这个函数可以返回任务中的线程列表。</h5><pre><code>mach_msg_type_number_t count;thread_act_array_t list;task_threads(mach_task_self(), &amp;list, &amp;count);</code></pre><h4 id="我们不能直接创建RunLoop-我们也可以通过两种方式来获取，"><a href="#我们不能直接创建RunLoop-我们也可以通过两种方式来获取，" class="headerlink" title="我们不能直接创建RunLoop,我们也可以通过两种方式来获取，"></a>我们不能直接创建<code>RunLoop</code>,我们也可以通过两种方式来获取，</h4><h5 id="NSRunLoop："><a href="#NSRunLoop：" class="headerlink" title="NSRunLoop："></a>NSRunLoop：</h5><ul><li><p><code>[NSRunLoop mainRunLoop];</code>获取主runloop</p></li><li><p><code>[NSRunLoop currentRunLoop];</code>获取当前runloop</p></li></ul><h5 id="CFRunLoopRef："><a href="#CFRunLoopRef：" class="headerlink" title="CFRunLoopRef："></a>CFRunLoopRef：</h5><ul><li><p><code>    CFRunLoopGetMain()</code>获取主runloop</p></li><li><p><code>CFRunLoopGetCurrent()</code>获取当前runloop</p></li></ul><p>我们先来看一下<code>CFRunLoopGetMain</code>函数的实现方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>(<span class="type">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFRunLoopRef</span> __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CFRunLoopGetCurrent</code>函数的实现方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="type">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这两个函数都调用了<code>_CFRunLoopGet0</code>这个函数，可见这个函数才是核心，看下这个函数的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key是pthread_t， value是CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> __CFRunLoops = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock = <span class="built_in">CFSpinLockInit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个pthread对应的runloop</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="comment">// 创建一个字典，key是pthread，value是runloop</span></span><br><span class="line"><span class="built_in">CFMutableDictionaryRef</span> dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"><span class="comment">// 创建一个主线程的runloop</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line"><span class="built_in">CFDictionarySetValue</span>(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line"><span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="type">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">    <span class="built_in">CFRelease</span>(dict);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CFRelease</span>(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过pthread直接取runloop</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line"><span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line"><span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">    <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">    loop = newLoop;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line"><span class="built_in">CFRelease</span>(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">    <span class="comment">// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="type">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="type">void</span> (*)(<span class="type">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="从上面的代码可以看出，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的-Dictionary-里。线程刚创建时并没有-RunLoop，如果你不主动获取，那它一直都不会有。RunLoop-的创建是发生在第一次获取时，RunLoop-的销毁是发生在线程结束时。你只能在一个线程的内部获取其-RunLoop（主线程除外）。"><a href="#从上面的代码可以看出，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的-Dictionary-里。线程刚创建时并没有-RunLoop，如果你不主动获取，那它一直都不会有。RunLoop-的创建是发生在第一次获取时，RunLoop-的销毁是发生在线程结束时。你只能在一个线程的内部获取其-RunLoop（主线程除外）。" class="headerlink" title="从上面的代码可以看出，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。"></a>从上面的代码可以看出，<code>线程</code>和<code>RunLoop</code>之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</h5><p>接下来我们可以在<code>CFRunLoop.h</code>文件中看到几个对外提供的接口：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CFStringRef</span> <span class="built_in">CFRunLoopMode</span> <span class="built_in">CF_EXTENSIBLE_STRING_ENUM</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="type">id</span>) __CFRunLoop * <span class="built_in">CFRunLoopRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="type">id</span>) __CFRunLoopSource * <span class="built_in">CFRunLoopSourceRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="type">id</span>) __CFRunLoopObserver * <span class="built_in">CFRunLoopObserverRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="built_in">NSTimer</span>) __CFRunLoopTimer * <span class="built_in">CFRunLoopTimerRef</span>;</span><br></pre></td></tr></table></figure><p>在<code>CFRunLoop.c</code>文件看到了还有<code>__CFRunLoopMode</code>结构体，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">    pthread_mutex_t _lock;<span class="comment">/* must have the run loop locked before locking this */</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="type">char</span> _padding[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0; <span class="comment">// 非基于Port的 ，用于用户主动触发事件</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1; <span class="comment">// 包含了一个 mach_port，被用于通过内核和其他线程相互发送消息,能主动唤醒 RunLoop 的线程。</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line">    <span class="built_in">CFMutableDictionaryRef</span> _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    <span class="built_in">CFIndex</span> _observerMask;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    <span class="type">void</span> (*_msgPump)(<span class="type">void</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    uint64_t _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">    uint64_t _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定一个Mode启动，允许设置超时时间   </span></span><br><span class="line">SInt32 <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用kCFRunLoopDefaultMode启动</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="type">void</span>) &#123;<span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    int32_t result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实际上-RunLoop-就是这样一个函数，其内部是一个-do-while-循环。当你调用-CFRunLoopRun-时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回"><a href="#实际上-RunLoop-就是这样一个函数，其内部是一个-do-while-循环。当你调用-CFRunLoopRun-时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回" class="headerlink" title="实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回."></a>实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回.</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runloop的实现</span></span><br><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="comment">// 根据modeName找到当前对应的mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果currentMode里没有source/timer/observer, 直接返回kCFRunLoopRunFinished，如果有则开始处理source</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">Boolean did = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">__CFRunLoopUnlock(rl);</span><br><span class="line"><span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    int32_t result = kCFRunLoopRunFinished;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) </span><br><span class="line"><span class="comment">// 通知 Observers: 即将进入runloop。</span></span><br><span class="line">__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line"><span class="comment">// 通知 Observers: 即将退出runloop。</span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">        __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/RunLoop_0.png"></p><h5 id="通过代码我们可以看出：一个-RunLoop-包含多个-Mode，每个-Mode-又包含多个-Source-Timer-Observer。每次调用CFRunLoopRunInMode时，只能指定其中一个-Mode，这个Mode被称作-CurrentMode。如果需要切换-Mode，只能退出-Loop，再重新指定一个-Mode-进入。这样做主要是为了分隔开不同组的-Source-Timer-Observer，让其互不影响。"><a href="#通过代码我们可以看出：一个-RunLoop-包含多个-Mode，每个-Mode-又包含多个-Source-Timer-Observer。每次调用CFRunLoopRunInMode时，只能指定其中一个-Mode，这个Mode被称作-CurrentMode。如果需要切换-Mode，只能退出-Loop，再重新指定一个-Mode-进入。这样做主要是为了分隔开不同组的-Source-Timer-Observer，让其互不影响。" class="headerlink" title="通过代码我们可以看出：一个 RunLoop 包含多个 Mode，每个 Mode 又包含多个 Source/Timer/Observer。每次调用CFRunLoopRunInMode时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。"></a>通过代码我们可以看出：一个 RunLoop 包含多个 Mode，每个 Mode 又包含多个 Source/Timer/Observer。每次调用<code>CFRunLoopRunInMode</code>时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</h5><h3 id="Runloop内部逻辑"><a href="#Runloop内部逻辑" class="headerlink" title="Runloop内部逻辑"></a>Runloop内部逻辑</h3><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/RunLoop_1.png"></p><h4 id="我们给当前runloop添加一个观察者："><a href="#我们给当前runloop添加一个观察者：" class="headerlink" title="我们给当前runloop添加一个观察者："></a>我们给当前runloop添加一个观察者：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> callback(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity,<span class="type">void</span> *info) &#123;</span><br><span class="line"><span class="keyword">switch</span> (activity) &#123;</span><br><span class="line"><span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;即将进入runloop&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;即将处理 Timer&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;即将处理 Sources&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;即将进入休眠&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;从休眠中唤醒loop&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;即将退出runloop&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFRunLoopObserverContext</span> context = &#123; <span class="number">0</span>,</span><br><span class="line"> (__bridge <span class="type">void</span> *)(<span class="keyword">self</span>),</span><br><span class="line">                                 &amp;<span class="built_in">CFRetain</span>,</span><br><span class="line">                                 &amp;<span class="built_in">CFRelease</span>,</span><br><span class="line">                                 <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="built_in">CFOptionFlags</span> activitys = (kCFRunLoopBeforeWaiting | kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CFRunLoopObserverCreate(&lt;#CFAllocatorRef allocator#&gt;, &lt;#CFOptionFlags activities#&gt;, &lt;#Boolean repeats#&gt;, &lt;#CFIndex order#&gt;, &lt;#CFRunLoopObserverCallBack callout#&gt;, &lt;#CFRunLoopObserverContext *context#&gt;)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 第一个参数：（&lt;#CFAllocatorRef allocator#&gt;）分配存储空间</span></span><br><span class="line"><span class="comment"> 第二个参数：（&lt;#CFOptionFlags activities#&gt;）要监听的状态（kCFRunLoopAllActivities）所有的状态</span></span><br><span class="line"><span class="comment"> 第三个参数：（&lt;#Boolean repeats#&gt;）是否持续监听</span></span><br><span class="line"><span class="comment"> 第四个参数：（&lt;#CFIndex order#&gt;）优先级</span></span><br><span class="line"><span class="comment"> 第五个参数：回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(<span class="built_in">CFAllocatorGetDefault</span>(), activitys, <span class="literal">YES</span>, INT_MAX, &amp;callback, &amp;context);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(runLoop, observer, kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="我们可以自己写一个timer试验一下，发现如下打印："><a href="#我们可以自己写一个timer试验一下，发现如下打印：" class="headerlink" title="我们可以自己写一个timer试验一下，发现如下打印："></a>我们可以自己写一个timer试验一下，发现如下打印：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">2017-06-12 20:35:15.779 CodeTest[43168:5 050565] 从休眠中唤醒loop</span></span><br><span class="line"><span class="comment">    2017-06-12 20:35:15.780 CodeTest[43168:5050565] &lt;__NSCFTimer: 0x600000176380&gt;</span></span><br><span class="line"><span class="comment">    2017-06-12 20:35:15.780 CodeTest[43168:5050565] 即将处理 Timer</span></span><br><span class="line"><span class="comment">    2017-06-12 20:35:15.780 CodeTest[43168:5050565] 即将处理 Sources</span></span><br><span class="line"><span class="comment">    2017-06-12 20:35:15.780 CodeTest[43168:5050565] 即将进入休眠</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="执行逻辑跟图示一样"><a href="#执行逻辑跟图示一样" class="headerlink" title="执行逻辑跟图示一样"></a>执行逻辑跟图示一样</h4><h2 id="Runloop线程保活"><a href="#Runloop线程保活" class="headerlink" title="Runloop线程保活"></a>Runloop线程保活</h2><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/436C3B06-5744-459C-ADF0-CAE74FA672B6.png"></p><p>从苹果的官方文档看，我们可以看到runloop开启有这四种方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)run;</span><br></pre></td></tr></table></figure><blockquote><p>我们先来看下这个方法，它会开启一个永驻的runloop，来处理Input Source，内部会循环调用runMode：beforeDate，并且运行在NSDefaultRunLoopMode这个模式下，即使用<code>void CFRunLoopStop(CFRunLoopRef rl)</code>也无法停止runloop的运行，除非能移除这个runloop上的所有事件源，包括timer和source，不然这个子线程就无法停止，只能永久运行下去。</p></blockquote><blockquote><p>但是并不建议我们使用这个方法来开启，如果我们想要停止runloop。我们可以采用这种方式，</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BOOL</span> shouldKeepRunning = <span class="literal">YES</span>; <span class="comment">// global</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *theRL = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="keyword">while</span> (shouldKeepRunning &amp;&amp; [theRL runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]]);</span><br></pre></td></tr></table></figure><blockquote><p>当条件<code>shouldKeepRunning</code>设置为NO的时候，我们就可以退出runloop</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)runUntilDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法我们可以设置一个超时时间，如果没有检测到timer和source输入源，runloop则立刻退出，否则当到达超时时间的时候才会退出，这个方法也是运行在NSDefaultRunLoopMode模式下的，需要注意的是<code>void CFRunLoopStop(CFRunLoopRef rl)</code>也无法停止runloop的运行</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BOOL</span> shouldKeepRunning = <span class="literal">YES</span>; <span class="comment">// global</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *theRL = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="keyword">while</span> (!shouldKeepRunning) &#123;</span><br><span class="line">  [theRL runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">5</span>]];</span><br><span class="line">  <span class="comment">// do somthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法无非就是每隔5秒退出一次，然后判断自己需要做的事并可以设置shouldKeepRunning是否需要设置为NO</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)runMode:(<span class="built_in">NSRunLoopMode</span>)mode beforeDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法比上面的方法多了一个mode参数，这种方式是可以使用<code>void CFRunLoopStop(CFRunLoopRef rl)</code>停止runloop运行的。但是需要注意的是，这种方法会导致runloop退出，我们看如下代码：</p></blockquote> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;线程开始&quot;</span>);</span><br><span class="line"><span class="comment">//获取到当前线程</span></span><br><span class="line"><span class="keyword">self</span>.thread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSRunLoop</span> *runloop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"></span><br><span class="line"><span class="comment">//[runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span></span><br><span class="line"></span><br><span class="line">[runloop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;线程结束&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(recieveMsg) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)recieveMsg &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;收到消息了，在这个线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们会发现打印 :<br><code>2017-06-20 10:14:45.653 CodeTest[47702:5665253] 线程开始</code><br><code>2017-06-20 10:14:45.654 CodeTest[47702:5665253] 线程结束</code></p></blockquote><blockquote><p>也就是说根本不会执行<code>recieveMsg</code>这个方法，因为这个线程执行完，没有检测到输入源就会立刻退出runloop。需要注意的是，如果我们在<code>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</code> 这个方法中把wait设置成了YES，则如果线程退出了话，就会crash</p></blockquote><blockquote><p>但是如果我们把<code>[runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</code>这行代码打开的话，会出现如下打印：</p></blockquote><blockquote><p><code>2017-06-20 10:27:02.673 CodeTest[47749:5678254] 线程开始</code><br><code>2017-06-20 10:27:04.867 CodeTest[47749:5678254] 收到消息了，在这个线程：&lt;NSThread: 0x608000069fc0&gt;&#123;number = 3, name = (null)&#125;</code><br><code>2017-06-20 10:27:04.867 CodeTest[47749:5678254] 线程结束</code></p><p>那么为什么添加一个端口就可以让线程不退出呢？ 添加一个端口监听这个端口的事件，这个就是我们之前所说的source1，保证runloop有输入源，也就是保证runloop不会退出，这也是一种线程间的通信方式-基于端口的通信。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopSourceRef</span> rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">   <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">mach_msg_header_t *reply = <span class="literal">NULL</span>;</span><br><span class="line">sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">   (<span class="type">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">   <span class="built_in">CFAllocatorDeallocate</span>(kCFAllocatorSystemDefault, reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个 Source1 (基于port) 发出事件了，就处理这个事件，这就是为什么有port能线程保活的原因。</p></blockquote><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><blockquote><p>线程间的通信，实际上是各种输入源，触发runloop去处理对应的事件，输入源会异步的发送消息给你的线程。事件来源取决于输入源的种类：基于端口的输入源和自定义输入源。</p></blockquote><blockquote><ul><li>基于端口的输入源监听程序相应的端口。</li><li>自定义输入源则监听自定义的事件源。</li></ul></blockquote><blockquote><p>两类输入源的区别在于：基于端口的输入源由内核自动发送，而自定义的则需要人工从其他线程发送。</p></blockquote><blockquote><p>基于端口的输入源:<br>在runloop中，被定义名为souce1。Cocoa和CoreFoundation内置支持使用端口相关的对象和函数来创建的基于端口的源。在Cocoa里面你从来不需要直接创建输入源。你只要简单的创建端口对象，并使用NSPort的方法把该端口添加到runloop。端口对象会自己处理创建和配置输入源。</p></blockquote><blockquote><p>Cocoa里用来线程间传值的是NSMachPort，它的父类是NSPort。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSPort</span> *port = [<span class="built_in">NSPort</span> port];</span><br><span class="line"><span class="built_in">NSMachPort</span> *machPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line"><span class="built_in">NSPort</span> *machPort_port = [<span class="built_in">NSMachPort</span> port];</span><br></pre></td></tr></table></figure><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/B7B2FF3E-2CF6-4077-B83F-326F6A194E94.png"></p><p>然后发现怎么创建都是返回 <code>NSMachPort</code>对象。。。。。</p><p>利用NSMachPort来实现线程通信的🌰</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSPort</span> *mainPort = [<span class="built_in">NSPort</span> port];</span><br><span class="line"><span class="built_in">NSPort</span> *threadPort = [<span class="built_in">NSPort</span> port];</span><br><span class="line"></span><br><span class="line">threadPort.delegate = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给主线程runloop加一个端口</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> mainRunLoop] addPort:mainPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line"><span class="comment">//给子线程runloop加一个端口</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:threadPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;hello world！&quot;</span>;</span><br><span class="line"><span class="built_in">NSData</span> *data = [str dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithArray:@[mainPort,data]];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> @param limitDate 限制时间</span></span><br><span class="line"><span class="comment"> @param msgID 信息标识</span></span><br><span class="line"><span class="comment"> @param components 消息组件</span></span><br><span class="line"><span class="comment"> @param receivePort 接受端口</span></span><br><span class="line"><span class="comment"> @param headerSpaceReserved 为头部预留的字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[threadPort sendBeforeDate:[<span class="built_in">NSDate</span> date] msgid:<span class="number">1000</span> components:array from:mainPort reserved:<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)handlePortMessage:(<span class="type">id</span>)message &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;收到消息了，线程为：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="comment">//只能用KVC的方式取值</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [message valueForKeyPath:<span class="string">@&quot;components&quot;</span>];</span><br><span class="line"><span class="built_in">NSData</span> *data =  array[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>出现如下打印：</p></blockquote><blockquote><p>2017-06-20 12:05:34.441 CodeTest[48264:5786736] 收到消息了，线程为:&lt;NSThread: 0x608000261800&gt;{number = 3, name = (null)}</p><p>2017-06-20 12:05:34.441 CodeTest[48264:5786736] hello world！</p><p>说明我们从主线程往子线程发送了消息</p></blockquote><h4 id="需要注意的是，components这个传参数组里面只能装两种类型的数据，一种是NSPort的子类，一种是NSData的子类。"><a href="#需要注意的是，components这个传参数组里面只能装两种类型的数据，一种是NSPort的子类，一种是NSData的子类。" class="headerlink" title="需要注意的是，components这个传参数组里面只能装两种类型的数据，一种是NSPort的子类，一种是NSData的子类。"></a>需要注意的是，components这个传参数组里面只能装两种类型的数据，一种是NSPort的子类，一种是NSData的子类。</h4><blockquote><p>自定义输入源，自定义输入源必须是使用CoreFoundation里面的<code>CGRunLoopSourceRef</code>类型相关的函数来创建。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> _runLoopRef;</span><br><span class="line"><span class="built_in">CFRunLoopSourceRef</span> _source;</span><br><span class="line"><span class="built_in">CFRunLoopSourceContext</span> _context;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;starting thread.......&quot;</span>);</span><br><span class="line">_runLoopRef = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="comment">//初始化_context,把所有内容先置为0</span></span><br><span class="line">bzero(&amp;_context, <span class="keyword">sizeof</span>(_context));</span><br><span class="line"><span class="comment">//这里创建了一个基于事件的源，绑定了一个函数</span></span><br><span class="line">_context.perform = fire;</span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line">_context.info = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">_source = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;_context);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopAddSource</span>(_runLoopRef, _source, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">YES</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;end thread.......&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CFRunLoopIsWaiting</span>(_runLoopRef)) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop 正在等待事件输入&quot;</span>);</span><br><span class="line"><span class="comment">//添加输入事件</span></span><br><span class="line"><span class="built_in">CFRunLoopSourceSignal</span>(_source);</span><br><span class="line"><span class="comment">//唤醒线程，线程唤醒后发现由事件需要处理，于是立即处理事件</span></span><br><span class="line"><span class="built_in">CFRunLoopWakeUp</span>(_runLoopRef);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop 正在处理事件&quot;</span>);</span><br><span class="line"><span class="comment">//添加输入事件，当前正在处理一个事件，当前事件处理完成后，立即处理当前新输入的事件</span></span><br><span class="line"><span class="built_in">CFRunLoopSourceSignal</span>(_source);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此输入源需要处理的后台事件</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> fire(<span class="type">void</span> *info)&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;我现在正在处理后台任务&quot;</span>);</span><br><span class="line"><span class="type">char</span> *str = info;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>出现如下打印：</p></blockquote><blockquote><p>2017-06-20 12:27:39.164 CodeTest[48418:5812271] starting thread…….</p><p>2017-06-20 12:27:44.165 CodeTest[48418:5812163] RunLoop 正在等待事件输入</p></blockquote><blockquote><p>2017-06-20 12:27:44.165 CodeTest[48418:5812271] 我现在正在处理后台任务</p></blockquote><blockquote><p>2017-06-20 12:27:44.165 CodeTest[48418:5812271] hello</p></blockquote><blockquote><p>2017-06-20 12:27:44.165 CodeTest[48418:5812271] end thread…….</p></blockquote><h2 id="最后，学习还请看大神的文章"><a href="#最后，学习还请看大神的文章" class="headerlink" title="最后，学习还请看大神的文章"></a>最后，学习还请看大神的<a href="http://blog.ibireme.com/2015/05/18/runloop/">文章</a></h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在研究检测页面卡顿的问题，发现基本上都是基于Runloop的，所以打算把Runloop再好好复习一遍，于是就把学习的过程记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;在OSX-iOS-系统中，提供了两个对象：NSRunLoop（线程不安全）-和-CFRunLoopRef（线程安全）。但是NSRunloop是闭源的，我们无法直接查看到内部实现，但是CFRunLoopRef是开源的，CFRunLoopRef-在-CoreFoundation-框架内，它提供了纯-C-函数的-API，接下来我们就分析一下CFRunLoopRef的内部实现。目前最新的版本是-CF-855-17&quot;&gt;&lt;a href=&quot;#在OSX-iOS-系统中，提供了两个对象：NSRunLoop（线程不安全）-和-CFRunLoopRef（线程安全）。但是NSRunloop是闭源的，我们无法直接查看到内部实现，但是CFRunLoopRef是开源的，CFRunLoopRef-在-CoreFoundation-框架内，它提供了纯-C-函数的-API，接下来我们就分析一下CFRunLoopRef的内部实现。目前最新的版本是-CF-855-17&quot; class=&quot;headerlink&quot; title=&quot;在OSX/iOS 系统中，提供了两个对象：NSRunLoop（线程不安全） 和 CFRunLoopRef（线程安全）。但是NSRunloop是闭源的，我们无法直接查看到内部实现，但是CFRunLoopRef是开源的，CFRunLoopRef 在 CoreFoundation 框架内，它提供了纯 C 函数的 API，接下来我们就分析一下CFRunLoopRef的内部实现。目前最新的版本是 CF-855.17.&quot;&gt;&lt;/a&gt;在OSX/iOS 系统中，提供了两个对象：&lt;code&gt;NSRunLoop&lt;/code&gt;（线程不安全） 和 &lt;code&gt;CFRunLoopRef&lt;/code&gt;（线程安全）。但是&lt;code&gt;NSRunloop&lt;/code&gt;是闭源的，我们无法直接查看到内部实现，但是&lt;code&gt;CFRunLoopRef&lt;/code&gt;是&lt;a href=&quot;https://opensource.apple.com/tarballs/CF/&quot;&gt;开源&lt;/a&gt;的，&lt;code&gt;CFRunLoopRef&lt;/code&gt; 在 &lt;code&gt;CoreFoundation&lt;/code&gt; 框架内，它提供了纯 C 函数的 API，接下来我们就分析一下&lt;code&gt;CFRunLoopRef&lt;/code&gt;的内部实现。目前最新的版本是 &lt;code&gt;CF-855.17&lt;/code&gt;.&lt;/h6&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Runloop" scheme="http://aeronxie.github.io/tags/Runloop/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Git</title>
    <link href="http://aeronxie.github.io/post/3cd14bc1.html"/>
    <id>http://aeronxie.github.io/post/3cd14bc1.html</id>
    <published>2017-04-04T09:20:58.000Z</published>
    <updated>2023-03-25T14:39:55.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git深入理解"><a href="#Git深入理解" class="headerlink" title="Git深入理解"></a>Git深入理解</h1><blockquote><p>Git是我们平时团队协作必不可少的版本控制系统。这次就来深入探讨一下其中的原理。</p></blockquote><span id="more"></span><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>我们先新建一个项目，就叫<code>TestGit</code>吧。。。我们先来看一下目录结构：</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%2014.51.10.png"></p><p>然后我们用<code>tree</code>命令看一下目录结构</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%2014.53.48.png"></p><p>然后我们初始化一下git：</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/QQ20170404-150807@2x.png"> </p><p><code>先初始化git，然后添加所有文件到git的暂存区，成功后提交一个commit，最后log一下版本历史记录</code> ,大概就是进行了这几个步骤。</p><h4 id="那么这个commit到底执行的是什么操作呢？"><a href="#那么这个commit到底执行的是什么操作呢？" class="headerlink" title="那么这个commit到底执行的是什么操作呢？"></a>那么这个commit到底执行的是什么操作呢？</h4><p>先别急，我们先来看看着张图：</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/f1e4cbe9-1f7d-4826-8a61-1f7d065e43ce.png"></p><p>这是项目的三个版本，版本1中有两个文件A和B,然后修改了A，变成了A1,形成了版本2,接着又修改了B变为B1,形成了版本3。</p><p>如果我们把项目的每个版本都保存到本地仓库,需要保存至少6个文件,而实际上，只有4个不同的文件,A、A1、B、B1。为了节省存储的空间,我们要想一个方法将同样的文件只需要保存一份,这就引入了Sha-1算法。</p><p><code>SHA-1将文件中的内容通过通过计算生成一个 40 位长度的hash值。</code></p><h4 id="Sha-1特点："><a href="#Sha-1特点：" class="headerlink" title="Sha-1特点："></a>Sha-1特点：</h4><ul><li>由文件内容计算出的hash值</li><li>hash值相同，文件内容相同</li></ul><p>对于上图中的内容，无论我们执行多少次，都会得到相同的结果。因此，文件的sha-1值是可以作为文件的唯一 id ,同时,它还有一个额外的功能，校验文件完整性。</p><p>其实当我们运行<code>git commit -m &quot;git init&quot;</code>命令时，git主要进行了三个操作:</p><h5 id="1-为每一个文件生成一个快照"><a href="#1-为每一个文件生成一个快照" class="headerlink" title="1.为每一个文件生成一个快照"></a>1.为每一个文件生成一个快照</h5><p>每一个文件其实是真的数据，所以git会把整个文件内容转成二进制，然后经过压缩直接存在键值对数据库中，对应的键值就是文件中的内容再附加一些头信息的40位校验和sha-1。既然是真数据，所以文件快照的类型为<code>blob</code>类型（binary large object）即大型二进制对象类型<br><code>blob: 用来存放项目文件的内容，但是不包括文件的路径、名字、格式等其它描述信息。项目的任意文件的任意版本都是以blob的形式存放的。</code></p><h5 id="2-为每一个文件夹生成一个快照"><a href="#2-为每一个文件夹生成一个快照" class="headerlink" title="2.为每一个文件夹生成一个快照"></a>2.为每一个文件夹生成一个快照</h5><p>文件夹并不是直接的文字数据，其主要记录的是文件夹的结构和每个文件或者文件夹所对应的快照键值，所以文件夹的快照内容主要是其包含的所有文件和文件夹的键值信息总和，附加一些头信息，如文件名，文件夹名。对应快照键值为快照内容的40位校验和sha-1。既然不是直接数据，数据类型与文件快照必然不同，文件夹快照对应的类型为tree类型。<br><code>tree :用来表示目录。我们知道项目就是一个目录，目录中有文件、有子目录。因此 tree 中有 blob、子tree，且都是使用 sha-1值引用的。这是与目录对应的。从顶层的 tree 纵览整个树状的结构，叶子结点就是blob，表示文件的内容，非叶子结点表示项目的目录，顶层的 tree 对象就代表了当前项目的快照。</code></p><h5 id="3-生成一个项目快照"><a href="#3-生成一个项目快照" class="headerlink" title="3.生成一个项目快照"></a>3.生成一个项目快照</h5><p>也即生成一个commit，项目快照的内容主要包含四部分信息，根项目目录的快照、提交人信息、项目快照说明（即commit信息）和父项目快照。其中项目文件快照，只要根目录即’TestGit’的目录快照即可。项目快照commit的键值为项目快照内容的40位校验和sha-1。项目快照类型为commit类型。<br><code>commit: 表示一次提交，有parent字段，用来引用父提交。指向了一个顶层 tree，表示了项目的快照，还有一些其它的信息，比如上一个提交，committer、author、message 等信息。</code></p><h4 id="我们可以看下数据库中的文件"><a href="#我们可以看下数据库中的文件" class="headerlink" title="我们可以看下数据库中的文件"></a>我们可以看下数据库中的文件</h4><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%2015.33.02.png"></p><p>我们可以看到，在 objects 目录下，存放了很多文件，他们都使用 sha-1 的前两位创建了文件夹，剩下的38位为文件名。我们先称呼这些文件为 obj 文件。</p><p>对于这么多的 obj 文件，就保存了我们代码提交的所有记录。对于这些 obj 文件，其实分为四种类型，分别是 blob、tree、commit、tag。</p><p>我们可以使用命令 <code>find .git/objects -type f</code> 看到每一个object的信息</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%2015.48.17.png"></p><p>通过 <code>cat-file </code>命令可以将数据内容取回, 传入 <code>-p</code> 参数可以让该命令输出数据内容的类型：</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%2015.52.07.png"></p><p>这些object其实就是这些文件<br><img src="http://7xoijj.com1.z0.glb.clouddn.com/IMG_4350.JPG"></p><p>如果我们添加了新的文件，其所在的文件夹也因新添加的文件而产生了内容的变化，因此也会生成新的快照，同样的根文件夹<code>TestGit</code>也生成了新的快照。最终的形成新的commitd指向最新的根文件<code>TestGit</code>的快照。<br><code>只有变化的文件或文件夹才会形成新的快照，没有变化的文件不会形成新的快照。</code></p><h2 id="branch-分支"><a href="#branch-分支" class="headerlink" title="branch-分支"></a>branch-分支</h2><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/876aff53-1fd9-44b2-bfe4-bc97f35cd192.png"></p><p>分支的目的是让我们可以并行的进行开发。比如我们当前正在开发功能，但是需要修复一个紧急bug，我们不可能在这个项目正在修改的状态下修复 bug，因为这样会引入更多的bug。有了分支的概念，我们就可以新建一个分支，修复 bug，使新功能与 bug 修复同步进行。</p><p>分支的实现其实很简单，我们可以先看一下 <code>.git/refs/heads/master</code> 文件，它保存了当前的分支。</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%2016.57.34.png"></p><p>打开master，里面的内容是<code>bdac9e2702227bd5a2f5024742e42a6cd4636553</code>,这是最新commit的键值，所以branch仅仅是指向一个commit的指针而已，指向一个commit，而一个commit同时指向其父commit，如此循环最终形成了一个branch</p><h3 id="head指针"><a href="#head指针" class="headerlink" title="head指针"></a>head指针</h3><p>那git是怎么知道项目在master分支上呢？HEAD指针。git有一个独立的HEAD指针，记录项目现在所在的位置，比如现在我们在master分支上，查看<code>.git/HEAD</code>文件，内容为：<code>ref: refs/heads/master</code></p><p>此时HEAD指针指向master，所以项目在master分支上</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%2017.08.10.png"></p><p>当我们创建一个新的分支test时，git会在.git/refs/heads/目录下生成一个文件test，并将其指向当前HEAD所指向的分支master所指向的提交，并把HEAD指向新的分支test(<code>ref: refs/heads/test</code>)。</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/branch3.png"></p><p>当我们在新的分支生成新的commit时，git会将HEAD所指向的分支test所指向的commit作为新commit的父commit，然后将HEAD所指向的分支test移动指向新的提交。</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/branch4.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>git中每一个文件会生成一个blob类型的object记录这个文件的状态，每一个文件夹都会生成一个tree类型的object就录这个文件夹的状态，一个项目会生成一个指向根目录tree object的commit类型object作为项目的快照。</p></blockquote><blockquote><p>branch其实只是指向一个commit的指针而已，HEAD记录了当前项目的位置。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Git深入理解&quot;&gt;&lt;a href=&quot;#Git深入理解&quot; class=&quot;headerlink&quot; title=&quot;Git深入理解&quot;&gt;&lt;/a&gt;Git深入理解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Git是我们平时团队协作必不可少的版本控制系统。这次就来深入探讨一下其中的原理。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Git" scheme="http://aeronxie.github.io/tags/Git/"/>
    
    <category term="verson" scheme="http://aeronxie.github.io/tags/verson/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Block</title>
    <link href="http://aeronxie.github.io/post/9cbe35e.html"/>
    <id>http://aeronxie.github.io/post/9cbe35e.html</id>
    <published>2017-03-26T05:30:47.000Z</published>
    <updated>2023-03-25T14:39:55.530Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>平时我们在开发中经常会用到block，那么这个block究竟是个什么东东？ 然后使用的时候需要注意什么呢？ 话不多说，直接进入正题。。。</p></blockquote><span id="more"></span><p>首先我们写下了一个这个样子的block。。。</p><pre><code>int main(int argc, const char * argv[]) &#123;            @autoreleasepool &#123;            void (^testBlock)(NSString *) = ^ (NSString *str) &#123;            NSLog(@&quot;----%@----&quot;,str);        &#125;;        testBlock(@&quot;hello world!&quot;);    &#125;    return 0;&#125;</code></pre><p>然后为了探究其原理，我们使用 <code>clang -rewrite-objc main.m</code> 就会看到一个同名的<code>cpp</code>文件，这个就是我们通过Clang（LLVM编译器）将OC的代码转换成了C++源码。</p><p>额。。打开这个文件。。。WTF？？ 一共9w多行代码。。。这都是些什么玩意。。细看都是一堆结构体和方法。。继续往下找重点。。。咦，发现我们的main函数的内容被转换成了这个样子：</p><pre><code>int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123;      __AtAutoreleasePool __autoreleasepool;     void (*testBlock)(NSString *) = ((void (*)(NSString *))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));      ((void (*)(__block_impl *, NSString *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock, (NSString *)&amp;__NSConstantStringImpl__var_folders_q1_yw_3n1px5bb6019pv_7gmtb00000gn_T_main_b79bfb_mi_1);          &#125;    return 0;&#125;</code></pre><p>我们写的block和block的调用最后被转换成了这个样子。。我们试着搜索被转后的东东。。然后我们发现了这么些结构体</p><pre><code>struct __main_block_impl_0 &#123;      struct __block_impl impl;      struct __main_block_desc_0* Desc;      __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;        impl.isa = &amp;_NSConcreteStackBlock;        impl.Flags = flags;        impl.FuncPtr = fp;        Desc = desc;      &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself, NSString *str) &#123;       NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_q1_yw_3n1px5bb6019pv_7gmtb00000gn_T_main_b79bfb_mi_0,str);    &#125;</code></pre><p>这是一个看似很普通到结构体，然后我们分别找到内部的结构体。</p><pre><code>#define BLOCK_IMPLstruct __block_impl &#123;      void *isa;     // 指向所属类的指针      int Flags;     // 标志变量      int Reserved;  // 是否保留变量      void *FuncPtr; // block执行时调用的函数指针&#125;;static struct __main_block_desc_0 &#123;      size_t reserved;    // 保留字段      size_t Block_size;  // block的大小&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</code></pre><p>不难发现<code>__main_block_impl_0</code>就是block的一个C++的实现,后面的零代表的是main中的第几个block。 <code>__block_impl</code> 也有isa指针，说明block也是一个对象。可以看出：</p><ul><li>__main_block_impl_0的isa指针指向了_NSConcreteStackBlock，</li><li>__main_block_impl_0的FuncPtr指向了函数__main_block_func_0</li><li>__main_block_impl_0的Desc也指向了定义__main_block_desc_0时就创建的__main_block_desc_0_DATA，其中纪录了block结构体大小等信息。</li></ul><p>我们再来看下OC对block的实现：<br>可以从<a href="https://opensource.apple.com/source/libclosure/libclosure-38/">opensource.apple</a>中的 <code>Block_private.h</code>中看到这样的结构体:</p><pre><code>struct Block_layout &#123;    void *isa;    int flags;    int reserved;     void (*invoke)(void *, ...);    struct Block_descriptor *descriptor;    // imported variables&#125;; // revised new layoutstruct Block_descriptor &#123;    unsigned long int reserved;    unsigned long int size;    void (*copy)(void *dst, void *src);    void (*dispose)(void *);&#125;;</code></pre><p>发现跟用clang命令（LLVM）处理的结果差不太多，只是稍微的有些不同：</p><pre><code>* invoke，跟上文的FuncPtr一样，block执行时调用的函数指针，block定义时内部的执行代码都在这个函数中* Block_descriptor，block的详细描述    copy/dispose，拷贝函数/销毁函数，处理block范围外的变量时使用</code></pre><h6 id="总体来说，block就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。"><a href="#总体来说，block就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。" class="headerlink" title="总体来说，block就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。"></a>总体来说，block就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。</h6><h3 id="常见的block类型"><a href="#常见的block类型" class="headerlink" title="常见的block类型"></a>常见的block类型</h3><p>我们从<a href="https://opensource.apple.com/source/libclosure/libclosure-38/data.c.auto.html">data.c</a> 文件中找到了这几种block，不过前三种只是在GC环境下使用：</p><ul><li><p>_NSConcreteFinalizingBlock </p></li><li><p>_NSConcreteAutoBlock</p></li><li><p>_NSConcreteWeakBlockVariable</p></li><li><p>_NSConcreteGlobalBlock（全局）</p></li><li><p>_NSConcreteStackBlock（栈）</p></li><li><p>_NSConcreteMallocBlock（堆）</p></li></ul><h6 id="为了探究为什么在block中，有些变量可以直接修改而有一些需要加上-block之后才可以修改，我们又写了一段这样的代码："><a href="#为了探究为什么在block中，有些变量可以直接修改而有一些需要加上-block之后才可以修改，我们又写了一段这样的代码：" class="headerlink" title="为了探究为什么在block中，有些变量可以直接修改而有一些需要加上__block之后才可以修改，我们又写了一段这样的代码："></a>为了探究为什么在block中，有些变量可以直接修改而有一些需要加上__block之后才可以修改，我们又写了一段这样的代码：</h6><pre><code>int globalVal = 0;static int staticGlobalVal = 0;int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;            int autoVal = 0;        static int staticVal = 0;            void (^testBlock)() = ^ () &#123;            globalVal++;            staticGlobalVal++;            //autoVal++;            staticVal++;            NSLog(@&quot;----%d----%d----%d----%d----&quot;,globalVal,staticGlobalVal,autoVal,staticVal);        &#125;;            testBlock();    &#125;    return 0;&#125;</code></pre><p>我们继续用clang命令进行解析，得到如下代码：</p><pre><code>static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;      int *staticVal = __cself-&gt;staticVal; // bound by copy      int autoVal = __cself-&gt;autoVal; // bound by copy       globalVal++;       staticGlobalVal++;    (*staticVal)++;       NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_q1_yw_3n1px5bb6019pv_7gmtb00000gn_T_main_95d0b8_mi_0,globalVal,staticGlobalVal,autoVal,(*staticVal));  &#125;  </code></pre><blockquote><p>首先，我们可以看到，全局变量和静态全局变量的值自增，这个我们不难理解，因为这两个变量是在全局数据存储区，由于作用域很大，block捕获它们进去之后，就会进行自增的操作，Block结束之后，它们的值依旧可以得以保存下来。接下来我们再看自动变量和静态变量</p></blockquote><pre><code>__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_staticVal, int _autoVal, int flags=0) : staticVal(_staticVal), autoVal(_autoVal) &#123;    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  &#125;  </code></pre><blockquote><p>这个构造函数中，自动变量和静态变量被捕获为成员变量追加到了构造函数中。但是我们从编译器的注释（bound by copy）来看，静态变量和自动变量都被block捕获进来了，但是自动变量是用<code>__cself-&gt;autoVal</code>来访问的，也就是说block只捕获了自动变量的值，并没有捕获它的内存地址，所以我们通常无法在block中直接改变它外部的值，而静态变量是捕获到了它的内存地址，我们可以直接修改它的值.</p></blockquote><h4 id="总结，自动变量是以值传递方式传递到Block的构造函数里面去的，Block只捕获Block中会用到的变量。由于只捕获了自动变量的值，而不是内存地址，所以Block内部不能改变自动变量的值。而全局变量，全局静态变量存储在全局区，作用域大，所以可以直接修改；静态变量传递给block的是内存地址，所以也可以修改。也就是说，可以修改block变量值有两种方式，一是传递内存地址，二是改变变量存储区域。"><a href="#总结，自动变量是以值传递方式传递到Block的构造函数里面去的，Block只捕获Block中会用到的变量。由于只捕获了自动变量的值，而不是内存地址，所以Block内部不能改变自动变量的值。而全局变量，全局静态变量存储在全局区，作用域大，所以可以直接修改；静态变量传递给block的是内存地址，所以也可以修改。也就是说，可以修改block变量值有两种方式，一是传递内存地址，二是改变变量存储区域。" class="headerlink" title="总结，自动变量是以值传递方式传递到Block的构造函数里面去的，Block只捕获Block中会用到的变量。由于只捕获了自动变量的值，而不是内存地址，所以Block内部不能改变自动变量的值。而全局变量，全局静态变量存储在全局区，作用域大，所以可以直接修改；静态变量传递给block的是内存地址，所以也可以修改。也就是说，可以修改block变量值有两种方式，一是传递内存地址，二是改变变量存储区域。"></a>总结，自动变量是以值传递方式传递到Block的构造函数里面去的，Block只捕获Block中会用到的变量。由于只捕获了自动变量的值，而不是内存地址，所以Block内部不能改变自动变量的值。而全局变量，全局静态变量存储在全局区，作用域大，所以可以直接修改；静态变量传递给block的是内存地址，所以也可以修改。也就是说，可以修改block变量值有两种方式，一是传递内存地址，二是改变变量存储区域。</h4><p>而我们可以通过加<code>__block</code>关键字来改变其修饰的变量，我们接着而看代码：</p><pre><code>struct __Block_byref_autoVal_0 &#123;      void *__isa;                 // 指向自身的类    __Block_byref_autoVal_0 *__forwarding;  // 指向自身类型的__forwarding指针     int __flags;            // 标记     int __size;            // 大小     int autoVal;        // 变量名&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;      __Block_byref_autoVal_0 *autoVal = __cself-&gt;autoVal; // bound by ref      int *staticVal = __cself-&gt;staticVal; // bound by copy       globalVal++;       staticGlobalVal++;       (autoVal-&gt;__forwarding-&gt;autoVal)++;       (*staticVal)++;       NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_q1_yw_3n1px5bb6019pv_7gmtb00000gn_T_main_c2f928_mi_0,globalVal,staticGlobalVal,(autoVal-&gt;__forwarding-&gt;autoVal),(*staticVal));  &#125;  </code></pre><p>我们可以看出，带有 __block修饰的变量也被转化成了一个结构体<code>__Block_byref_i_0</code>，__forwarding指针初始化传递的是自己的地址。最后，带__block修饰的自动变量 和 静态变量 就是直接地址访问，所以在Block里面可以直接改变变量的值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;平时我们在开发中经常会用到block，那么这个block究竟是个什么东东？ 然后使用的时候需要注意什么呢？ 话不多说，直接进入正题。。。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Objective-C" scheme="http://aeronxie.github.io/tags/Objective-C/"/>
    
    <category term="Block" scheme="http://aeronxie.github.io/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Runtime的核心 objc_msgSend 函数</title>
    <link href="http://aeronxie.github.io/post/bf9a09e9.html"/>
    <id>http://aeronxie.github.io/post/bf9a09e9.html</id>
    <published>2017-03-07T01:39:44.000Z</published>
    <updated>2023-03-25T14:39:55.812Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在OC中，所有的方法调用其实都是通过消息传递机制来查询且执行方法，而且在编译期间，是不知道谁调用谁的，都是在运行时才确定调用对象，而消息传递的核心则是<code>objc_msgSend</code>函数，下面我们就开始研究下<code>objc_msgSend</code></p></blockquote><span id="more"></span><p>我们在开发的时候最常见的就是方法的调用了，但是在OC中我们一般都看到函数调用这个样子的 <code>[receiver hello:@&quot;word&quot;]</code>, 但是这个方法会被编译器转换成 <code>objc_msgSend(receiver,@selector(hello:),@&quot;word&quot;)</code></p><p>我们来看下<code>id objc_msgSend(id self, SEL op, ...)</code>这个函数，它其实主要做了下面三件事情：</p><ul><li>检测这个 selector是不是要忽略的。</li><li>检查target是不是为nil。（如果这里有相应的nil的处理函数，就跳转到相应的函数中。如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因）</li><li>确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。（如果找到，就跳转进去执行。如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止。）</li></ul><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/1194012-071da64373b4f5f9.png"></p><ul><li>如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过select()快速查找IMP的过程。</li></ul><p>我们在<code>objc4-706中的objc-msg-x86_64.s</code> 中找到这么一段汇编代码：</p><pre><code>/******************************************************************** * * id objc_msgSend(id self, SEL    _cmd,...); * IMP objc_msgLookup(id self, SEL _cmd, ...); * * objc_msgLookup ABI: * IMP returned in r11 * Forwarding returned in Z flag * r10 reserved for our use but not used * ********************************************************************/    .data    .align 3    .globl _objc_debug_taggedpointer_classes_objc_debug_taggedpointer_classes:    .fill 16, 8, 0    .globl _objc_debug_taggedpointer_ext_classes_objc_debug_taggedpointer_ext_classes:    .fill 256, 8, 0    ENTRY _objc_msgSend    UNWIND _objc_msgSend, NoFrame    MESSENGER_START    NilTest    NORMAL    GetIsaFast NORMAL        // r10 = self-&gt;isa    CacheLookup NORMAL, CALL    // calls IMP on success    NilTestReturnZero NORMAL    GetIsaSupport NORMAL// cache miss: go search the method listsLCacheMiss:    // isa still in r10    MESSENGER_END_SLOW    jmp    __objc_msgSend_uncached    END_ENTRY _objc_msgSend    ENTRY _objc_msgLookup    NilTest    NORMAL    GetIsaFast NORMAL        // r10 = self-&gt;isa    CacheLookup NORMAL, LOOKUP    // returns IMP on success    NilTestReturnIMP NORMAL    GetIsaSupport NORMAL// cache miss: go search the method listsLCacheMiss:    // isa still in r10    jmp    __objc_msgLookup_uncached    END_ENTRY _objc_msgLookup    ENTRY _objc_msgSend_fixup    int3    END_ENTRY _objc_msgSend_fixup    STATIC_ENTRY _objc_msgSend_fixedup    // Load _cmd from the message_ref    movq    8(%a2), %a2    jmp    _objc_msgSend    END_ENTRY _objc_msgSend_fixedup    </code></pre><hr><pre><code>/******************************************************************** * * _objc_msgSend_uncached * _objc_msgSend_stret_uncached * _objc_msgLookup_uncached * _objc_msgLookup_stret_uncached * * The uncached method lookup. *********************************************************************/STATIC_ENTRY __objc_msgSend_uncachedUNWIND __objc_msgSend_uncached, FrameWithNoSaves// THIS IS NOT A CALLABLE C FUNCTION// Out-of-band r10 is the searched class// r10 is already the class to searchMethodTableLookup NORMAL    // r11 = IMPjmp    *%r11            // goto *impEND_ENTRY __objc_msgSend_uncachedSTATIC_ENTRY __objc_msgSend_stret_uncachedUNWIND __objc_msgSend_stret_uncached, FrameWithNoSaves// THIS IS NOT A CALLABLE C FUNCTION// Out-of-band r10 is the searched class// r10 is already the class to searchMethodTableLookup STRET        // r11 = IMPjmp    *%r11            // goto *impEND_ENTRY __objc_msgSend_stret_uncachedSTATIC_ENTRY __objc_msgLookup_uncachedUNWIND __objc_msgLookup_uncached, FrameWithNoSaves// THIS IS NOT A CALLABLE C FUNCTION// Out-of-band r10 is the searched class// r10 is already the class to searchMethodTableLookup NORMAL    // r11 = IMPretEND_ENTRY __objc_msgLookup_uncachedSTATIC_ENTRY __objc_msgLookup_stret_uncachedUNWIND __objc_msgLookup_stret_uncached, FrameWithNoSaves// THIS IS NOT A CALLABLE C FUNCTION// Out-of-band r10 is the searched class// r10 is already the class to searchMethodTableLookup STRET        // r11 = IMPretEND_ENTRY __objc_msgLookup_stret_uncached</code></pre><p>这两段代码无非就是做了两件事， CacheLookup 和 MethodTableLookup，有缓存的方法查找，如果cache缓存中获取失败，就从方法列表中查找</p><p>然后我们看一下查找方法的方法源码：</p><pre><code>/************************************************************************ getMethodNoSuper_nolock* fixme* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static method_t *search_method_list(const method_list_t *mlist, SEL sel) &#123;    int methodListIsFixedUp = mlist-&gt;isFixedUp();    int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t);    if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) &#123;        return findMethodInSortedMethodList(sel, mlist);    &#125; else &#123;        // Linear search of unsorted method list        for (auto&amp; meth : *mlist) &#123;            if (meth.name == sel) return &amp;meth;        &#125;    &#125;#if DEBUG    // sanity-check negative results    if (mlist-&gt;isFixedUp()) &#123;        for (auto&amp; meth : *mlist) &#123;            if (meth.name == sel) &#123;                _objc_fatal(&quot;linear search worked when binary search did not&quot;);            &#125;        &#125;    &#125;#endif    return nil;&#125;</code></pre><blockquote><p>在search_method_list函数中，会去判断当前methodList是否有序，如果有序，会调用findMethodInSortedMethodList方法，这个方法里面的实现是一个二分搜索。如果非有序，就调用线性的遍历搜索。</p></blockquote><h3 id="如果直到NSObject还没有找到方法的实现的话，就会进入下面的消息转发："><a href="#如果直到NSObject还没有找到方法的实现的话，就会进入下面的消息转发：" class="headerlink" title="如果直到NSObject还没有找到方法的实现的话，就会进入下面的消息转发："></a>如果直到NSObject还没有找到方法的实现的话，就会进入下面的消息转发：</h3><ul><li><p><code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 和 <code>+(BOOL)resolveClassMethod:(SEL)sel</code> 这一阶段我们可以为类添加方法</p><pre><code>  void dynamicMethodIMP(id self, SEL _cmd)&#123;      NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);  &#125;  + (BOOL)resolveInstanceMethod:(SEL)sel&#123;          if (sel == @selector(hello)) &#123;              class_addMethod([self class], sel, (IMP)dynamicMethodIMP, &quot;V@:&quot;);          return YES;      &#125;      return [super resolveInstanceMethod:sel];  &#125;</code></pre></li><li><p><code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 这一步可以换一个消息接受者处理消息</p><pre><code>  - (id)forwardingTargetForSelector:(SEL)aSelector &#123;          if(aSelector == @selector(Method:))&#123;              return otherObject;      &#125;      return [super forwardingTargetForSelector:aSelector];  &#125;</code></pre></li></ul><p> 如果以上两步还未处理消息，就只能启用完整的消息转发机制了</p><ul><li><code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code> 运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息 有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation 方法中选择将消息转发给其它对象。还有一个很重要的问题，我们必须重写以下方法：<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></li></ul><pre><code>    - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;        NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];        if (!signature) &#123;            if ([SomeObject instancesRespondToSelector:aSelector]) &#123;                signature = [SomeObject instanceMethodSignatureForSelector:aSelector];            &#125;        &#125;        return signature;    &#125;    - (void)forwardInvocation:(NSInvocation *)anInvocation &#123;        if ([SomeObject instancesRespondToSelector:anInvocation.selector]) &#123;            [anInvocation invokeWithTarget: SomeObject];        &#125; else &#123;            [super forwardInvocation:anInvocation];        &#125;    &#125;</code></pre><h6 id="我们来看一下消息发送和转发的过程："><a href="#我们来看一下消息发送和转发的过程：" class="headerlink" title="我们来看一下消息发送和转发的过程："></a>我们来看一下消息发送和转发的过程：</h6><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/1194012-e96387802506ea96.png"></p><h3 id="研究完了消息转发，我们会有一个问题，为什么objc-msgSend必须用汇编实现，而不是C-C-或者Objective-C-？"><a href="#研究完了消息转发，我们会有一个问题，为什么objc-msgSend必须用汇编实现，而不是C-C-或者Objective-C-？" class="headerlink" title="研究完了消息转发，我们会有一个问题，为什么objc_msgSend必须用汇编实现，而不是C/C++或者Objective-C ？"></a>研究完了消息转发，我们会有一个问题，为什么objc_msgSend必须用汇编实现，而不是C/C++或者Objective-C ？</h3><p>我们先来看下两行代码:</p><pre><code>    NSUInteger length = [string length];    NSString   *str = [string substringFromIndex:2]; </code></pre><p>将会被编译器翻译成:</p><pre><code>    NSUInteger length = objc_msgSend(string,  @selector(length));    NSString   *str = objc_msgSend(string, @selector(substringFromIndex:), 2);        </code></pre><p>但是实际上这是不可能的，因为没有函数可以同时满足这两个调用。而且它的返回值也不能同时是NSUInteger和NSString。</p><p>而且，上面的代码也是无法编译通过的。那么，加上类型转换怎么样？</p><pre><code>    NSUInteger length = ((NSUInteger (*)(id, SEL))objc_msgSend)(string,  @selector(length));    NSString   *str = ((NSString *(*)(NSString *, SEL, NSUInteger))objc_msgSend)(string, @selector(substringFromIndex:), 2);            </code></pre><p>这下可以编译通过了,objc_msgSend是一个Public的函数，在&lt;objc/message.h&gt;里声明，如果你想直接调用它，就必须按照上面的格式加上强制类型转换，要不然是无法编译通过的。但是objc_msgSend到底是如何实现，来支持各种返回类型的？</p><h3 id="参数类型和数量"><a href="#参数类型和数量" class="headerlink" title="- 参数类型和数量"></a>- 参数类型和数量</h3><p>当objc_msgSend找到对应的函数指针后，只要用传入的参数调用这个函数即可。剩下来的就是找到一种方法，可以调用任意参数类型、数量的任意函数。</p><p>参数的数量很容易计算。然后我们可以把所有的参数都放入varargs，然后调用函数时传入即可。但是这样的话，每个Objective-C的方法都必须在其prologue（译者注：函数执行具体的“任务”前，所做的准备环节）里面把所有的参数从varargs里面提取出来。这种把参数打包到varargs里面然后又取出来的办法显然是非常糟糕的，同时也是不必要的。    </p><p>在C语言中，调用一个函数会被编译成对应的汇编语言指令，首先是设置参数（把参数放到寄存器、栈上），然后用如jump或者call的指令，跳到具体的函数代码地址处。如果我们想支持任意类型的函数类型，我们就必须写一个switch语句，把所有的参数组合情况都包含起来，这样才能正确的为任何形式的函数设置参数（译者注：即按照某种“规范”、“约定”，把参数依次存放到“约定”的寄存器、栈上），这显然是没有扩展性的，更是不可能的。    </p><h3 id="拆解调用"><a href="#拆解调用" class="headerlink" title="- 拆解调用"></a>- 拆解调用</h3><p><code>objc_msgSend</code>的解决办法，主要依据的是：当objc_msgSend被调用时，所有的参数已经被设置好了。</p><p>换一种方式来说，就是：在objc_msgSend开始执行时，栈帧（stack frame）的状态、数据，和各个寄存器的组合形式、数据，跟调用具体的函数指针（IMP）时所需的状态、数据，是完全一致的！</p><p>如下这行代码：</p><pre><code>    NSString   *str = ((NSString *(*)(NSString *, SEL, NSUInteger))objc_msgSend)(string, @selector(substringFromIndex:), 2);                </code></pre><p>在调用objc_msgSend时，需要设置三个参数，分别是被调用方receiver、方法名selector和最后一个整型参数2。这和具体的方法函数IMP的参数顺序、类型是完全一致的，也就是说，调用objc_msgSend前，设置的栈、寄存器的状态、数据正是调用具体的方法函数时需要的状态！</p><p>所以，当objc_msgSend找到要调用的函数实现IMP后，只需要把所有的对栈、寄存器的操作“倒”回到objc_msgSend执行开始的状态（类似于函数执行完成return返回前，做的“收尾处理”工作一样，即epilogue），直接jump/call到IMP函数指针对应的地址，执行指令即可，因为所有的参数已经被设置好了。</p><p>同时，当selector对应的IMP执行完成后，返回值也被正确的设置好了（在x86平台上，返回值被设置到了指定的寄存器eax/rax里，在arm上，则是r0寄存器），所以，我们也不必担心前文提到的不同类型的返回值问题了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="- 总结"></a>- 总结</h3><p>在C语言里面调用函数，必须在编译时就知道调用的“状态”；而这些“状态”在运行时是无法得出或正确处理的，所以必须往底层走，用汇编处理。有人指出<code>objc_msgSend</code>有可能是用GCC的扩展方法<code>__builtin_apply_args，__builtin_apply，和__builtin_return</code>实现的。这也正指出了一个事实，就是这些builtins方法是非常有必要的，因为单靠语言本身无法实现这些功能。实现<code>objc_msgSend</code>所需要的技巧，也正是实现这些builtins方法所需要的技巧。    </p><p>用汇编实现，是为了应对不同的<a href="https://en.wikipedia.org/wiki/Calling_convention">“Calling convention”</a>，把函数调用前的栈和寄存器的参数、状态设置，交给编译器去处理。    </p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在OC中，所有的方法调用其实都是通过消息传递机制来查询且执行方法，而且在编译期间，是不知道谁调用谁的，都是在运行时才确定调用对象，而消息传递的核心则是&lt;code&gt;objc_msgSend&lt;/code&gt;函数，下面我们就开始研究下&lt;code&gt;objc_msgSend&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Runtime" scheme="http://aeronxie.github.io/tags/Runtime/"/>
    
    <category term="Objc" scheme="http://aeronxie.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>Runtime源码阅读笔记</title>
    <link href="http://aeronxie.github.io/post/c3cade62.html"/>
    <id>http://aeronxie.github.io/post/c3cade62.html</id>
    <published>2017-03-06T04:55:45.000Z</published>
    <updated>2023-03-25T14:39:55.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Objective-C Runtime是一个Runtime库，基本上是用C和汇编完成的，使C具有了面向对象的能力。这也使得Objective-C语言成为了一个动态语言。</p></blockquote><span id="more"></span><h6 id="这动态语言和传统的面向过程语言-C语言-、面向对象语言-C-OOP-有比较大的区别：函数调用在编译期不能确定内存地址，只有到了运行时才能做出跳转。也决定了Objective-C语言将-决定-尽可能的从编译和链接时推迟到运行时。并且只要有可能，Objective-C总是用动态的方式来解决问题。Objective-C是基于Runtime完成了面向对象和动态的特性，这里Runtime系统扮演的角色类似于Objective-C语言的操作系统。"><a href="#这动态语言和传统的面向过程语言-C语言-、面向对象语言-C-OOP-有比较大的区别：函数调用在编译期不能确定内存地址，只有到了运行时才能做出跳转。也决定了Objective-C语言将-决定-尽可能的从编译和链接时推迟到运行时。并且只要有可能，Objective-C总是用动态的方式来解决问题。Objective-C是基于Runtime完成了面向对象和动态的特性，这里Runtime系统扮演的角色类似于Objective-C语言的操作系统。" class="headerlink" title="这动态语言和传统的面向过程语言(C语言)、面向对象语言(C++, OOP)有比较大的区别：函数调用在编译期不能确定内存地址，只有到了运行时才能做出跳转。也决定了Objective-C语言将 决定 尽可能的从编译和链接时推迟到运行时。并且只要有可能，Objective-C总是用动态的方式来解决问题。Objective-C是基于Runtime完成了面向对象和动态的特性，这里Runtime系统扮演的角色类似于Objective-C语言的操作系统。"></a>这动态语言和传统的面向过程语言(C语言)、面向对象语言(C++, OOP)有比较大的区别：函数调用在编译期不能确定内存地址，只有到了运行时才能做出跳转。也决定了Objective-C语言将 决定 尽可能的从编译和链接时推迟到运行时。并且只要有可能，Objective-C总是用动态的方式来解决问题。Objective-C是基于Runtime完成了面向对象和动态的特性，这里Runtime系统扮演的角色类似于Objective-C语言的操作系统。</h6><h4 id="Runtime库是开源的，所以我们可以在这里下载源码-LZ-用的是最新的-objc4-706-这个版本-废话不多说，下面开始进入源码分析-我们可以看到源码的目录大概是这么个结构："><a href="#Runtime库是开源的，所以我们可以在这里下载源码-LZ-用的是最新的-objc4-706-这个版本-废话不多说，下面开始进入源码分析-我们可以看到源码的目录大概是这么个结构：" class="headerlink" title="Runtime库是开源的，所以我们可以在这里下载源码,LZ 用的是最新的 objc4-706 这个版本. 废话不多说，下面开始进入源码分析~~我们可以看到源码的目录大概是这么个结构："></a>Runtime库是开源的，所以我们可以在<a href="https://opensource.apple.com/tarballs/objc4/">这里</a>下载源码,LZ 用的是最新的 <code>objc4-706</code> 这个版本. 废话不多说，下面开始进入源码分析~~我们可以看到源码的目录大概是这么个结构：</h4><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/runtime1.png"><br><img src="http://7xoijj.com1.z0.glb.clouddn.com/runtime2.png"><br><img src="http://7xoijj.com1.z0.glb.clouddn.com/runtime3.png"></p><h6 id="我们点开-NSObject-h文件，首先会看到一个-叫NSObject的协议。这个协议里有这么些方法"><a href="#我们点开-NSObject-h文件，首先会看到一个-叫NSObject的协议。这个协议里有这么些方法" class="headerlink" title="我们点开 NSObject.h文件，首先会看到一个 叫NSObject的协议。这个协议里有这么些方法"></a>我们点开 <code>NSObject.h</code>文件，首先会看到一个 叫<code>NSObject</code>的协议。这个协议里有这么些方法</h6><pre><code>@property (readonly) NSUInteger hash;@property (readonly) Class superclass;@property (readonly, copy) NSString *description;    @property (readonly, copy) NSString *debugDescription;- (BOOL)isEqual:(id)object;- (Class)class;- (instancetype)self;- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;- (BOOL)isProxy;- (BOOL)isKindOfClass:(Class)aClass;- (BOOL)isMemberOfClass:(Class)aClass;- (BOOL)conformsToProtocol:(Protocol *)aProtocol;- (BOOL)respondsToSelector:(SEL)aSelector;    - (instancetype)retain OBJC_ARC_UNAVAILABLE;- (oneway void)release OBJC_ARC_UNAVAILABLE;- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;- (struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</code></pre><h6 id="这些方法其实都是平时我们在开发时使用到的方法以及属性，主要都是一些用于自我检查、消息传递的一些方法，还有就是用于内存管理的方法，不过在ARC情况下，都不需要用到。由于这些方法都写在了NSObject协议里，而我们所有的类也都是继承自-NSObject-（除了NSProxy），而-NSObject-则是实现了-NSObject-协议，也就是说，继承自NSObject的对象都可以使用到这些方法。"><a href="#这些方法其实都是平时我们在开发时使用到的方法以及属性，主要都是一些用于自我检查、消息传递的一些方法，还有就是用于内存管理的方法，不过在ARC情况下，都不需要用到。由于这些方法都写在了NSObject协议里，而我们所有的类也都是继承自-NSObject-（除了NSProxy），而-NSObject-则是实现了-NSObject-协议，也就是说，继承自NSObject的对象都可以使用到这些方法。" class="headerlink" title="这些方法其实都是平时我们在开发时使用到的方法以及属性，主要都是一些用于自我检查、消息传递的一些方法，还有就是用于内存管理的方法，不过在ARC情况下，都不需要用到。由于这些方法都写在了NSObject协议里，而我们所有的类也都是继承自 NSObject （除了NSProxy），而 NSObject 则是实现了 NSObject 协议，也就是说，继承自NSObject的对象都可以使用到这些方法。"></a>这些方法其实都是平时我们在开发时使用到的方法以及属性，主要都是一些用于自我检查、消息传递的一些方法，还有就是用于内存管理的方法，不过在ARC情况下，都不需要用到。由于这些方法都写在了<code>NSObject</code>协议里，而我们所有的类也都是继承自 <code>NSObject</code> （除了NSProxy），而 <code>NSObject </code>则是实现了 <code>NSObject </code>协议，也就是说，继承自<code>NSObject</code>的对象都可以使用到这些方法。</h6><h4 id="接着我们着重分析下下面四个方法："><a href="#接着我们着重分析下下面四个方法：" class="headerlink" title="接着我们着重分析下下面四个方法："></a>接着我们着重分析下下面四个方法：</h4><pre><code>- (BOOL)isKindOfClass:(Class)aClass;- (BOOL)isMemberOfClass:(Class)aClass;+ (BOOL)isKindOfClass:(Class)aClass;+ (BOOL)isMemberOfClass:(Class)aClass;</code></pre><p>我们查看下方法的源码:</p><pre><code>- (BOOL)isKindOfClass:(Class)cls &#123;    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;        if (tcls == cls) return YES;    &#125;    return NO;&#125;+ (BOOL)isKindOfClass:(Class)cls &#123;    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;        if (tcls == cls) return YES;    &#125;    return NO;&#125;Class object_getClass(id obj) &#123;    if (obj) return obj-&gt;getIsa();    else return Nil;&#125;inline Class objc_object::getIsa() &#123;    return ISA();&#125;inline Class objc_object::ISA() &#123;    assert(!isTaggedPointer());           return isa.cls;&#125;</code></pre><blockquote><p><code>+ (BOOL)isKindOfClass:(Class)cls</code> 内部会先去获得<code>object_getClas</code>s的类，而<code>object_getClass</code>的源码实现是去调用当前类的<code>obj-&gt;getIsa()</code>，最后在<code>ISA()</code>方法中获得<code>meta class</code>的指针。接着在isKindOfClass中有一个循环，先判断class是否等于meta class，不等就继续循环判断是否等于super class，不等再继续取super class，如此循环下去。</p></blockquote><blockquote><p>判断两个class是不是相等的步骤大概是这样的：某类的Meta Class与某类是不是相等，如果不等则判断某类的 Meta Class的super class， 指向的是 NSObject Meta Class， 和某类相比，如果不相等，则继续，NSObject Meta Class的super class指向的是NSObject Class，和 某类相比还 不相等，则继续进行比较，NSObject Class 的super class 指向 nil， 和 某类不相等，则退出循环。</p></blockquote><pre><code>+ (BOOL)isMemberOfClass:(Class)cls &#123;    return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123;    return [self class] == cls;&#125;</code></pre><blockquote><p>isMemberOfClass的源码实现是拿到自己的isa指针和自己比较，是否相等。<br>第二行isa 指向 NSObject 的 Meta Class，所以和 NSObject Class不相等,isa指向某类的Meta Class，和某类也不等</p></blockquote><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-06%2012.46.55.png"></p><h4 id="我们在来看看NSObject这个类，"><a href="#我们在来看看NSObject这个类，" class="headerlink" title="我们在来看看NSObject这个类，"></a>我们在来看看<code>NSObject</code>这个类，</h4><pre><code>+ (instancetype)new;+ (instancetype)allocWithZone:(struct _NSZone *)zone;+ (instancetype)alloc;- (void)dealloc;- (void)finalize;- (id)copy;- (id)mutableCopy;+ (BOOL)instancesRespondToSelector:(SEL)aSelector;+ (BOOL)conformsToProtocol:(Protocol *)protocol;- (IMP)methodForSelector:(SEL)aSelector;+ (IMP)instanceMethodForSelector:(SEL)aSelector;- (void)doesNotRecognizeSelector:(SEL)aSelector;- (id)forwardingTargetForSelector:(SEL)aSelector ;- (void)forwardInvocation:(NSInvocation *)anInvocation;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector;+ (BOOL)isSubclassOfClass:(Class)aClass;+ (BOOL)resolveClassMethod:(SEL)sel;+ (BOOL)resolveInstanceMethod:(SEL)sel;</code></pre><h6 id="这个类除了提供了对象的创建方法之外，还有一些用于消息转发处理的的方法。"><a href="#这个类除了提供了对象的创建方法之外，还有一些用于消息转发处理的的方法。" class="headerlink" title="这个类除了提供了对象的创建方法之外，还有一些用于消息转发处理的的方法。"></a>这个类除了提供了对象的创建方法之外，还有一些用于消息转发处理的的方法。</h6><h6 id="我们打开-objc-h这个文件会看到-NSObject类有这个一个成员变量"><a href="#我们打开-objc-h这个文件会看到-NSObject类有这个一个成员变量" class="headerlink" title="我们打开 objc.h这个文件会看到 NSObject类有这个一个成员变量"></a>我们打开 <code>objc.h</code>这个文件会看到 <code>NSObject</code>类有这个一个成员变量</h6><pre><code>typedef struct objc_class *Class;struct objc_object &#123;    Class isa  OBJC_ISA_AVAILABILITY;&#125;;</code></pre><p>在Objc2.0之前，objc_class源码如下：</p><pre><code>typedef struct objc_method *Method;    typedef struct objc_ivar *Ivar;typedef struct objc_category *Category;typedef struct objc_property *objc_property_t;struct objc_class &#123;    Class isa  OBJC_ISA_AVAILABILITY;#if !__OBJC2__    Class super_class                                            const char *name                                             long version                                                 long info                                                    long instance_size                                           struct objc_ivar_list *ivars      struct objc_method_list **methodLists                        struct objc_cache *cache                                     struct objc_protocol_list *protocols                     #endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */</code></pre><p>在这里可以看到，在一个类中，有超类的指针，类名，版本的信息。<br>ivars是objc_ivar_list成员变量列表的指针；methodLists是指向objc_method_list指针的指针。*methodLists是指向方法列表的指针。这里如果动态修改 *methodLists的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。</p><h4 id="然后在2006年苹果发布Objc-2-0之后，objc-class的定义就变成下面这个样子了"><a href="#然后在2006年苹果发布Objc-2-0之后，objc-class的定义就变成下面这个样子了" class="headerlink" title="然后在2006年苹果发布Objc 2.0之后，objc_class的定义就变成下面这个样子了:"></a>然后在2006年苹果发布Objc 2.0之后，objc_class的定义就变成下面这个样子了:</h4><pre><code>typedef struct objc_class *Class;typedef struct objc_object *id;@interface NSObject &lt;NSObject&gt; &#123;    Class isa  OBJC_ISA_AVAILABILITY;&#125;struct objc_object &#123;private:       isa_t isa;&#125;struct objc_class : objc_object &#123;    Class superclass;    cache_t cache;    class_data_bits_t bits;    &#125;union isa_t &#123;    isa_t() &#123; &#125;    isa_t(uintptr_t value) : bits(value) &#123; &#125;    Class cls;    uintptr_t bits;&#125;</code></pre><blockquote><p>从上述源码中，我们可以看到，Objective-C 对象都是 C 语言结构体实现的，在objc2.0中，所有的对象都会包含一个isa_t类型的结构体。</p></blockquote><p>objc_object被源码typedef成了id类型，这也就是我们平时遇到的id类型。这个结构体中就只包含了一个isa_t类型的结构体。objc_class继承于objc_object。所以在objc_class中也会包含isa_t类型的结构体isa。<br><code>可以得出结论：Objective-C 中类也是一个对象。</code> 在objc_class中，除了isa之外，还有3个成员变量，一个是父类的指针，一个是方法缓存，最后一个这个类的实例方法链表。</p><p>当一个对象的实例方法被调用的时候，会通过isa找到相应的类，然后在该类的class_data_bits_t中去查找方法。class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。</p><blockquote><p>但是在我们调用类方法的时候，类对象的isa里面是什么呢？<br>这里为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。</p></blockquote><p>在引入元类之后，类对象和对象查找方法的机制就完全统一了。</p><p>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。<br>类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</p><p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/metaclass.png"></p><h3 id="PS-图中实线是-super-class指针，虚线是isa指针"><a href="#PS-图中实线是-super-class指针，虚线是isa指针" class="headerlink" title="PS:图中实线是 super_class指针，虚线是isa指针"></a>PS:图中实线是 super_class指针，虚线是isa指针</h3><h4 id="接下来我们来研究下-isa-t-结构体的具体实现"><a href="#接下来我们来研究下-isa-t-结构体的具体实现" class="headerlink" title="接下来我们来研究下 isa_t 结构体的具体实现"></a>接下来我们来研究下 <code>isa_t</code> 结构体的具体实现</h4><pre><code>union isa_t  &#123;    isa_t() &#123; &#125;    isa_t(uintptr_t value) : bits(value) &#123; &#125;    Class cls;    uintptr_t bits;#if SUPPORT_PACKED_ISA# if __arm64__#   define ISA_MASK        0x0000000ffffffff8ULL#   define ISA_MAGIC_MASK  0x000003f000000001ULL#   define ISA_MAGIC_VALUE 0x000001a000000001ULLstruct &#123;    uintptr_t nonpointer        : 1;    uintptr_t has_assoc         : 1;    uintptr_t has_cxx_dtor      : 1;    uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000    uintptr_t magic             : 6;    uintptr_t weakly_referenced : 1;    uintptr_t deallocating      : 1;    uintptr_t has_sidetable_rc  : 1;    uintptr_t extra_rc          : 19;#       define RC_ONE   (1ULL&lt;&lt;45)#       define RC_HALF  (1ULL&lt;&lt;18)&#125;;# elif __x86_64__#   define ISA_MASK        0x00007ffffffffff8ULL#   define ISA_MAGIC_MASK  0x001f800000000001ULL#   define ISA_MAGIC_VALUE 0x001d800000000001ULLstruct &#123;    uintptr_t nonpointer        : 1;    uintptr_t has_assoc         : 1;    uintptr_t has_cxx_dtor      : 1;    uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000    uintptr_t magic             : 6;    uintptr_t weakly_referenced : 1;    uintptr_t deallocating      : 1;    uintptr_t has_sidetable_rc  : 1;    uintptr_t extra_rc          : 8;#       define RC_ONE   (1ULL&lt;&lt;56)#       define RC_HALF  (1ULL&lt;&lt;7)&#125;;# else#   error unknown architecture for packed isa# endif// SUPPORT_PACKED_ISA#endif#if SUPPORT_INDEXED_ISA# if  __ARM_ARCH_7K__ &gt;= 2#   define ISA_INDEX_IS_NPI      1#   define ISA_INDEX_MASK        0x0001FFFC#   define ISA_INDEX_SHIFT       2#   define ISA_INDEX_BITS        15#   define ISA_INDEX_COUNT       (1 &lt;&lt; ISA_INDEX_BITS)#   define ISA_INDEX_MAGIC_MASK  0x001E0001#   define ISA_INDEX_MAGIC_VALUE 0x001C0001struct &#123;    uintptr_t nonpointer        : 1;    uintptr_t has_assoc         : 1;    uintptr_t indexcls          : 15;    uintptr_t magic             : 4;    uintptr_t has_cxx_dtor      : 1;    uintptr_t weakly_referenced : 1;    uintptr_t deallocating      : 1;    uintptr_t has_sidetable_rc  : 1;    uintptr_t extra_rc          : 7;&#125;;# else#   error unknown architecture for indexed isa# endif// SUPPORT_INDEXED_ISA#endif&#125;;</code></pre><blockquote><p>我去。。<code>isa_t</code> 是一个联合体，但是这一大坨都是什么玩意？其实用一句话概括就是 :对64位的设备对象进行类对象指针的优化，利用合理的bit（arm64设备为32位）存储类对象的地址，其他位用来进行内存管理。这种优化模式被称为<a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/">Tagged Pointer</a>。用在isa_t的实现中称作IndexedIsa.</p></blockquote><p>我们来看下每个元素都是什么意思</p><ul><li>nonpointer：标记是否启动指针优化</li><li>has_assoc：是否有关联对象</li><li>has_cxx_dtor：是否有析构器</li><li>shiftcls：类对象指针</li><li>magic：标记初始化完成</li><li>weakly_refrenced：是否弱引用</li><li>deallocating：是否正在释放</li><li>extra_rc：引用计数（但是比retaincount小1）</li><li>has_sidetable_rc：对象的引用计数太大了，存不下</li></ul><h3 id="研究完isa-t之后，我们再回过头来看-objc-object的方法"><a href="#研究完isa-t之后，我们再回过头来看-objc-object的方法" class="headerlink" title="研究完isa_t之后，我们再回过头来看 objc_object的方法 :"></a>研究完isa_t之后，我们再回过头来看 <code>objc_object</code>的方法 :</h3><pre><code>Class ISA() //不支持tagged pointer时候获取Class的函数Class getIsa() //支持tagged pointer时候获取Class的函数</code></pre><p>这些是初始化isa的一些方法：    </p><pre><code>// initIsa() should be used to init the isa of new objects only.// If this object already has an isa, use changeIsa() for correctness.// initInstanceIsa(): objects with no custom RR/AWZ// initClassIsa(): class objects// initProtocolIsa(): protocol objectsvoid initIsa(Class cls /*nonpointer=false*/);void initClassIsa(Class cls /*nonpointer=maybe*/);void initProtocolIsa(Class cls /*nonpointer=maybe*/);void initInstanceIsa(Class cls, bool hasCxxDtor);</code></pre><p>最后你会发现这些方法其实最后都是调了这么个方法：</p><pre><code>inline void objc_object::initIsa(Class cls) &#123;    assert(!isTaggedPointer());     isa = (uintptr_t)cls; &#125;</code></pre><p>这个方法可以用来改变一个对象所指向的Class</p><pre><code>Class changeIsa(Class newCls);</code></pre><p>接下来就是一些内存管理的方法：</p><pre><code>// Optimized calls to retain/release methodsid retain();void release();id autorelease();// Implementations of retain/release methodsid rootRetain();bool rootRelease();id rootAutorelease();bool rootTryRetain();bool rootReleaseShouldDealloc();uintptr_t rootRetainCount();// Implementation of dealloc methodsbool rootIsDeallocating();void clearDeallocating();void rootDealloc();</code></pre><p>看一下 <code>id retain()</code>的实现：</p><pre><code>inline id objc_object::retain() &#123;    // UseGC is allowed here, but requires hasCustomRR.    assert(!UseGC  ||  ISA()-&gt;hasCustomRR());    assert(!isTaggedPointer());    if (! ISA()-&gt;hasCustomRR()) &#123;        return rootRetain();    &#125;    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, SEL_retain);&#125;inline id objc_object::rootRetain() &#123;    if (isTaggedPointer()) return (id)this;    return sidetable_retain();&#125; id objc_object::sidetable_retain() &#123;#if SUPPORT_NONPOINTER_ISA    assert(!isa.nonpointer);#endif    SideTable&amp; table = SideTables()[this];    table.lock();    size_t&amp; refcntStorage = table.refcnts[this];    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;        refcntStorage += SIDE_TABLE_RC_ONE;    &#125;    table.unlock();   return (id)this;&#125;</code></pre><p>解释下这段函数就是：如果使用GC但是并没有custom的retain/release方法则会直接断言掉，如果支持tagged pointer就会直接断言掉。接下来的流程就是如果没有custom的retain/release方法就会调用rootRetain()。最后会调用<code>sidetable_retain ()</code>方法</p><h3 id="接下来研究cache-t的实现"><a href="#接下来研究cache-t的实现" class="headerlink" title="接下来研究cache_t的实现:"></a>接下来研究<code>cache_t</code>的实现:</h3><pre><code>struct cache_t &#123;    struct bucket_t *_buckets;    mask_t _mask;    mask_t _occupied;&#125;struct bucket_t &#123;private:    cache_key_t _key;    IMP _imp;&#125;typedef unsigned int uint32_t;typedef uint32_t mask_t;  // x86_64 &amp; arm64 asm are less efficient with 16-bitstypedef unsigned long  uintptr_t;typedef uintptr_t cache_key_t;</code></pre><ul><li>mask：分配用来缓存bucket的总数。</li><li>occupied：表明目前实际占用的缓存bucket的个数。</li><li>bucket_t的结构体中存储了一个unsigned long和一个IMP。IMP是一个函数指针，指向了一个方法的具体实现。</li><li>bucket_t *_buckets其实就是一个散列表，用来存储Method的链表。</li></ul><p>Cache的作用主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。</p><p><a href="https://developer.apple.com/reference/objectivec/objective_c_runtime?language=objc">Runtime 系统库</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Objective-C Runtime是一个Runtime库，基本上是用C和汇编完成的，使C具有了面向对象的能力。这也使得Objective-C语言成为了一个动态语言。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="Objective-C" scheme="http://aeronxie.github.io/tags/Objective-C/"/>
    
    <category term="runtime" scheme="http://aeronxie.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>最近面试总结</title>
    <link href="http://aeronxie.github.io/post/6c7694ae.html"/>
    <id>http://aeronxie.github.io/post/6c7694ae.html</id>
    <published>2016-11-06T06:32:05.000Z</published>
    <updated>2023-03-25T14:39:55.745Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在小公司呆啦三个月之后，最后由于某种原因离开了，但是最公司的氛围确实很不错的，然后各种大神，反正在公司这段时间，基本都是被虐过来的，毕竟他们都是从BAT跳过来的，额。。说了这么多废话，其实就是想说，实习是可以学到很多东西的.在工作之余，我基本都没有在玩，周末回去图书馆学习，补上落下太多的知识，然后从刚开始实习到现在，基本面了十几家吧，大大小小的公司都有，第一次在腾讯面试，算法被虐了，美团编译原理被虐了。。。之后就沉迷于学习中，刷了剑指offer，leetcode。。各种基础，最后幸运的拿到了新浪、搜狗、乐视的offer。</p></blockquote><span id="more"></span><h4 id="面试题大体上都是数据结构、算法、操作系统、编译原理、网络和iOS基本知识点"><a href="#面试题大体上都是数据结构、算法、操作系统、编译原理、网络和iOS基本知识点" class="headerlink" title="面试题大体上都是数据结构、算法、操作系统、编译原理、网络和iOS基本知识点"></a>面试题大体上都是数据结构、算法、操作系统、编译原理、网络和iOS基本知识点</h4><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><pre><code>1.自己写一个算法，去重（比如：144257836236）2.一个数组的逆序对3.翻转链表，链表的倒数第k个节点，判断链表是否有环，链表的中间节点。。。4.数组中连续和相等的对数5.把数组中的奇偶数分开6.字符串的逆序 （I am a Student. -&gt; Student a am I）7.kmp算法至少也要了解</code></pre><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><pre><code>基本排序1.至少能够写出归并排序、快速排序、堆排序、冒泡排序，并熟悉各种排序的最好时间复杂度和最坏时间复杂度，以及空间复杂度.2.二叉排序树，AVL树，红黑树，B+树以及图</code></pre><blockquote><p>LZ 在面试的时候就被问到了数据库索引的原理，为什么B+树的磁盘查找效率要高，而红黑树要低，需要分析和对比其中的区别和原理    </p></blockquote><h4 id="iOS基础"><a href="#iOS基础" class="headerlink" title="iOS基础"></a>iOS基础</h4><pre><code>1.SDWebImage 的实现原理以及使用时内部的流程，如果让你实现一个这样的库应该怎么入手以及使用什么数据结构2.AFNetworking 的实现原理，内部使用的是什么，NSURLConnection内部使用的是什么，ASIHTTP 是基于什么开发的3.Block的数据结构，以及有哪几种block，然后block属性使用什么关键字，为什么在block中全局变量、静态变量可以直接改变外部的值，而自动变量不可以4.集合set的实现原理，有序set的实现原理5.NSString 为什么需要用copy关键字，用strong就不可以么？6.KVO的实现原理和缺陷？7.Runtime中的优化？8.GCD和NSOperation的区别？9.子线程里面，需要加autoreleasepool吗？10.autorelease对象什么时候释放11.哪几种情况会造成内存泄露？12.断点续传怎么实现？需要设置什么？13.HTTP请求过程？14.如果你写一个工具检测循环引用，该怎么考虑，用到什么数据结构（其实就是有向图查找环的过程）15.使用`imageNamed:`方法显示图片，图片什么时候会释放？</code></pre><p>之后就会问项目，比如你觉得在项目中遇到的最大难题是什么，是如何解决的，你在项目中出于什么角色，为什么你不开发安卓而是iOS。。。。</p><h4 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h4><pre><code>1.已知A、B在C之后编译，如何知道三者的编译顺序2.方法调用是在什么地方还有几个。。。但是不太记得了 = =</code></pre><p>额。。大概记得这么多了，最后还是要说基础很重要。。。LZ 不是计算机系的，所以很多东西大学都没接触到，都需要自己学，大家一起加油吧~~~！！！        </p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在小公司呆啦三个月之后，最后由于某种原因离开了，但是最公司的氛围确实很不错的，然后各种大神，反正在公司这段时间，基本都是被虐过来的，毕竟他们都是从BAT跳过来的，额。。说了这么多废话，其实就是想说，实习是可以学到很多东西的.在工作之余，我基本都没有在玩，周末回去图书馆学习，补上落下太多的知识，然后从刚开始实习到现在，基本面了十几家吧，大大小小的公司都有，第一次在腾讯面试，算法被虐了，美团编译原理被虐了。。。之后就沉迷于学习中，刷了剑指offer，leetcode。。各种基础，最后幸运的拿到了新浪、搜狗、乐视的offer。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="面试" scheme="http://aeronxie.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>链表学习</title>
    <link href="http://aeronxie.github.io/post/66ad38b.html"/>
    <id>http://aeronxie.github.io/post/66ad38b.html</id>
    <published>2016-07-01T07:00:09.000Z</published>
    <updated>2023-03-25T14:39:54.186Z</updated>
    
    <content type="html"><![CDATA[<p>链表问题在面试过程中也是很重要也很基础的一部分，链表本身很灵活，很考查编程功底，所以是很值得考的地方。我将复习过程中觉得比较好的链表问题整理了下。</p><p>下面是本文所要用到链表节点的定义：</p><pre><code>struct ListNode &#123;    int data;    ListNode *next;&#125;;</code></pre><span id="more"></span><h2 id="1-在O-1-时间删除链表节点"><a href="#1-在O-1-时间删除链表节点" class="headerlink" title="1. 在O(1)时间删除链表节点"></a>1. 在O(1)时间删除链表节点</h2><p>题目描述：给定链表的头指针和一个节点指针，在O(1)时间删除该节点。</p><blockquote><p>分析：在链表中删除一个结点，最常规的做法是从链表的头结点开始，顺序查找要删除的结点，找到之后再删除。由于需要顺序查找，时间复杂度自然就是O(n) 了。<br>我们之所以需要从头结点开始查找要删除的结点，是因为我们需要得到要删除的结点的前面一个结点。我们试着换一种思路。我们可以从给定的结点得到它的下一个结点。这个时候我们实际删除的是它的下一个结点，由于我们已经得到实际删除的结点的前面一个结点，因此完全是可以实现的。当然，在删除之前，我们需要需要把给定的结点的下一个结点的数据拷贝到给定的结点中。此时，时间复杂度为O(1)。</p></blockquote><p>代码如下:</p><pre><code>void deleteListNode(ListNode *current) &#123;    if (current != NULL &amp;&amp; current-&gt;next != NULL) &#123;        ListNode *pNext = current-&gt;next;        current-&gt;data = pNext-&gt;data;        current-&gt;next = pNext-&gt;next;        delete pNext;    &#125;&#125;</code></pre><h2 id="2-反转单链表"><a href="#2-反转单链表" class="headerlink" title="2. 反转单链表"></a>2. 反转单链表</h2><p>题目描述：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p><blockquote><p>分析：假设有链表A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G。在反转链表过程中的某一阶段，其链表指针指向为：A&lt;-B&lt;-C&lt;-D  E-&gt;F-&gt;G。也就是说在结点D之前的所有结点都已经反转，而结点D后面的结点E开始的所有结点都没有反转。这样D跟E之间存在了断裂。我们如果要实现链表的反转，会有以下几个重要步骤：</p></blockquote><blockquote><ol><li>D-&gt;E变为D-&gt;C，指针反转</li><li>指针往后移动一个，操作下一个结点E</li><li>结合1.2我们发现需要操作3个指针，分别是C,D,E(我们使用p,q,r表示)。<br>因此可以考虑存储C/D/E三个结点的指针，通过这三个结点的指针实现反转。</li></ol></blockquote><p>我们通过以下图表来说明：</p><pre><code>p = head;q = head-&gt;next;</code></pre><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/1.gif"></p><pre><code>head-&gt;next = NULL;</code></pre><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/2.gif"></p><pre><code>现在进入循环体，这是第一次循环r = q-&gt;next;q-&gt;next = p;</code></pre><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/3.gif"></p><pre><code>p = q;q =r;</code></pre><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/4.gif"></p><pre><code>第二次循环r = q-&gt;next;</code></pre><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/5.gif"></p><pre><code>q-&gt;next = p; </code></pre><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/6.gif"></p><pre><code>p = q;</code></pre><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/7.gif"></p><pre><code>q = r;</code></pre><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/8.gif"></p><p>第三次循环。。。。。</p><p>代码如下：</p><pre><code>ListNode *ReverseListNode(ListNode *head) &#123;    if (head == NULL || head-&gt;next == NULL)        return head;    ListNode *p,*q,*r;    p = head;    q = head-&gt;next;    head-&gt;next = NULL;    while (q) &#123;        r = q-&gt;next;        q-&gt;next = p;        p = q;        q = r;    &#125;    head = p;    return head;&#125;    </code></pre><h2 id="3-求链表的中间节点"><a href="#3-求链表的中间节点" class="headerlink" title="3. 求链表的中间节点"></a>3. 求链表的中间节点</h2><p>题目描述：求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。</p><blockquote><p>分析：此题可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法，就是通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。</p></blockquote><p>代码如下:</p><pre><code>ListNode *MiddleNode(ListNode *head) &#123;    if (head == NULL)        return NULL;    ListNode *slow,*fast;    slow = fast = head;    //如果要求在链表长度为偶数的情况下，返回中间两个节点的第一个，可以用下面的循环条件    //while(fast &amp;&amp; fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL)    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;    &#125;    return slow;&#125;</code></pre><h2 id="4-判断单链表是否存在环"><a href="#4-判断单链表是否存在环" class="headerlink" title="4. 判断单链表是否存在环"></a>4. 判断单链表是否存在环</h2><p>题目描述：输入一个单向链表，判断链表是否有环？</p><blockquote><p>分析：通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。</p></blockquote><p>代码如下： </p><pre><code>bool hasCircle(ListNode *head,ListNode *circleNode) &#123;    ListNode *slow,*fast;    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;        if (fast == slow) &#123;            circleNode = fast;            return true;        &#125;    &#125;    return false;&#125;</code></pre><h2 id="5-找到环的入口点"><a href="#5-找到环的入口点" class="headerlink" title="5. 找到环的入口点"></a>5. 找到环的入口点</h2><p>题目描述：输入一个单向链表，判断链表是否有环。如果链表存在环，如何找到环的入口点？</p><blockquote><p>解题思路： 由上题可知，按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。</p></blockquote><blockquote><p>为什么？：假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有：</p></blockquote><blockquote><p>p1走的路径： a+b ＝ n；<br>p2走的路径： a+b+k<em>L = 2</em>n； p2 比 p1 多走了k圈环路，总路程是p1的2倍</p></blockquote><blockquote><p>根据上述公式可以得到 k*L=a+b=n显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2从头开始走的话，经过n步，也会达到相遇点M。</p></blockquote><blockquote><p>显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。</p></blockquote><p>代码如下：</p><pre><code>ListNode *findLoopPort(ListNode *head) &#123;    if (head == NULL || head-&gt;next == NULL)        return NULL;    ListNode *slow,*fast;    slow = fast = head;    // 判断是否存在环    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;        if (slow == fast)            break;    &#125;    //不存在环    if (fast != slow)        return NULL;    //快指针从头开始走，步长变为1    fast = head;    //两者相遇即为入口点    while (fast != slow) &#123;        fast = fast-&gt;next;        slow = slow-&gt;next;    &#125;    return fast;&#125;</code></pre><h2 id="6-编程判断两个链表是否相交"><a href="#6-编程判断两个链表是否相交" class="headerlink" title="6.编程判断两个链表是否相交"></a>6.编程判断两个链表是否相交</h2><p>题目描述：给出两个单向链表的头指针（如下图所示），比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。<br><img src="http://ww2.sinaimg.cn/large/81b78497tw1eesdi7bb2kj20d403qaa0.jpg"></p><blockquote><p>解题思路：</p></blockquote><blockquote><p>1.直接循环判断第一个链表的每个节点是否在第二个链表中。但，这种方法的时间复杂度为O(Length(h1) * Length(h2))。显然，我们得找到一种更为有效的方法，至少不能是O（N^2）的复杂度。</p></blockquote><blockquote><p>2.针对第一个链表直接构造hash表，然后查询hash表，判断第二个链表的每个节点是否在hash表出现，如果所有的第二个链表的节点都能在hash表中找到，即说明第二个链表与第一个链表有相同的节点。时间复杂度为为线性：O(Length(h1) + Length(h2))，同时为了存储第一个链表的所有节点，空间复杂度为O(Length(h1))。是否还有更好的方法呢，既能够以线性时间复杂度解决问题，又能减少存储空间？</p></blockquote><blockquote><p>3.转换为环的问题。把第二个链表接在第一个链表后面，如果得到的链表有环，则说明两个链表相交。如何判断有环的问题上面已经讨论过了，但这里有更简单的方法。因为如果有环，则第二个链表的表头一定也在环上，即第二个链表会构成一个循环链表，我们只需要遍历第二个链表，看是否会回到起始点就可以判断出来。这个方法的时间复杂度是线性的，空间是常熟。</p></blockquote><blockquote><p>4.进一步考虑“如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的”这个特点，我们可以知道，如果它们相交，则最后一个节点一定是共有的。而我们很容易能得到链表的最后一个节点，所以这成了我们简化解法的一个主要突破口。那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。<br>所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。这样我们就得到了一个时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1)，显然比解法三更胜一筹。</p></blockquote><p>解法四代码如下: </p><pre><code>bool isIntersect(ListNode *head1,ListNode *head2) &#123;    if (head1 == NULL || head2 == NULL)        return  NULL;    while (head1-&gt;next != NULL) &#123;        head1 = head1-&gt;next;    &#125;    while (head2-&gt;next != NULL ) &#123;        head2 = head2-&gt;next;    &#125;    if (head1==head2)        return true;    else return false;&#125;</code></pre><h2 id="7-链表有环，如何判断相交"><a href="#7-链表有环，如何判断相交" class="headerlink" title="7.链表有环，如何判断相交"></a>7.链表有环，如何判断相交</h2><p>题目描述：上面的问题都是针对链表无环的，那么如果现在，链表是有环的呢?上面的方法还同样有效么?</p><blockquote><p>分析：如果有环且两个链表相交，则两个链表都有共同一个环，即环上的任意一个节点都存在于两个链表上。因此，就可以判断一链表上俩指针相遇的那个节点，在不在另一条链表上。    </p></blockquote><p>代码如下：</p><pre><code>bool isIntersectWithLoop(ListNode *head1,ListNode *head2) &#123;    ListNode *circleNode1,*circleNode2;    //判断链表带不带环，并保存环内节点    if (!hasCircle(head1, circleNode1))        return false;    if (!hasCircle(head2, circleNode2))        return false;    ListNode *temp = circleNode2-&gt;next;    while (temp != circleNode2) &#123;        if (temp == circleNode1)            return true;        temp = temp-&gt;next;    &#125;    return false;&#125;</code></pre><h2 id="8-链表中倒数第k个节点"><a href="#8-链表中倒数第k个节点" class="headerlink" title="8.链表中倒数第k个节点"></a>8.链表中倒数第k个节点</h2><p>题目描述：输入一个链表，输出该链表中倒数第k个结点。</p><blockquote><p>为了实现一次遍历链表就能找到倒数第k个结点，我们可以定义两个指针，第一个从链表的头指针开始遍历向前走k-1，第二个指针保持不动，从第K步开始，第二个指针也开始从链表的头指针开始遍历.由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针正好是第k个结点.</p></blockquote><p>代码如下:</p><pre><code>ListNode *FindthToTail(ListNode *phead,unsigned int k) &#123;    if (phead == NULL || phead-&gt;next == NULL) &#123;        return NULL;    &#125;    ListNode *pFast = phead;    ListNode *pLow = NULL;    for (unsigned int i = 0; i&lt;k-1; i++) &#123;        pFast = pFast-&gt;next;    &#125;    pLow = phead;    while (pFast-&gt; next != NULL) &#123;        pFast = pFast-&gt;next;        pLow = pLow-&gt;next;    &#125;    return pLow;&#125;</code></pre><h2 id="9-合并两个排序的链表"><a href="#9-合并两个排序的链表" class="headerlink" title="9.合并两个排序的链表"></a>9.合并两个排序的链表</h2><p>题目描述：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的.</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/lian01.png"></p><blockquote><p>链表1的头结点的值小于链表2的头结点的值，因此链表1的头结点将是合并后链表的头结点.在剩余的结点中，链表2的头结点的值小于链表1的头结点的值，因此链表2的头结点是剩余结点的头结点，把这个结点和之前已经合并好的链表的尾结点链接起来.</p></blockquote><p>代码如下:</p><pre><code>ListNode *Merge (ListNode *head1, ListNode *head2) &#123;    if (head1 == NULL) &#123;        return head2;    &#125; else if (head2 == NULL)        return head1;    ListNode *mergedHead = NULL;    if (head1-&gt;data &lt; head2-&gt;data) &#123;        mergedHead = head1;        mergedHead-&gt;next = Merge(head1-&gt;next,head2);    &#125; else &#123;        mergedHead = head2;        mergedHead-&gt;next = Merge(head1,head2-&gt;next);    &#125;    return mergedHead;&#125;</code></pre><h2 id="10-两个链表的第一个公共结点"><a href="#10-两个链表的第一个公共结点" class="headerlink" title="10.两个链表的第一个公共结点"></a>10.两个链表的第一个公共结点</h2><p>题目描述：输入两个链表，找出它们的第一个公共结点.</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/lian02.png"></p><blockquote><p>从链表结点的定义可以看出，这两个链表是单向链表，如果两个单向链表有公共结点，那么这两个链表从某一结点开始，他们的next都是指向同一个结点.但是由于是单向链表的结点，每个结点只有一个next，因此从第一个公共结点开始，之后他们所有结点都是重合的，不可能再出现分叉。</p></blockquote><p>代码如下:</p><pre><code>ListNode *FindFirstCommonNode(ListNode *head1, ListNode *head2) &#123;    // 得到两个链表长度    unsigned int nLength1 = GetListLength(head1);    unsigned int nLength2 = GetListLength(head2);    int nLengthDiff = nLength1 - nLength2;    ListNode *pListHeadLong = head1;    ListNode *pListHeadShort = head2;    if (nLength2 &gt; nLength1) &#123;        pListHeadLong = head2;        pListHeadShort = head1;        nLengthDiff = nLength2 - nLength1;    &#125;    // 长链表先走    for (int i = 0; i&lt;nLengthDiff;i++) &#123;        pListHeadLong = pListHeadLong-&gt;next;    &#125;    while (pListHeadLong != NULL &amp;&amp; pListHeadShort != NULL &amp;&amp; pListHeadShort != pListHeadLong) &#123;        pListHeadLong = pListHeadLong-&gt;next;        pListHeadShort = pListHeadShort-&gt;next;    &#125;    ListNode *pCommonNode = pListHeadLong;    return pCommonNode;&#125;// 获取链表长度unsigned int GetListLength(ListNode *head) &#123;    unsigned int length = 0;    ListNode *pNode = head;    while (head != NULL) &#123;        length ++;        pNode = pNode-&gt;next;    &#125;    return length;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表问题在面试过程中也是很重要也很基础的一部分，链表本身很灵活，很考查编程功底，所以是很值得考的地方。我将复习过程中觉得比较好的链表问题整理了下。&lt;/p&gt;
&lt;p&gt;下面是本文所要用到链表节点的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct ListNode &amp;#123;
    int data;
    ListNode *next;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="链表" scheme="http://aeronxie.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="C++" scheme="http://aeronxie.github.io/tags/C/"/>
    
    <category term="数据结构" scheme="http://aeronxie.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>在 CentOS 下搭建 PPTP</title>
    <link href="http://aeronxie.github.io/post/3dd6bfb9.html"/>
    <id>http://aeronxie.github.io/post/3dd6bfb9.html</id>
    <published>2016-06-30T02:39:06.000Z</published>
    <updated>2023-03-25T14:39:55.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="验证-ppp"><a href="#验证-ppp" class="headerlink" title="验证 ppp"></a>验证 ppp</h3><p>用cat命令检查是否开启ppp，一般服务器都是开启的。</p><pre><code>cat /dev/ppp  cat: /dev/ppp: No such device or address  </code></pre><p>出现这个结果，说明 ppp 没有安装</p><span id="more"></span><h3 id="安装-PPP"><a href="#安装-PPP" class="headerlink" title="安装 PPP"></a>安装 PPP</h3><pre><code>yum update  yum -y install ppp iptables  </code></pre><p>安装 iptables 是为了做 NAT，让 PPTP 客户端能够通过 PPTP 服务器上外网，不过</p><p>一般情况下 iptables 默认都是系统装好后就已经有了。</p><p>我们来看一下安装的 ppp 是什么版本</p><p>可以看到是 ppp 版本是 2.4.5-10.el6 在网站 <a href="http://poptop.sourceforge.net/yum/stable/packages/">sourceforge</a> 上有所有版本的 PPTP，选择对应的版本下载。</p><pre><code>cd \tmp  wget http://poptop.sourceforge.net/yum/stable/packages/pptpd-1.4.0-1.el6.x86_64.rpm  rpm -ivh pptpd-1.4.0-1.el6.x86_64.rpm  </code></pre><p>安装到这就完了。</p><h3 id="配置-PPTP"><a href="#配置-PPTP" class="headerlink" title="配置 PPTP"></a>配置 PPTP</h3><h4 id="1、-添加-服务端和客户端-IP"><a href="#1、-添加-服务端和客户端-IP" class="headerlink" title="1、 添加 服务端和客户端 IP"></a>1、 添加 服务端和客户端 IP</h4><pre><code>vi /etc/pptpd.conf  </code></pre><p>在最底下添加这两行</p><pre><code>localip 192.168.2.1  remoteip 192.168.2.10-100  </code></pre><p>localip 是 pptp 服务器端 IP</p><p>remoteip 是客户端获取的 IP 地址范围</p><h4 id="2、-添加-DNS-服务器"><a href="#2、-添加-DNS-服务器" class="headerlink" title="2、 添加 DNS 服务器"></a>2、 添加 DNS 服务器</h4><pre><code>vi /etc/ppp/options.pptpd  </code></pre><p>在最后添加这三行，你也可以改成自己想要的 DNS 服务器</p><pre><code># DNSms-dns 8.8.8.8  ms-dns 8.8.4.4  </code></pre><h4 id="3、-添加用户"><a href="#3、-添加用户" class="headerlink" title="3、 添加用户"></a>3、 添加用户</h4><pre><code>vi /etc/ppp/chap-secrets  </code></pre><p>client 填用户名，server 填 pptpd 或者 *，secret 填用户密码，IP 填给用户分配的 IP 可以指定 IP，不指定的填 *</p><pre><code># Secrets for authentication using CHAP# client        server          secret                  IP addressesvpn_1           pptpd           password                *  vpn_2           pptpd           password                *  </code></pre><h4 id="4、-开启-IP-转发"><a href="#4、-开启-IP-转发" class="headerlink" title="4、 开启 IP 转发"></a>4、 开启 IP 转发</h4><pre><code>vi /etc/sysctl.conf  </code></pre><p>把 <code>net.ipv4.ip_forward</code> 改为 <code>1</code></p><p>执行下面命令使内核配置生效</p><pre><code>sysctl -p  </code></pre><p>要是出现这种情况，不用管可以忽略</p><pre><code>error: &quot;net.bridge.bridge-nf-call-ip6tables&quot; is an unknown key  error: &quot;net.bridge.bridge-nf-call-iptables&quot; is an unknown key  error: &quot;net.bridge.bridge-nf-call-arptables&quot; is an unknown key  </code></pre><h4 id="5、-配置-iptables-转发"><a href="#5、-配置-iptables-转发" class="headerlink" title="5、 配置 iptables 转发"></a>5、 配置 iptables 转发</h4><pre><code>iptables -t nat -A POSTROUTING -s 192.168.2.10/24 -j SNAT --to-source server_ip  </code></pre><p>这条命令是把 <code>192.168.2.10</code> 这个网段的 IP 通过你的服务器公网 IP 访问外网</p><p><code>192.168.2.10</code> 是在第一步在 <code>/etc/pptpd.conf</code> 设置的 <code>remoteip</code>，如果</p><p>你的设置跟教程里不一样，请改成你自己设置的 IP 段</p><p><code>server_ip</code> 改成你自己的服务器 IP</p><p>保存 iptables 配置</p><pre><code>service iptables save  </code></pre><h4 id="6、启动服务"><a href="#6、启动服务" class="headerlink" title="6、启动服务"></a>6、启动服务</h4><pre><code>service pptpd start  service iptables start  </code></pre><p>设置为开机启动</p><pre><code>chkconfig pptpd on  chkconfig iptables on  </code></pre><h3 id="接下来你就可以通过-VPN-采用-PPTP-连接方式-fanqiang-了"><a href="#接下来你就可以通过-VPN-采用-PPTP-连接方式-fanqiang-了" class="headerlink" title="接下来你就可以通过 VPN 采用 PPTP 连接方式 fanqiang 了"></a>接下来你就可以通过 VPN 采用 PPTP 连接方式 fanqiang 了</h3>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;验证-ppp&quot;&gt;&lt;a href=&quot;#验证-ppp&quot; class=&quot;headerlink&quot; title=&quot;验证 ppp&quot;&gt;&lt;/a&gt;验证 ppp&lt;/h3&gt;&lt;p&gt;用cat命令检查是否开启ppp，一般服务器都是开启的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /dev/ppp  
cat: /dev/ppp: No such device or address  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出现这个结果，说明 ppp 没有安装&lt;/p&gt;</summary>
    
    
    
    
    <category term="CentOS" scheme="http://aeronxie.github.io/tags/CentOS/"/>
    
    <category term="PPTP" scheme="http://aeronxie.github.io/tags/PPTP/"/>
    
    <category term="VPN" scheme="http://aeronxie.github.io/tags/VPN/"/>
    
    <category term="VPS" scheme="http://aeronxie.github.io/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>iOS图片处理</title>
    <link href="http://aeronxie.github.io/post/dd7dae3f.html"/>
    <id>http://aeronxie.github.io/post/dd7dae3f.html</id>
    <published>2016-06-29T07:02:28.000Z</published>
    <updated>2023-03-25T14:39:55.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何把-GIF-动图保存到相册？"><a href="#如何把-GIF-动图保存到相册？" class="headerlink" title="如何把 GIF 动图保存到相册？"></a>如何把 GIF 动图保存到相册？</h3><p>iOS 的相册是支持保存 GIF 和 APNG 动图的，只是不能直接播放。用 <code>[ALAssetsLibrary writeImageDataToSavedPhotosAlbum:metadata:completionBlock]</code> 可以直接把 APNG、GIF 的数据写入相册。如果图省事直接用 UIImageWriteToSavedPhotosAlbum() 写相册，那么图像会被强制转码为 PNG。</p><span id="more"></span><h3 id="将-UIImage-保存到磁盘，用什么方式最好？"><a href="#将-UIImage-保存到磁盘，用什么方式最好？" class="headerlink" title="将 UIImage 保存到磁盘，用什么方式最好？"></a>将 UIImage 保存到磁盘，用什么方式最好？</h3><p>目前来说，保存 UIImage 有三种方式：</p><ol><li>直接用 NSKeyedArchiver 把 UIImage 序列化保存，</li><li>用 UIImagePNGRepresentation() 先把图片转为 PNG 保存，</li><li>用 UIImageJPEGRepresentation() 把图片压缩成 JPEG 保存。</li></ol><p>实际上，<code>NSKeyedArchiver</code> 是调用了 <code>UIImagePNGRepresentation</code> 进行序列化的，用它来保存图片是消耗最大的。苹果对 JPEG 有硬编码和硬解码，保存成 JPEG 会大大缩减编码解码时间，也能减小文件体积。所以如果图片不包含透明像素时，<code>UIImageJPEGRepresentation(0.9)</code> 是最佳的图片保存方式，其次是 <code>UIImagePNGRepresentation()</code>。</p><h3 id="UIImage-缓存是怎么回事？"><a href="#UIImage-缓存是怎么回事？" class="headerlink" title="UIImage 缓存是怎么回事？"></a>UIImage 缓存是怎么回事？</h3><p>通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。据我观察，在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。</p><h3 id="我要是用-imageWithData-能不能避免缓存呢？"><a href="#我要是用-imageWithData-能不能避免缓存呢？" class="headerlink" title="我要是用 imageWithData 能不能避免缓存呢？"></a>我要是用 imageWithData 能不能避免缓存呢？</h3><p>不能。通过数据创建 UIImage 时，UIImage 底层是调用 ImageIO 的 <code>CGImageSourceCreateWithData()</code> 方法。该方法有个参数叫 ShouldCache，在 64 位的设备上，这个参数是默认开启的。这个图片也是同样在第一次显示到屏幕时才会被解码，随后解码数据被缓存到 CGImage 内部。与 imageNamed 创建的图片不同，如果这个图片被释放掉，其内部的解码数据也会被立刻释放。</p><h3 id="怎么能避免缓存呢？"><a href="#怎么能避免缓存呢？" class="headerlink" title="怎么能避免缓存呢？"></a>怎么能避免缓存呢？</h3><ol><li>手动调用 <code>CGImageSourceCreateWithData()</code> 来创建图片，并把 ShouldCache 和 ShouldCacheImmediately 关掉。这么做会导致每次图片显示到屏幕时，解码方法都会被调用，造成很大的 CPU 占用。</li><li>把图片用 <code>CGContextDrawImage()</code> 绘制到画布上，然后把画布的数据取出来当作图片。这也是常见的网络图片库的做法。</li></ol><h3 id="我能直接取到图片解码后的数据，而不是通过画布取到吗？"><a href="#我能直接取到图片解码后的数据，而不是通过画布取到吗？" class="headerlink" title="我能直接取到图片解码后的数据，而不是通过画布取到吗？"></a>我能直接取到图片解码后的数据，而不是通过画布取到吗？</h3><ol><li><code>CGImageSourceCreateWithData(data)</code> 创建 ImageSource。</li><li><code>CGImageSourceCreateImageAtIndex(source)</code> 创建一个未解码的 CGImage。</li><li><code>CGImageGetDataProvider(image)</code> 获取这个图片的数据源。</li><li><code>CGDataProviderCopyData(provider)</code> 从数据源获取直接解码的数据。<br>ImageIO 解码发生在最后一步，这样获得的数据是没有经过颜色类型转换的原生数据（比如灰度图像）。</li></ol><h3 id="如何判断一个文件的图片类型？"><a href="#如何判断一个文件的图片类型？" class="headerlink" title="如何判断一个文件的图片类型？"></a>如何判断一个文件的图片类型？</h3><p>通过读取文件或数据的头几个字节然后和对应图片格式标准进行比对。我在这里写了一个简单的函数，能很快速的判断图片格式。</p><h3 id="怎样像浏览器那样边下载边显示图片？"><a href="#怎样像浏览器那样边下载边显示图片？" class="headerlink" title="怎样像浏览器那样边下载边显示图片？"></a>怎样像浏览器那样边下载边显示图片？</h3><p>首先，图片本身有 3 种常见的编码方式：</p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/image_baseline.gif"></p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/image_interlaced.gif"></p><p><img src="http://7xoijj.com1.z0.glb.clouddn.com/image_progressive.gif"></p><ul><li>第一种是 baseline，即逐行扫描。默认情况下，JPEG、PNG、GIF 都是这种保存方式。</li><li>第二种是 interlaced，即隔行扫描。PNG 和 GIF 在保存时可以选择这种格式。</li><li>第三种是 progressive，即渐进式。JPEG 在保存时可以选择这种方式。<br>在下载图片时，首先用 <code>CGImageSourceCreateIncremental(NULL)</code> 创建一个空的图片源，随后在获得新数据时调用<br><code>CGImageSourceUpdateData(data, false)</code> 来更新图片源，最后在用 <code>CGImageSourceCreateImageAtIndex()</code> 创建图片来显示。</li></ul><p>(转自Ibireme的博客)                                     </p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;如何把-GIF-动图保存到相册？&quot;&gt;&lt;a href=&quot;#如何把-GIF-动图保存到相册？&quot; class=&quot;headerlink&quot; title=&quot;如何把 GIF 动图保存到相册？&quot;&gt;&lt;/a&gt;如何把 GIF 动图保存到相册？&lt;/h3&gt;&lt;p&gt;iOS 的相册是支持保存 GIF 和 APNG 动图的，只是不能直接播放。用 &lt;code&gt;[ALAssetsLibrary writeImageDataToSavedPhotosAlbum:metadata:completionBlock]&lt;/code&gt; 可以直接把 APNG、GIF 的数据写入相册。如果图省事直接用 UIImageWriteToSavedPhotosAlbum() 写相册，那么图像会被强制转码为 PNG。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>传感器的使用 (学习笔记)</title>
    <link href="http://aeronxie.github.io/post/d7f288de.html"/>
    <id>http://aeronxie.github.io/post/d7f288de.html</id>
    <published>2016-03-30T07:24:07.000Z</published>
    <updated>2023-03-25T14:39:54.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>iPhone内置的传感器有:</strong></p></blockquote><blockquote><p>运动传感器\加速度传感器\加速计（Motion/Accelerometer Sensor）</p></blockquote><blockquote><p>环境光传感器（Ambient Light Sensor）</p></blockquote><blockquote><p>距离传感器（Proximity Sensor）</p></blockquote><blockquote><p>磁力计传感器（Magnetometer Sensor）</p></blockquote><blockquote><p>内部温度传感器（Internal Temperature Sensor）</p></blockquote><blockquote><p>湿度传感器（Moisture Sensor）</p></blockquote><blockquote><p>陀螺仪（Gyroscope）</p></blockquote><span id="more"></span><h1 id="距离传感器"><a href="#距离传感器" class="headerlink" title="距离传感器"></a>距离传感器</h1><blockquote><p>感应是否有其他物体靠近设备屏幕（打电话自动锁屏）</p></blockquote><pre><code>// 开启距离感应功能[UIDevice currentDevice].proximityMonitoringEnabled = YES;// 监听距离感应的通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(proximityChange:) name:UIDeviceProximityStateDidChangeNotification object:nil];- (void)proximityChange:(NSNotificationCenter *)notification &#123;    if ([UIDevice currentDevice].proximityState == YES) &#123;        NSLog(@&quot;屏幕被遮挡了&quot;); &#125; else &#123;        NSLog(@&quot;屏幕被遮挡了&quot;);     &#125;&#125;</code></pre><h1 id="加速计"><a href="#加速计" class="headerlink" title="加速计"></a>加速计</h1><blockquote><p>用于检测设备的运动（比如摇晃,计步）<strong>检测设备在X、Y、Z轴上的加速度 （哪个方向有力的作用，哪个方向运动了）<br>根据加速度数值，就可以判断出在各个方向上的作用力度</strong></p></blockquote><blockquote><p>随着iPhone4的推出，加速度计全面升级，并引入了陀螺仪，与Motion（运动）相关的编程成为重头戏<br>苹果特地在iOS4中增加了专门处理Motion的框架  <strong><code>CoreMotion.framework</code></strong><br>Core Motion不仅能够提供实时的加速度值和旋转速度值，更重要的是，苹果在其中集成了很多牛逼的算法</p></blockquote><p><strong>Core Motion获取数据的两种方式:</strong></p><ul><li>push: 实时采集所有数据（采集频率高）</li><li>pull: 在有需要的时候，再主动去采集数据</li></ul><h4 id="Core-Motion的使用步骤（push）"><a href="#Core-Motion的使用步骤（push）" class="headerlink" title="Core Motion的使用步骤（push）"></a>Core Motion的使用步骤（push）</h4><ul><li>创建运动管理者对象 </li></ul><p><code>CMMotionManager *mgr = [[CMMotionManager alloc] init];</code></p><ul><li>判断加速计是否可用（最好判断） </li></ul><p><code>if (mgr.isAccelerometerAvailable) &#123; // 加速计可用 &#125;</code></p><ul><li>设置采样间隔 </li></ul><p><code>mgr.accelerometerUpdateInterval = 1.0/30.0; // 1秒钟采样30次</code></p><ul><li>开始采样（采样到数据就会调用handler，handler会在queue中执行）</li></ul><p><code>- (void)startAccelerometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMAccelerometerHandler)handler;</code></p><h4 id="Core-Motion的使用步骤（pull）"><a href="#Core-Motion的使用步骤（pull）" class="headerlink" title="Core Motion的使用步骤（pull）"></a>Core Motion的使用步骤（pull）</h4><ul><li>创建运动管理者对象</li></ul><p><code>CMMotionManager *mgr = [[CMMotionManager alloc] init];</code></p><ul><li>判断加速计是否可用（最好判断）</li></ul><p><code>if (mgr.isAccelerometerAvailable) &#123; // 加速计可用 &#125;</code></p><ul><li>开始采样</li></ul><p><code>- (void)startAccelerometerUpdates;</code></p><ul><li>在需要的时候采集加速度数据</li></ul><p><code>CMAcceleration acc = mgr.accelerometerData.acceleration; NSLog(@&quot;%f, %f, %f&quot;, acc.x, acc.y, acc.z);</code></p><h3 id="摇一摇"><a href="#摇一摇" class="headerlink" title="摇一摇"></a>摇一摇</h3><blockquote><p> 监控摇一摇的方法:</p></blockquote><blockquote><p>方法1：通过分析加速计数据来判断是否进行了摇一摇操作（比较复杂）</p></blockquote><blockquote><p>方法2：iOS自带的Shake监控API（非常简单）</p></blockquote><p>判断摇一摇的步骤：实现3个摇一摇监听方法</p><pre><code>- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event /** 检测到摇动 */- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event /** 摇动取消(被中断) */- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event /** 摇动结束 */</code></pre><h3 id="计步器"><a href="#计步器" class="headerlink" title="计步器"></a>计步器</h3><blockquote><p>CMStepCounter 类提供访问用户携带设备步行的步数接口，步行信息通过内置硬件去采集和存储，让第三方可以通过查询数据来获知用户最近的身体运动情况。第三方可以通过这个类收集当前或任何历史的步行数据。</p></blockquote><p>这个类使用起来非常的简单：</p><ul><li>用于判断设备是否支持计步</li></ul><p><code>+ (BOOL)isStepCountingAvailable;</code></p><ul><li>收集并返回某一时间段内的历史步数数据（queue不能为nil）</li></ul><p><code>- (void)queryStepCountStartingFrom:(NSDate *)start                                 to:(NSDate *)end                            toQueue:(NSOperationQueue *)queue                        withHandler:(CMStepQueryHandler)handler;</code></p><ul><li>开始更新步数计数 （queue不能为nil）</li></ul><p><code>- (void)startStepCountingUpdatesToQueue:(NSOperationQueue *)queue                                updateOn:(NSInteger)stepCounts                             withHandler:(CMStepUpdateHandler)handler;</code></p><ul><li>停止更新步数计数</li></ul><p><code>- (void)stopStepCountingUpdates;</code></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;iPhone内置的传感器有:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;运动传感器\加速度传感器\加速计（Motion/Accelerometer Sensor）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;环境光传感器（Ambient Light Sensor）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;距离传感器（Proximity Sensor）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;磁力计传感器（Magnetometer Sensor）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;内部温度传感器（Internal Temperature Sensor）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;湿度传感器（Moisture Sensor）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;陀螺仪（Gyroscope）&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://aeronxie.github.io/tags/iOS/"/>
    
    <category term="传感器" scheme="http://aeronxie.github.io/tags/%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    
    <category term="Objective-C" scheme="http://aeronxie.github.io/tags/Objective-C/"/>
    
  </entry>
  
</feed>
